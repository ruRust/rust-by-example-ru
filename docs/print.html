<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Example</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A description">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/outdated.css">
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="index.html">Введение</a></li><li><a href="hello.html"><strong aria-hidden="true">1.</strong> Привет, мир!</a></li><li><ol class="section"><li><a href="hello/comment.html"><strong aria-hidden="true">1.1.</strong> Комментарии</a></li><li><a href="hello/print.html"><strong aria-hidden="true">1.2.</strong> Форматированный вывод</a></li><li><ol class="section"><li><a href="hello/print/print_debug.html"><strong aria-hidden="true">1.2.1.</strong> Debug</a></li><li><a href="hello/print/print_display.html"><strong aria-hidden="true">1.2.2.</strong> Display</a></li><li><ol class="section"><li><a href="hello/print/print_display/testcase_list.html"><strong aria-hidden="true">1.2.2.1.</strong> Пример: Список</a></li></ol></li><li><a href="hello/print/fmt.html"><strong aria-hidden="true">1.2.3.</strong> Форматирование</a></li></ol></li></ol></li><li><a href="primitives.html"><strong aria-hidden="true">2.</strong> Примитивы</a></li><li><ol class="section"><li><a href="primitives/literals.html"><strong aria-hidden="true">2.1.</strong> Литералы и операторы</a></li><li><a href="primitives/tuples.html"><strong aria-hidden="true">2.2.</strong> Кортежи</a></li><li><a href="primitives/array.html"><strong aria-hidden="true">2.3.</strong> Массив и срезы</a></li></ol></li><li><a href="custom_types.html"><strong aria-hidden="true">3.</strong> Пользовательские типы</a></li><li><ol class="section"><li><a href="custom_types/structs.html"><strong aria-hidden="true">3.1.</strong> Структуры</a></li><li><a href="custom_types/enum.html"><strong aria-hidden="true">3.2.</strong> Перечисления</a></li><li><ol class="section"><li><a href="custom_types/enum/enum_use.html"><strong aria-hidden="true">3.2.1.</strong> Декларация use</a></li><li><a href="custom_types/enum/c_like.html"><strong aria-hidden="true">3.2.2.</strong> C-подобные перечисления</a></li><li><a href="custom_types/enum/testcase_linked_list.html"><strong aria-hidden="true">3.2.3.</strong> Пример: Связанный список</a></li></ol></li><li><a href="custom_types/constants.html"><strong aria-hidden="true">3.3.</strong> Константы</a></li></ol></li><li><a href="variable_bindings.html"><strong aria-hidden="true">4.</strong> Связывание переменных</a></li><li><ol class="section"><li><a href="variable_bindings/mut.html"><strong aria-hidden="true">4.1.</strong> Изменяемость</a></li><li><a href="variable_bindings/scope.html"><strong aria-hidden="true">4.2.</strong> Область видимости и затенение</a></li><li><a href="variable_bindings/declare.html"><strong aria-hidden="true">4.3.</strong> Предварительное объявление</a></li></ol></li><li><a href="types.html"><strong aria-hidden="true">5.</strong> Типы</a></li><li><ol class="section"><li><a href="types/cast.html"><strong aria-hidden="true">5.1.</strong> Приведение типов</a></li><li><a href="types/literals.html"><strong aria-hidden="true">5.2.</strong> Литералы</a></li><li><a href="types/inference.html"><strong aria-hidden="true">5.3.</strong> Вывод типов</a></li><li><a href="types/alias.html"><strong aria-hidden="true">5.4.</strong> Псевдонимы</a></li></ol></li><li><a href="conversion.html"><strong aria-hidden="true">6.</strong> Преобразования</a></li><li><ol class="section"><li><a href="conversion/from_into.html"><strong aria-hidden="true">6.1.</strong> From и Into</a></li><li><a href="conversion/string.html"><strong aria-hidden="true">6.2.</strong> В и из String</a></li></ol></li><li><a href="expression.html"><strong aria-hidden="true">7.</strong> Выражения</a></li><li><a href="flow_control.html"><strong aria-hidden="true">8.</strong> Управление потоком</a></li><li><ol class="section"><li><a href="flow_control/if_else.html"><strong aria-hidden="true">8.1.</strong> if/else</a></li><li><a href="flow_control/loop.html"><strong aria-hidden="true">8.2.</strong> loop</a></li><li><ol class="section"><li><a href="flow_control/loop/nested.html"><strong aria-hidden="true">8.2.1.</strong> Вложенность и метки</a></li><li><a href="flow_control/loop/return.html"><strong aria-hidden="true">8.2.2.</strong> Возврат из циклов</a></li></ol></li><li><a href="flow_control/while.html"><strong aria-hidden="true">8.3.</strong> while</a></li><li><a href="flow_control/for.html"><strong aria-hidden="true">8.4.</strong> for и range</a></li><li><a href="flow_control/match.html"><strong aria-hidden="true">8.5.</strong> match</a></li><li><ol class="section"><li><a href="flow_control/match/destructuring.html"><strong aria-hidden="true">8.5.1.</strong> Деструктуризация</a></li><li><ol class="section"><li><a href="flow_control/match/destructuring/destructure_tuple.html"><strong aria-hidden="true">8.5.1.1.</strong> Кортежи</a></li><li><a href="flow_control/match/destructuring/destructure_enum.html"><strong aria-hidden="true">8.5.1.2.</strong> Перечисления</a></li><li><a href="flow_control/match/destructuring/destructure_pointers.html"><strong aria-hidden="true">8.5.1.3.</strong> Указатели и ссылки</a></li><li><a href="flow_control/match/destructuring/destructure_structures.html"><strong aria-hidden="true">8.5.1.4.</strong> Структуры</a></li></ol></li><li><a href="flow_control/match/guard.html"><strong aria-hidden="true">8.5.2.</strong> Ограничители шаблонов</a></li><li><a href="flow_control/match/binding.html"><strong aria-hidden="true">8.5.3.</strong> Связывание</a></li></ol></li><li><a href="flow_control/if_let.html"><strong aria-hidden="true">8.6.</strong> if let</a></li><li><a href="flow_control/while_let.html"><strong aria-hidden="true">8.7.</strong> while let</a></li></ol></li><li><a href="fn.html"><strong aria-hidden="true">9.</strong> Функции</a></li><li><ol class="section"><li><a href="fn/methods.html"><strong aria-hidden="true">9.1.</strong> Методы</a></li><li><a href="fn/closures.html"><strong aria-hidden="true">9.2.</strong> Замыкания</a></li><li><ol class="section"><li><a href="fn/closures/capture.html"><strong aria-hidden="true">9.2.1.</strong> Захват</a></li><li><a href="fn/closures/input_parameters.html"><strong aria-hidden="true">9.2.2.</strong> Как входные параметры</a></li><li><a href="fn/closures/anonymity.html"><strong aria-hidden="true">9.2.3.</strong> Анонимность типов</a></li><li><a href="fn/closures/input_functions.html"><strong aria-hidden="true">9.2.4.</strong> Входные функции</a></li><li><a href="fn/closures/output_parameters.html"><strong aria-hidden="true">9.2.5.</strong> Как выходные параметры</a></li><li><a href="fn/closures/closure_examples.html"><strong aria-hidden="true">9.2.6.</strong> Примеры из стандартной библиотеки</a></li><li><ol class="section"><li><a href="fn/closures/closure_examples/iter_any.html"><strong aria-hidden="true">9.2.6.1.</strong> Iterator::any</a></li><li><a href="fn/closures/closure_examples/iter_find.html"><strong aria-hidden="true">9.2.6.2.</strong> Iterator::find</a></li></ol></li></ol></li><li><a href="fn/hof.html"><strong aria-hidden="true">9.3.</strong> Функции высшего порядка</a></li><li><a href="fn/diverging.html"><strong aria-hidden="true">9.4.</strong> Расходящиеся функции</a></li></ol></li><li><a href="mod.html"><strong aria-hidden="true">10.</strong> Модули</a></li><li><ol class="section"><li><a href="mod/visibility.html"><strong aria-hidden="true">10.1.</strong> Видимость</a></li><li><a href="mod/struct_visibility.html"><strong aria-hidden="true">10.2.</strong> Видимость структуры</a></li><li><a href="mod/use.html"><strong aria-hidden="true">10.3.</strong> Декларация use</a></li><li><a href="mod/super.html"><strong aria-hidden="true">10.4.</strong> super и self</a></li><li><a href="mod/split.html"><strong aria-hidden="true">10.5.</strong> Иерархия файлов</a></li></ol></li><li><a href="crates.html"><strong aria-hidden="true">11.</strong> Контейнеры</a></li><li><ol class="section"><li><a href="crates/lib.html"><strong aria-hidden="true">11.1.</strong> Библиотеки</a></li><li><a href="crates/link.html"><strong aria-hidden="true">11.2.</strong> extern crate</a></li></ol></li><li><a href="cargo.html"><strong aria-hidden="true">12.</strong> Cargo</a></li><li><ol class="section"><li><a href="cargo/deps.html"><strong aria-hidden="true">12.1.</strong> Зависимости</a></li><li><a href="cargo/conventions.html"><strong aria-hidden="true">12.2.</strong> Соглашения</a></li><li><a href="cargo/test.html"><strong aria-hidden="true">12.3.</strong> Тестирование</a></li><li><a href="cargo/build_scripts.html"><strong aria-hidden="true">12.4.</strong> Скрипты сборки</a></li></ol></li><li><a href="attribute.html"><strong aria-hidden="true">13.</strong> Атрибуты</a></li><li><ol class="section"><li><a href="attribute/unused.html"><strong aria-hidden="true">13.1.</strong> dead_code</a></li><li><a href="attribute/crate.html"><strong aria-hidden="true">13.2.</strong> Контейнеры</a></li><li><a href="attribute/cfg.html"><strong aria-hidden="true">13.3.</strong> cfg</a></li><li><ol class="section"><li><a href="attribute/cfg/custom.html"><strong aria-hidden="true">13.3.1.</strong> Собственные условия</a></li></ol></li></ol></li><li><a href="generics.html"><strong aria-hidden="true">14.</strong> Обобщения</a></li><li><ol class="section"><li><a href="generics/gen_fn.html"><strong aria-hidden="true">14.1.</strong> Функции</a></li><li><a href="generics/impl.html"><strong aria-hidden="true">14.2.</strong> Реализация</a></li><li><a href="generics/gen_trait.html"><strong aria-hidden="true">14.3.</strong> Типажи</a></li><li><a href="generics/bounds.html"><strong aria-hidden="true">14.4.</strong> Ограничения</a></li><li><ol class="section"><li><a href="generics/bounds/testcase_empty.html"><strong aria-hidden="true">14.4.1.</strong> Пример: пустые ограничения</a></li></ol></li><li><a href="generics/multi_bounds.html"><strong aria-hidden="true">14.5.</strong> Множественные ограничения</a></li><li><a href="generics/where.html"><strong aria-hidden="true">14.6.</strong> Утверждения where</a></li><li><a href="generics/new_types.html"><strong aria-hidden="true">14.7.</strong> New Type идиома</a></li><li><a href="generics/assoc_items.html"><strong aria-hidden="true">14.8.</strong> Ассоциированные элементы</a></li><li><ol class="section"><li><a href="generics/assoc_items/the_problem.html"><strong aria-hidden="true">14.8.1.</strong> Проблема</a></li><li><a href="generics/assoc_items/types.html"><strong aria-hidden="true">14.8.2.</strong> Ассоциированные типы</a></li></ol></li><li><a href="generics/phantom.html"><strong aria-hidden="true">14.9.</strong> PhantomData-параметры</a></li><li><ol class="section"><li><a href="generics/phantom/testcase_units.html"><strong aria-hidden="true">14.9.1.</strong> Пример: unit clarification</a></li></ol></li></ol></li><li><a href="scope.html"><strong aria-hidden="true">15.</strong> Правила области видимости</a></li><li><ol class="section"><li><a href="scope/raii.html"><strong aria-hidden="true">15.1.</strong> RAII</a></li><li><a href="scope/move.html"><strong aria-hidden="true">15.2.</strong> Владение и перемещение</a></li><li><ol class="section"><li><a href="scope/move/mut.html"><strong aria-hidden="true">15.2.1.</strong> Изменяемость</a></li></ol></li><li><a href="scope/borrow.html"><strong aria-hidden="true">15.3.</strong> Заимствование</a></li><li><ol class="section"><li><a href="scope/borrow/mut.html"><strong aria-hidden="true">15.3.1.</strong> Mutability</a></li><li><a href="scope/borrow/freeze.html"><strong aria-hidden="true">15.3.2.</strong> Замораживание</a></li><li><a href="scope/borrow/alias.html"><strong aria-hidden="true">15.3.3.</strong> Алиасинг</a></li><li><a href="scope/borrow/ref.html"><strong aria-hidden="true">15.3.4.</strong> ref паттерн</a></li></ol></li><li><a href="scope/lifetime.html"><strong aria-hidden="true">15.4.</strong> Времена жизни</a></li><li><ol class="section"><li><a href="scope/lifetime/explicit.html"><strong aria-hidden="true">15.4.1.</strong> Явное аннотирование</a></li><li><a href="scope/lifetime/fn.html"><strong aria-hidden="true">15.4.2.</strong> Функции</a></li><li><a href="scope/lifetime/methods.html"><strong aria-hidden="true">15.4.3.</strong> Методы</a></li><li><a href="scope/lifetime/struct.html"><strong aria-hidden="true">15.4.4.</strong> Структуры</a></li><li><a href="scope/lifetime/trait.html"><strong aria-hidden="true">15.4.5.</strong> Типажи</a></li><li><a href="scope/lifetime/lifetime_bounds.html"><strong aria-hidden="true">15.4.6.</strong> Ограничения</a></li><li><a href="scope/lifetime/lifetime_coercion.html"><strong aria-hidden="true">15.4.7.</strong> Приведение (coercion)</a></li><li><a href="scope/lifetime/static_lifetime.html"><strong aria-hidden="true">15.4.8.</strong> Static</a></li><li><a href="scope/lifetime/elision.html"><strong aria-hidden="true">15.4.9.</strong> Сокрытие</a></li></ol></li></ol></li><li><a href="trait.html"><strong aria-hidden="true">16.</strong> Типажи</a></li><li><ol class="section"><li><a href="trait/derive.html"><strong aria-hidden="true">16.1.</strong> Атрибут Derive</a></li><li><a href="trait/ops.html"><strong aria-hidden="true">16.2.</strong> Перегрузка операторов</a></li><li><a href="trait/drop.html"><strong aria-hidden="true">16.3.</strong> Типаж Drop</a></li><li><a href="trait/iter.html"><strong aria-hidden="true">16.4.</strong> Итераторы</a></li><li><a href="trait/clone.html"><strong aria-hidden="true">16.5.</strong> Типаж Clone</a></li></ol></li><li><a href="macros.html"><strong aria-hidden="true">17.</strong> macro_rules!</a></li><li><ol class="section"><li><a href="macros/syntax.html"><strong aria-hidden="true">17.1.</strong> Синтаксис</a></li><li><ol class="section"><li><a href="macros/designators.html"><strong aria-hidden="true">17.1.1.</strong> Указатели</a></li><li><a href="macros/overload.html"><strong aria-hidden="true">17.1.2.</strong> Перегрузка</a></li><li><a href="macros/repeat.html"><strong aria-hidden="true">17.1.3.</strong> Повторение</a></li></ol></li><li><a href="macros/dry.html"><strong aria-hidden="true">17.2.</strong> DRY (Не повторяйся)</a></li><li><a href="macros/dsl.html"><strong aria-hidden="true">17.3.</strong> DSL (Domain Specific Languages)</a></li><li><a href="macros/variadics.html"><strong aria-hidden="true">17.4.</strong> Variadics</a></li></ol></li><li><a href="error.html"><strong aria-hidden="true">18.</strong> Обработка ошибок</a></li><li><ol class="section"><li><a href="error/panic.html"><strong aria-hidden="true">18.1.</strong> panic</a></li><li><a href="error/option_unwrap.html"><strong aria-hidden="true">18.2.</strong> Option &amp; unwrap</a></li><li><ol class="section"><li><a href="error/option_unwrap/map.html"><strong aria-hidden="true">18.2.1.</strong> Комбинаторы: map</a></li><li><a href="error/option_unwrap/and_then.html"><strong aria-hidden="true">18.2.2.</strong> Комбинаторы: and_then</a></li></ol></li><li><a href="error/result.html"><strong aria-hidden="true">18.3.</strong> Result</a></li><li><ol class="section"><li><a href="error/result/result_map.html"><strong aria-hidden="true">18.3.1.</strong> map для Result</a></li><li><a href="error/result/result_alias.html"><strong aria-hidden="true">18.3.2.</strong> Псевдонимы для Result</a></li><li><a href="error/result/early_returns.html"><strong aria-hidden="true">18.3.3.</strong> Преждевременный выход</a></li><li><a href="error/result/enter_question_mark.html"><strong aria-hidden="true">18.3.4.</strong> Введение ?</a></li></ol></li><li><a href="error/multiple_error_types.html"><strong aria-hidden="true">18.4.</strong> Несколько типов ошибок</a></li><li><ol class="section"><li><a href="error/multiple_error_types/option_result.html"><strong aria-hidden="true">18.4.1.</strong> Получение Result из Option</a></li><li><a href="error/multiple_error_types/define_error_type.html"><strong aria-hidden="true">18.4.2.</strong> Объявление типа ошибки</a></li><li><a href="error/multiple_error_types/boxing_errors.html"><strong aria-hidden="true">18.4.3.</strong> Упаковка ошибок (Box)</a></li><li><a href="error/multiple_error_types/reenter_question_mark.html"><strong aria-hidden="true">18.4.4.</strong> Другие способы использования ?</a></li><li><a href="error/multiple_error_types/wrap_error.html"><strong aria-hidden="true">18.4.5.</strong> Оборачивание ошибок</a></li></ol></li><li><a href="error/iter_result.html"><strong aria-hidden="true">18.5.</strong> Итерирование по Result</a></li></ol></li><li><a href="std.html"><strong aria-hidden="true">19.</strong> Типы стандартной библиотеки</a></li><li><ol class="section"><li><a href="std/box.html"><strong aria-hidden="true">19.1.</strong> Box, стек и куча</a></li><li><a href="std/vec.html"><strong aria-hidden="true">19.2.</strong> Вектора</a></li><li><a href="std/str.html"><strong aria-hidden="true">19.3.</strong> Strings</a></li><li><a href="std/option.html"><strong aria-hidden="true">19.4.</strong> Option</a></li><li><a href="std/result.html"><strong aria-hidden="true">19.5.</strong> Result</a></li><li><ol class="section"><li><a href="std/result/question_mark.html"><strong aria-hidden="true">19.5.1.</strong> ?</a></li></ol></li><li><a href="std/panic.html"><strong aria-hidden="true">19.6.</strong> panic!</a></li><li><a href="std/hash.html"><strong aria-hidden="true">19.7.</strong> HashMap</a></li><li><ol class="section"><li><a href="std/hash/alt_key_types.html"><strong aria-hidden="true">19.7.1.</strong> Альтернативные (пользовательские) типы ключей</a></li><li><a href="std/hash/hashset.html"><strong aria-hidden="true">19.7.2.</strong> HashSet</a></li></ol></li><li><a href="std/rc.html"><strong aria-hidden="true">19.8.</strong> Rc</a></li></ol></li><li><a href="std_misc.html"><strong aria-hidden="true">20.</strong> Разное в стандартной библиотеке</a></li><li><ol class="section"><li><a href="std_misc/threads.html"><strong aria-hidden="true">20.1.</strong> Потоки</a></li><li><ol class="section"><li><a href="std_misc/threads/testcase_mapreduce.html"><strong aria-hidden="true">20.1.1.</strong> Пример: map-reduce</a></li></ol></li><li><a href="std_misc/channels.html"><strong aria-hidden="true">20.2.</strong> Каналы</a></li><li><a href="std_misc/path.html"><strong aria-hidden="true">20.3.</strong> Path</a></li><li><a href="std_misc/file.html"><strong aria-hidden="true">20.4.</strong> Файловый ввод-вывод</a></li><li><ol class="section"><li><a href="std_misc/file/open.html"><strong aria-hidden="true">20.4.1.</strong> open</a></li><li><a href="std_misc/file/create.html"><strong aria-hidden="true">20.4.2.</strong> create</a></li><li><a href="std_misc/file/read_lines.html"><strong aria-hidden="true">20.4.3.</strong> read lines</a></li></ol></li><li><a href="std_misc/process.html"><strong aria-hidden="true">20.5.</strong> Дочерние процессы</a></li><li><ol class="section"><li><a href="std_misc/process/pipe.html"><strong aria-hidden="true">20.5.1.</strong> Pipes</a></li><li><a href="std_misc/process/wait.html"><strong aria-hidden="true">20.5.2.</strong> Ожидание</a></li></ol></li><li><a href="std_misc/fs.html"><strong aria-hidden="true">20.6.</strong> Работа с файловой системой</a></li><li><a href="std_misc/arg.html"><strong aria-hidden="true">20.7.</strong> Аргументы программы</a></li><li><ol class="section"><li><a href="std_misc/arg/matching.html"><strong aria-hidden="true">20.7.1.</strong> Парсинг аргументов</a></li></ol></li><li><a href="std_misc/ffi.html"><strong aria-hidden="true">20.8.</strong> Foreign Function Interface</a></li></ol></li><li><a href="testing.html"><strong aria-hidden="true">21.</strong> Тестирование</a></li><li><ol class="section"><li><a href="testing/unit_testing.html"><strong aria-hidden="true">21.1.</strong> Unit-тестирование</a></li><li><a href="testing/doc_testing.html"><strong aria-hidden="true">21.2.</strong> Тестирование документации</a></li><li><a href="testing/integration_testing.html"><strong aria-hidden="true">21.3.</strong> Интеграционное тестирование</a></li><li><a href="testing/dev_dependencies.html"><strong aria-hidden="true">21.4.</strong> dev-dependencies</a></li></ol></li><li><a href="unsafe.html"><strong aria-hidden="true">22.</strong> Unsafe операции</a></li><li><a href="compatibility.html"><strong aria-hidden="true">23.</strong> Совместимость</a></li><li><ol class="section"><li><a href="compatibility/raw_identifiers.html"><strong aria-hidden="true">23.1.</strong> Сырые идентификаторы</a></li></ol></li><li><a href="meta.html"><strong aria-hidden="true">24.</strong> Meta</a></li><li><ol class="section"><li><a href="meta/doc.html"><strong aria-hidden="true">24.1.</strong> Документация</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust By Example</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>
                <div id="draft-warning" class="alert warning">
    <span class="message">
      Адрес перевода изменился. Актуальная версия находится по адресу
      <a href="https://doc.rust-lang.ru/stable/rust-by-example/">
        https://doc.rust-lang.ru/stable/rust-by-example
      </a>.
    </span>
</div>
<script type="text/javascript">

</script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rust-на-примерах" id="rust-на-примерах">Rust на примерах</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a> - современный язык программирования, нацеленный на безопасность,
скорость и параллелизм. Данные цели выполняются при условии безопасной работы с памятью
без использования сборщика мусора.</p>
<p>Rust на примерах - это набор исполняемых примеров, которые иллюстрируют различные
концепции языка Rust, а так же возможности его стандартной библиотеки.
Для того, чтобы подчеркнуть ещё больше из этих примеров,
не забудьте <a href="https://www.rust-lang.org/tools/install">установить Rust на своём компьютере</a> и
проверить <a href="https://doc.rust-lang.org/std/">официальную документацию</a>. Если вы ранее не сталкивались с языком программирования Rust,
то советую вам для начала ознакомиться с <a href="http://rustbook.ru/">русскоязычной книгой по Rust</a>. Кроме этого можно посмотреть <a href="https://github.com/ruRust/rust-by-example-ru">исходный код этого сайта</a>
или <a href="https://github.com/rust-lang/rust-by-example">оригинала</a>.</p>
<p>Итак, давайте начнём!</p>
<ul>
<li>
<p><a href="hello.html">Hello World</a> - Начните с традиционной программы Hello World.</p>
</li>
<li>
<p><a href="primitives.html">Примитивы</a> - Узнайте о целых числах со знаком, целых числах без знака и других примитивах.</p>
</li>
<li>
<p><a href="custom_types.html">Пользовательские типы</a> - <code>struct</code> и <code>enum</code>.</p>
</li>
<li>
<p><a href="variable_bindings.html">Связывание переменных</a> - изменяемые связывания, область видимости, затенение.</p>
</li>
<li>
<p><a href="types.html">Типы</a> - Узнаете об изменении и определении типов.</p>
</li>
<li>
<p><a href="conversion.html">Преобразования.</a></p>
</li>
<li>
<p><a href="expression.html">Выражения.</a></p>
</li>
<li>
<p><a href="flow_control.html">Управление потоком</a> - <code>if</code>/<code>else</code>, <code>for</code>, и другие.</p>
</li>
<li>
<p><a href="fn.html">Функции</a> - Узнайте о методах, замыканиях и функциях высокого порядка.</p>
</li>
<li>
<p><a href="mod.html">Модули</a> - Организация кода с помощью модулей</p>
</li>
<li>
<p><a href="crates.html">Контейнеры</a> - Пакет - это единица компиляции в Rust. Научитесь создавать библиотеку.</p>
</li>
<li>
<p><a href="cargo.html">Cargo</a> - Познакомьтесь с основными функциями официального пакетного менеджера Rust.</p>
</li>
<li>
<p><a href="attribute.html">Атрибуты</a> - Атрибут - это метаданные, применяемые к какому-либо модулю, пакету или элементу.</p>
</li>
<li>
<p><a href="generics.html">Обобщения</a> - Узнайте о написании функции или типа данных, которые могут работать для нескольких типов аргументов.</p>
</li>
<li>
<p><a href="scope.html">Правила областей видимости</a> - Области видимости играют важную роль во владении, заимствовании и продолжительности жизни.</p>
</li>
<li>
<p><a href="trait.html">Traits</a> - Типаж - это набор методов, определённых для неизвестного типа: <code>Self</code>.</p>
</li>
<li>
<p><a href="macros.html">Макросы.</a></p>
</li>
<li>
<p><a href="error.html">Обработка ошибок</a> - Узнаете как в Rust обрабатывать ошибки.</p>
</li>
<li>
<p><a href="std.html">Типы стандартной библиотеки</a> - Узнайте о некоторых пользовательских типах, предоставляемых библиотекой <code>std</code>.</p>
</li>
<li>
<p><a href="std_misc.html">Разное в стандартной библиотеке</a> - Больше пользовательских типов для обработки файлов, потоков.</p>
</li>
<li>
<p><a href="testing.html">Testing</a> - Все виды тестов в Rust.</p>
</li>
<li>
<p><a href="unsafe.html">Unsafe.</a></p>
</li>
<li>
<p><a href="compatibility.html">Совместимость.</a></p>
</li>
<li>
<p><a href="meta.html">Meta</a> - Документация, бенчмаркинг.</p>
</li>
</ul>
<h1><a class="header" href="#Привет-мир" id="Привет-мир">Привет мир</a></h1>
<p>Это исходный код традиционной программы &quot;Привет, мир!&quot;.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Эта строка является комментарием и она будет проигнорирована компилятором
// Протестировать код можно нажав на кнопку &quot;Run&quot; вот тут -&gt;
// так же можно использовать клавиатуру, нажав сочетание клавиш &quot;Ctrl + Enter&quot;

// Этот код можно редактировать не стесняясь, дерзайте!
// Всегда можно вернуть оригинальный код, нажав на кнопку &quot;Reset&quot; вот тут -&gt;

// Это главная функция. С неё начинается исполнение любой программы
fn main() {
    // Следующий код будет исполнен в момент, когда будет запущен исполняемый файл

    // Напечатаем текст в консоли
    println!(&quot;Привет, мир!&quot;);
}
</code></pre></pre>
<p><code>println!</code> - это <a href="macros.html"><em>макрос</em></a>, который отображает текст в консоли.</p>
<p>Исполняемый файл может быть сгенерирован с помощью компилятора Rust - <code>rustc</code>.</p>
<pre><code class="language-sh">$ rustc hello.rs
</code></pre>
<p><code>rustc</code> создаст исполняемый файл <code>hello</code>, который можно будет запустить.</p>
<pre><code class="language-sh">$ ./hello
Привет, мир!
</code></pre>
<h3><a class="header" href="#Задание" id="Задание">Задание</a></h3>
<p>Нажми кнопку 'Run', чтобы увидеть ожидаемый результат.
Затем, добавь новую строку с другим макросом <code>println!</code>, чтобы вывод был таким:</p>
<pre><code class="language-log">Привет, мир!
Я программирую на языке Rust!
</code></pre>
<h1><a class="header" href="#Комментарии" id="Комментарии">Комментарии</a></h1>
<p>Каждая программа, безусловно, нуждается в комментариях и
Rust предоставляет несколько способов комментирования кода:</p>
<ul>
<li><em>Обычные комментарии</em>, которые игнорируются компилятором:
<ul>
<li><code>// Однострочный комментарий. Который завершается в конце строки.</code></li>
<li><code>/* Блочный комментарий, который продолжается до завершающего символа. */</code></li>
</ul>
</li>
<li><em>Doc комментарии</em>, которые будут сгенерированы в HTML<a href="hello/../meta/doc.html">документацию</a>:
<ul>
<li><code>/// Генерация документации для функции.</code></li>
<li><code>//! Генерация документации для модуля.</code></li>
</ul>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // This is an example of a line comment
    // There are two slashes at the beginning of the line
    // And nothing written inside these will be read by the compiler

    // println!(&quot;Hello, world!&quot;);

    // Run it. See? Now try deleting the two slashes, and run it again.

    /* 
     * This is another type of comment, a block comment. In general,
     * line comments are the recommended comment style. But
     * block comments are extremely useful for temporarily disabling
     * chunks of code. /* Block comments can be /* nested, */ */
     * so it takes only a few keystrokes to comment out everything
     * in this main() function. /*/*/* Try it yourself! */*/*/
     */

    /*
    Note: The previous column of `*` was entirely for style. There's
    no actual need for it.
    */

    // You can manipulate expressions more easily with block comments
    // than with line comments. Try deleting the comment delimiters
    // to change the result:
    let x = 5 + /* 90 + */ 5;
    println!(&quot;Is `x` 10 or 100? x = {}&quot;, x);
}

</code></pre></pre>
<h3><a class="header" href="#Смотрите-также" id="Смотрите-также">Смотрите также:</a></h3>
<p><a href="hello/../meta/doc.html">Документирование библиотек</a></p>
<h1><a class="header" href="#Форматированный-вывод" id="Форматированный-вывод">Форматированный вывод</a></h1>
<p>Вывод обрабатывается несколькими <a href="hello/macros.html"><code>макросами</code></a>, которые определены в <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>.
Вот некоторые из них:</p>
<ul>
<li><code>format!</code>: записывает форматированный текст в <a href="hello/std/str.html"><code>String</code></a>.</li>
<li><code>print!</code>: работает аналогично с <code>format!</code>, но текст выводится в консоль (io::stdout).</li>
<li><code>println!</code>: аналогично <code>print!</code>, но в конце добавляется переход на новую строку.</li>
<li><code>eprint!</code>: аналогично <code>format!</code>, но текст выводится в стандартный поток ошибок (io::stderr).</li>
<li><code>eprintln!</code>: аналогично <code>eprint!</code>, но в конце добавляется переход на новую строку.</li>
</ul>
<p>Весь текст обрабатывается аналогичным образом. Плюс данного метода в том, что корректность
форматирования будет проверена на этапе компиляции программы.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // `{}` автоматически будет заменено на
    // аргументы. Они будут преобразованы в строку.
    println!(&quot;{} дней&quot;, 31);

    // Без суффиксов, 31 является i32. Можно изменить тип 31,
    // используя суффикс.

    // Существует множество способов работы с форматированным выводом. Можно указать
    // позицию для каждого аргумента.
    println!(&quot;{0}, это {1}. {1}, это {0}&quot;, &quot;Алиса&quot;, &quot;Боб&quot;);

    // Так же можно именовать аргументы.
    println!(&quot;{subject} {verb} {object}&quot;,
             object=&quot;ленивую собаку&quot;,
             subject=&quot;быстрая коричневая лиса&quot;,
             verb=&quot;прыгает через&quot;);

    println!(&quot;{} из {:b} людей знают, что такое двоичный код, а остальные нет.&quot;, 1, 2);

    // Можно выравнивать текст, сдвигая его на указанную ширину.
    // Данный макрос отобразит в консоли
    // &quot;     1&quot;. 5 пробелов и &quot;1&quot;.
    println!(&quot;{number:&gt;width$}&quot;, number=1, width=6);

    // Можно добавить к цифрам пару нулей. Данный макрос выведет &quot;000001&quot;.
    println!(&quot;{number:&gt;0width$}&quot;, number=1, width=6);

    // Компилятор обязательно проверит, что в макрос передано правильное количество
    // аргументов.
    println!(&quot;Меня зовут {0}, {1} {0}&quot;, &quot;Бонд&quot;);
    // ИСПРАВЬТЕ ^ Добавьте недостающий аргумент: &quot;Джеймс&quot;

    // Создаём структуру, которая хранит в себе `i32`. Назовём её `Structure`.
    #[allow(dead_code)]
    struct Structure(i32);

    // Однако, пользовательские типы данных, например, как эта структура
    // требуют более сложной обработки для вывода. Данный код не будет работать.
    println!(&quot;Эта структура `{}` не хочет выводится на экран...&quot;, Structure(3));
    // ИСПРАВЬТЕ ^ Закомментируйте эту строку.
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> содержит в себе много <a href="hello/trait.html"><code>типажей</code></a>, которые управляют
отображением текста. Базовая форма двух самых важных рассмотрена ниже:</p>
<ul>
<li><code>fmt::Debug</code>: Использует маркер <code>{:?}</code>. Форматирует текст для отладочных целей.</li>
<li><code>fmt::Display</code>: Использует маркер <code>{}</code>. Форматирует текст в более элегантном,удобном для пользователя стиле.</li>
</ul>
<p>В данном примере используется <code>fmt::Display</code>, потому что стандартная библиотека предоставляет
реализацию для данного типа. Для отображения собственных типов потребуется
больше дополнительных шагов.</p>
<p>Реализация типажа <code>fmt::Display</code> автоматически 
предоставляет реализацию типажа
<a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>, 
который позволяет нам <a href="hello/../conversion/string.html">конвертировать</a> наш тип в 
<a href="hello/../std/str.html"><code>String</code></a>.</p>
<h3><a class="header" href="#Задания" id="Задания">Задания</a></h3>
<ul>
<li>Исправьте две ошибки в коде выше (смотрите ИСПРАВЬТЕ), чтобы код компилировался без ошибок</li>
<li>Добавьте макрос <code>println!</code>, который выводит: <code>Pi is roughly 3.142</code> с помощью управления количеством знаков после запятой. Для выполнения данного задания создайте переменную, которая будет хранить в себе значение числа Пи: <code>let pi = 3.141592</code>. (Подсказка: вам необходимо ознакомиться с документацией по <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, чтобы узнать, как отобразить в консоли только часть знаков после запятой).</li>
</ul>
<h3><a class="header" href="#Смотрите-также-1" id="Смотрите-также-1">Смотрите также</a></h3>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="hello/../macros.html"><code>макросы</code></a>, <a href="hello/../custom_types/structs.html"><code>структуры</code></a>,
и <a href="hello/../trait.html"><code>типажи</code></a></p>
<h1><a class="header" href="#debug" id="debug">Debug</a></h1>
<p>Все типы, которые будут использовать <code>типажи (traits)</code> форматирования <code>std::fmt</code> требуют
их реализации для возможности печати. Автоматическая реализация предоставлена только для
типов из <code>стандартной библиотеки (std)</code>. Все остальные типы <em>должны</em> иметь собственную реализацию.</p>
<p>C помощью <code>типажа</code> <code>fmt::Debug</code> это сделать очень просто. <em>Все</em> типы могут
<code>выводить</code> (автоматически создавать) реализацию <code>fmt::Debug</code>.
Сделать подобное с <code>fmt::Display</code> невозможно, он должен быть реализован вручную.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Эта структура не может быть напечатана с помощью `fmt::Display`
// или с помощью `fmt::Debug`
struct UnPrintable(i32);

// Атрибут `derive` автоматически реализует
// необходимые методы, чтобы была возможность
// печатать данную `структуру` с помощью `fmt::Debug`.
#[derive(Debug)]
struct DebugPrintable(i32);
#}</code></pre></pre>
<p>Все типы в <code>стандартной библиотеке (std)</code> могут быть напечатаны с <code>{:?}</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Вывод и реализация `fmt::Debug` для `Structure`.
// `Structure` - это структура, которая содержит в себе один `i32`.
#[derive(Debug)]
struct Structure(i32);

// Добавим структуру `Structure` в структуру `Deep`.
// Реализуем для `Deep` возможность вывода с помощью fmt::Debug`.
#[derive(Debug)]
struct Deep(Structure);

fn main() {
    // Вывод с помощью `{:?}` аналогичен `{}`.
    println!(&quot;{:?} месяцев в году.&quot;, 12);
    println!(&quot;{1:?} {0:?} - это имя {actor:?}.&quot;,
             &quot;Слэйтер&quot;,
             &quot;Кристиан&quot;,
             actor=&quot;актёра&quot;);

    // `Structure` теперь можно напечатать!
    println!(&quot;Теперь {:?} будет выведена на экран!&quot;, Structure(3));

    // Проблема с `выводом (derive)`, в том, что у нас не будет контроля
    // над тем, как будет выглядеть результат.
    // Что если мы хотим напечатать просто `7`?
    println!(&quot;А теперь напечатаем {:?}&quot;, Deep(Structure(7)));
}
</code></pre></pre>
<p>Так что 'fmt:: Debug' определенно делает это для печати, но жертвует некоторыми
изящество. Rust также обеспечивает &quot;красивую печать &quot; с помощью&quot; {:#?}'.</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8
}

fn main() {
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // Pretty print
    println!(&quot;{:#?}&quot;, peter);
}
</code></pre></pre>
<p>Можно вручную реализовать 'fmt:: Display' для управления отображением.</p>
<h3><a class="header" href="#Смотрите-также-2" id="Смотрите-также-2">Смотрите также</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html">attributes</a>, <a href="hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>,
и <a href="hello/print/../../custom_types/structs.html"><code>struct</code></a></p>
<h1><a class="header" href="#display" id="display">Display</a></h1>
<p><code>fmt::Debug</code> выглядит не очень компактно и красиво,
поэтому полезно настраивать внешний вид информации, которая будет напечатана.
Это можно сделать реализовав <code>типаж</code> <a href="https://doc.rust-lang.org/std/fmt/"><code>fmt::Display</code></a> вручную,
который использует маркер <code>{}</code> для печати. Его реализация выглядит следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Импортируем (с помощью `use`) модуль `fmt`, чтобы мы могли его использовать.
use std::fmt;

// Определяем структуру, для которой будет реализован `fmt::Display`.
// Это простая кортежная структура c именем `Structure`, которая хранит в себе `i32`.
struct Structure(i32);

// Чтобы была возможность использовать маркер `{}`
// `типаж (trait) fmt::Display` должен быть реализован вручную
// для данного типа.
impl fmt::Display for Structure {
    // Этот типаж требует реализацию метода `fmt` с данной сигнатурой:
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Записываем первый элемент в предоставленный выходной поток: `f`.
        // Возвращаем `fmt::Result`, который показывает выполнилась операция
        // успешно или нет. Обратите внимание на то, что синтаксис `write!`
        // похож на синтаксис `println!`.
        write!(f, &quot;{}&quot;, self.0)
    }
}
#}</code></pre></pre>
<p>Вывод <code>fmt::Display</code> может быть более чистым чем <code>fmt::Debug</code>, но может быть
проблемой для <code>стандартной библиотеки (std)</code>. Как нестандартные типы должны отображаться?
Например, если <code>стандартная библиотека (std)</code> предоставляет единый стиль вывода для
<code>Vec&lt;T&gt;</code>, каким этот вывод должен быть? Любой из этих двух?</p>
<ul>
<li><code>Vec&lt;path&gt;</code>: <code>/:/etc:/home/username:/bin</code> (разделитель <code>:</code>)</li>
<li><code>Vec&lt;number&gt;</code>: <code>1,2,3</code> (разделитель <code>,</code>)</li>
</ul>
<p>Нет, потому что не существует идеального стиля вывода для всех типов, поэтому
<code>стандартная библиотека std</code> не может его предоставить. <code>fmt::Display</code> не реализован для
<code>Vec&lt;T&gt;</code> или для других обобщённых контейнеров. Для этих случаев подойдёт <code>fmt::Debug</code>.</p>
<p>Это не проблема, потому что для любых новых <em>контейнеров</em>, типы которых не обобщённые,
может быть реализован <code>fmt::Display</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt; // Импортируем `fmt`

// Структура, которая хранит в себе два числа.
// Вывод типажа `Debug` добавлен для сравнения с `Display`.
#[derive(Debug)]
struct MinMax(i64, i64);

// Реализуем `Display` для `MinMax`.
impl fmt::Display for MinMax {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Используем `self.номер`, чтобы получить доступ к каждому полю структуры.
        write!(f, &quot;({}, {})&quot;, self.0, self.1)
    }
}

// Объявим структуру с именованными полями, для сравнения
#[derive(Debug)]
struct Point2D {
    x: f64,
    y: f64,
}

// По аналогии, реализуем `Display` для Point2D
impl fmt::Display for Point2D {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Обращаться к полям структуры Point2D будет по имени
        write!(f, &quot;x: {}, y: {}&quot;, self.x, self.y)
    }
}

fn main() {
    let minmax = MinMax(0, 14);

    println!(&quot;Сравниваем структуры:&quot;);
    println!(&quot;Display: {}&quot;, minmax);
    println!(&quot;Debug: {:?}&quot;, minmax);

    let big_range =   MinMax(-300, 300);
    let small_range = MinMax(-3, 3);

    println!(&quot;Большой диапазон - {big} и маленький диапазон {small}&quot;,
             small = small_range,
             big = big_range);

    let point = Point2D { x: 3.3, y: 7.2 };

    println!(&quot;Сравниваем точки:&quot;);
    println!(&quot;Display: {}&quot;, point);
    println!(&quot;Debug: {:?}&quot;, point);

    // Ошибка. Типажи `Debug` и `Display` были реализованы, но `{:b}`
    // необходима реализация `fmt::Binary`. Следующий код не сработает.
    // println!(&quot;Как выглядит Point2D в виде двоичного кода: {:b}?&quot;, point);
}
</code></pre></pre>
<p>Итак, <code>fmt::Display</code> был реализован, но <code>fmt::Binary</code> нет, следовательно не может быть
использован. <code>std::fmt</code> имеет много таких <a href="hello/print/trait.html"><code>типажей</code></a> и
каждый из них требует свою реализацию. Это более подробно описано в документации к
<a href="https://doc.rust-lang.org/std/fmt/" data-md-type="link"><code>std::fmt</code></a>.</p>
<h3><a class="header" href="#Задание-1" id="Задание-1">Задание</a></h3>
<p>После того, как запустите код, представленный выше, используйте структуру <code>Point2D</code> как пример и
добавьте новую структуру <code>Complex</code>, чтобы вывод был таким:</p>
<pre><code class="language-txt">Display: 3.3 +7.2i
Debug: Complex { real: 3.3, imag: 7.2 }
</code></pre>
<h3><a class="header" href="#Смотрите-также-3" id="Смотрите-также-3">Смотрите также</a></h3>
<p><a href="hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="hello/print/../../macros.html">macros</a>, <a href="hello/print/../../custom_types/structs.html"><code>struct</code></a>,
<a href="hello/print/../../trait.html"><code>trait</code></a>, и <a href="hello/print/../../mod/use.html">use</a></p>
<h1><a class="header" href="#Пример-Список" id="Пример-Список">Пример: Список</a></h1>
<p>Реализовать <code>fmt::Display</code> для структуры, в которой каждый элемент должен обрабатываться
последовательно не так то просто.
Проблема в том, что <code>write!</code> каждый раз возвращает <code>fmt::Result</code>.
Для правильного обращения с этим необходимо обрабатывать <em>все</em>
результаты. Для этой цели Rust предоставляет оператор <code>?</code>.</p>
<p>Использование <code>?</code> для <code>write!</code> выглядит следующим образом:</p>
<pre><code class="language-rust ignore">// Попробуй исполнить `write!`, чтобы узнать, вернется ли ошибка. Если ошибка, верни ее.
// Если нет, то продолжи.
write!(f, &quot;{}&quot;, value)?;
</code></pre>
<p>Кроме того, Вы также можете использовать макрос <code>try!', который работает так же. Это немного более подробно и больше не рекомендуется, но вы все равно можете увидеть его в старом коде на Rust. Использование</code>try!` выглядит так:</p>
<pre><code class="language-rust ignore">try!(write!(f, &quot;{}&quot;, value));
</code></pre>
<p>С помощью оператора <code>?</code> реализация <code>fmt::Display</code> для <code>Vec</code> довольно простая:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt; // Импортируем модуль `fmt`.

// Определим структуру с именем `List`, которая хранит в себе `Vec`.
struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Получаем значение с помощью индекса кортежа
        // и создаём ссылку на `vec`.
        let vec = &amp;self.0;

        write!(f, &quot;[&quot;)?;

        // Пройдёмся по каждому `v` в `vec`.
        // Номер итерации хранится в `count`.
        for (count, v) in vec.iter().enumerate() {
            // Для каждого элемента, кроме первого, добавим запятую
            // до вызова `write!`. Используем оператор `?` или `try!`,
            // чтобы вернуться при наличие ошибок.
            if count != 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}&quot;, v)?;
        }

        // Закроем открытую скобку и вернём значение `fmt::Result`
        write!(f, &quot;]&quot;)
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<h3><a class="header" href="#Задание-2" id="Задание-2">Задание</a></h3>
<p>Попробуйте изменить программу так, чтобы индекс элемента так же выводился в консоль.
Новый вывод должен выглядеть примерно вот так:</p>
<pre><code class="language-rust ignore">[0: 1, 1: 2, 2: 3]
</code></pre>
<h3><a class="header" href="#Смотрите-также-4" id="Смотрите-также-4">Смотрите также</a></h3>
<p><a href="hello/print/print_display/../../../flow_control/for.html"><code>for</code></a>, <a href="hello/print/print_display/../../../scope/borrow/ref.html"><code>ref</code></a>, <a href="hello/print/print_display/../../../std/result.html"><code>Result</code></a>, <a href="hello/print/print_display/../../../custom_types/structs.html"><code>struct</code></a>,
<a href="hello/print/print_display/../../../std/result/question_mark.html"><code>?</code></a>, и <a href="hello/print/print_display/../../../std/vec.html"><code>vec!</code></a></p>
<h1><a class="header" href="#Форматирование" id="Форматирование">Форматирование</a></h1>
<p>Мы видели, что форматирование задаётся <em>макросом форматирования</em>:</p>
<ul>
<li><code>format!(&quot;{}&quot;, foo)</code> -&gt; <code>&quot;3735928559&quot;</code></li>
<li><code>format!(&quot;0x{:X}&quot;, foo)</code> -&gt;
<a href="https://en.wikipedia.org/wiki/Deadbeef#Magic_debug_values"><code>&quot;0xDEADBEEF&quot;</code></a></li>
<li><code>format!(&quot;0o{:o}&quot;, foo)</code> -&gt; <code>&quot;0o33653337357&quot;</code></li>
</ul>
<p>Одна и та же переменная (<code>foo</code>) может быть отображена по разному в зависимости от
используемого <em>типа аргумента</em>: <code>X</code>, <code>o</code> или <em>неопределённый</em>.</p>
<p>Функционал форматирования реализован благодаря типажу,
и для каждого типа аргумента существует свой.
Наиболее распространённый типаж для форматирования - <code>Display</code>,
который работает без аргументов: <code>{}</code>, например.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::{self, Formatter, Display};

struct City {
    name: &amp;'static str,
    // Широта
    lat: f32,
    // Долгота
    lon: f32,
}

impl Display for City {
    // `f` - это буфер, данный метод должен записать в него форматированную строку
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        let lat_c = if self.lat &gt;= 0.0 { 'N' } else { 'S' };
        let lon_c = if self.lon &gt;= 0.0 { 'E' } else { 'W' };

        // `write!` похож на `format!`, только он запишет форматированную строку
        // в буфер (первый аргумент функции)
        write!(f, &quot;{}: {:.3}°{} {:.3}°{}&quot;,
               self.name, self.lat.abs(), lat_c, self.lon.abs(), lon_c)
    }
}

#[derive(Debug)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

fn main() {
    for city in [
        City { name: &quot;Дублин&quot;, lat: 53.347778, lon: -6.259722 },
        City { name: &quot;Осло&quot;, lat: 59.95, lon: 10.75 },
        City { name: &quot;Ванкувер&quot;, lat: 49.25, lon: -123.1 },
    ].iter() {
        println!(&quot;{}&quot;, *city);
    }
    for color in [
        Color { red: 128, green: 255, blue: 90 },
        Color { red: 0, green: 3, blue: 254 },
        Color { red: 0, green: 0, blue: 0 },
    ].iter() {
        // Поменяйте {:?} на {}, когда добавите реализацию
        // типажа fmt::Display
        println!(&quot;{:?}&quot;, *color)
    }
}
</code></pre></pre>
<p>Вы можете посмотреть <a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">полный список типажей форматирования</a> и их типы аргументов
в документации к <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>.</p>
<h3><a class="header" href="#Задание-3" id="Задание-3">Задание</a></h3>
<p>Добавьте реализацию типажа <code>fmt::Display</code> для структуры <code>Color</code>,
чтобы вывод отображался вот так:</p>
<pre><code class="language-text">RGB (128, 255, 90) 0x80FF5A
RGB (0, 3, 254) 0x0003FE
RGB (0, 0, 0) 0x000000
</code></pre>
<p>Пару подсказок, если вы не знаете, что делать:</p>
<ul>
<li>Вам <a href="https://doc.rust-lang.org/std/fmt/#argument-types">возможно потребуется перечислить каждый цвет несколько раз</a>,</li>
<li>Вы можете <a href="https://doc.rust-lang.org/std/fmt/#width">добавить немного нулей</a> с <code>:02</code>.</li>
</ul>
<h3><a class="header" href="#Смотрите-также-5" id="Смотрите-также-5">Смотрите также</a></h3>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a></p>
<h1><a class="header" href="#Примитивы" id="Примитивы">Примитивы</a></h1>
<p>Rust предоставляет доступ к большому количеству <code>примитивов</code>:</p>
<h3><a class="header" href="#Скалярные-типы" id="Скалярные-типы">Скалярные типы</a></h3>
<ul>
<li>знаковые целочисленные: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code> и <code>isize</code> (размер указателя)</li>
<li>беззнаковые целочисленные: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code> и <code>usize</code> (размер указателя)</li>
<li>вещественные: <code>f32</code>, <code>f64</code></li>
<li><code>char</code> скалярное значение Unicode, например: <code>'a'</code>, <code>'α'</code> и <code>'∞'</code> (4 байта каждый)</li>
<li><code>bool</code>: <code>true</code> или <code>false</code></li>
<li>единичный тип <code>()</code>, значение которого так же <code>()</code></li>
</ul>
<p>Несмотря на то, что значение единичного типа является кортежем, оно не считается
составным типом, потому что не содержит нескольких значений.</p>
<h3><a class="header" href="#Составные-типы" id="Составные-типы">Составные типы</a></h3>
<ul>
<li>массивы, например <code>[1, 2, 3]</code></li>
<li>кортежи, например <code>(1, true)</code></li>
</ul>
<p>Переменные всегда должны быть <em>аннотированы</em>.
Числам можно указать определённый тип с помощью <em>суффикса</em>,
иначе будет присвоен <em>тип по умолчанию</em>.
Целочисленные значения по умолчанию <code>i32</code>, а вещественные <code>f64</code>.
Стоит заметить, что Rust также умеет выводить типы из контекста.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Переменные могут быть аннотированы.
    let logical: bool = true;

    let a_float: f64 = 1.0;  // Обычная аннотация
    let an_integer   = 5i32; // Суффиксная аннотация

    // Этим переменным будет присвоен тип по умолчанию.
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`
    
    // Тип также может быть выведен из контекста.
    let mut inferred_type = 12; // Тип i64 выводится из другой строки
    inferred_type = 4294967296i64;
    
    // Значение изменяемой переменной может быть изменено.
    let mut mutable = 12; // Изменяемое `i32`
    mutable = 21;
    
    // Ошибка! Тип переменной изменить нельзя.
    mutable = true;
    
    // Переменные могут быть переопределены с помощью затенения.
    let mutable = true;
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-6" id="Смотрите-также-6">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/">стандартная библиотека (<code>std</code>)</a>, <a href="variable_bindings/mut.html"><code>mut</code></a>, <a href="types/inference.html">вывод типов</a> и <a href="variable_bindings/scope.html">затенение</a></p>
<h1><a class="header" href="#Литералы-и-операторы" id="Литералы-и-операторы">Литералы и операторы</a></h1>
<p>Целочисленное <code>1</code>, вещественное <code>1.2</code>, символ <code>'a'</code>, строка <code>&quot;abc&quot;</code>, логическое <code>true</code>
и единичный тип <code>()</code> могут быть выражены с помощью литералов.</p>
<p>Целочисленные значения так же могут быть выражены с помощью шестнадцатеричного,
восьмеричного или двоичного обозначения используя соответствующие префиксы: <code>0x</code>, <code>0o</code> или <code>0b</code>.</p>
<p>Для улучшения читаемости числовых литералов можно использовать подчёркивания, например
<code>1_000</code> тоже самое, что и <code>1000</code>, и <code>0.000_001</code> равно <code>0.000001</code>.</p>
<p>Нам необходимо указать компилятору какой тип для литерала мы используем.
Сейчас мы используем суффикс <code>u32</code>, чтобы указать, что литерал - беззнаковое целое
число 32-х бит и суффикс <code>i32</code> - знаковое целое 32-х битное число.</p>
<p>Доступные операторы и их приоритет <a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">в Rust</a> такой же как и в других
<a href="https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages">C-подобных языках</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Целочисленное сложение
    println!(&quot;1 + 2 = {}&quot;, 1u32 + 2);

    // Целочисленное вычитание
    println!(&quot;1 - 2 = {}&quot;, 1i32 - 2);
    // ЗАДАНИЕ ^ Попробуйте изменить `1i32` на `1u32`
    // чтобы убедится насколько важен тип данных

    // Булева логика
    println!(&quot;true И false будет {}&quot;, true &amp;&amp; false);
    println!(&quot;true ИЛИ false будет {}&quot;, true || false);
    println!(&quot;НЕ true будет {}&quot;, !true);

    // Побитовые операции
    println!(&quot;0011 И 0101 будет {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 ИЛИ 0101 будет {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 исключающее ИЛИ 0101 будет {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 будет {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 будет 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);

    // Использование подчёркивания для улучшения читаемости!
    println!(&quot;Один миллион записан как {}&quot;, 1_000_000u32);
}
</code></pre></pre>
<h1><a class="header" href="#Кортежи" id="Кортежи">Кортежи</a></h1>
<p>Кортежи - коллекция, которая хранит в себе переменные разных типов. Кортежи
создаются с помощью круглых скобок <code>()</code>, и каждый кортеж является переменной
с сигнатурой типов <code>(T1, T2, ...)</code>, где <code>T1</code>, <code>T2</code> тип члена кортежа.
Функции могут использовать кортежи для возвращения нескольких значений,
так кортежи могут хранить любое количество значений.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Кортежи могут быть использованы как аргументы функции
// и как возвращаемые значения
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {
    // `let` можно использовать для создания связи между кортежем и переменной
    let (integer, boolean) = pair;

    (boolean, integer)
}

// Это структура используется для задания
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // Кортеж с множеством различных типов данных
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // К значениям переменных внутри кортежа можно обратиться по индексу
    println!(&quot;первое значение длинного кортежа: {}&quot;, long_tuple.0);
    println!(&quot;второе значение длинного кортежа: {}&quot;, long_tuple.1);

    // Кортежи могут содержать в себе кортежи
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // Кортежи можно напечатать
    println!(&quot;кортеж из кортежей: {:?}&quot;, tuple_of_tuples);
    
    // Но длинные Кортежи не могут быть напечатаны
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!(&quot;слишком длинный кортеж: {:?}&quot;, too_long_tuple);
    // TODO ^ Раскомментируйте выше 2 строки, чтобы увидеть ошибку компилятораr

    let pair = (1, true);
    println!(&quot;pair хранит в себе {:?}&quot;, pair);

    println!(&quot;перевёрнутая pair будет {:?}&quot;, reverse(pair));

    // Для создания кортежа, содержащего один элемент, необходимо написать элемент и
    // поставить запятую внутри круглых скобок.
    println!(&quot;кортеж из одного элемента: {:?}&quot;, (5u32,));
    println!(&quot;просто целочисленное значение: {:?}&quot;, (5u32));

    // Кортежи можно разобрать на части (деструктурировать) для создания связи
    let tuple = (1, &quot;привет&quot;, 4.5, true);

    let (a, b, c, d) = tuple;
    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!(&quot;{:?}&quot;, matrix);

}
</code></pre></pre>
<h3><a class="header" href="#Задание-4" id="Задание-4">Задание</a></h3>
<ol>
<li>
<p><em>Повторение</em>: Добавьте реализацию типажа <code>fmt::Display</code> для <code>структуры</code>
Matrix в примерах выше,
чтобы, когда вы измените формат вывода с <code>{:?}</code> на <code>{}</code>
на консоль вывелось:</p>
<pre><code class="language-text">( 1.1 1.2 )
( 2.1 2.2 )
</code></pre>
<p>Вы можете вернуться на пример <a href="primitives/hello/print/print_display.html">print display</a>.</p>
</li>
<li>
<p>Добавьте функцию <code>transpose</code>, используя функцию <code>reverse</code>, как пример, которая принимает
матрицу, как аргумент и возвращает матрицу, в которой два элемента поменялись местами.
Например:</p>
<pre><code class="language-rust ignore">println!(&quot;Matrix:\n{}&quot;, matrix);
println!(&quot;Transpose:\n{}&quot;, transpose(matrix));
</code></pre>
<p>Результат:</p>
<pre><code class="language-text">Matrix:
( 1.1 1.2 )
( 2.1 2.2 )
Transpose:
( 1.1 2.1 )
( 1.2 2.2 )
</code></pre>
</li>
</ol>
<h1><a class="header" href="#Массивы-и-срезы" id="Массивы-и-срезы">Массивы и срезы</a></h1>
<p><code>Массив</code> - это коллекция объектов одинакового типа <code>T</code>, расположенных в памяти
непосредственно друг за другом. Массивы создаются с помощью квадратных
скобок <code>[]</code>, а их размер должен быть известен во время компиляции и является
частью сигнатуры типа <code>[T; size]</code>.</p>
<p><code>Срезы</code> похожи на массивы, но их размер не известен в момент компиляции программы.
Срезы представляют собой объекты, состоящие из указателя на данные и размер среза.
Размер среза равен размеру <code>usize</code> и зависит от архитектуры процессора, например,
для x86-64 он равен 64 бит. Срезы могут быть использованы для заимствования
части массива и будут иметь сигнатуру типа <code>&amp;[T]</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">use std::mem;

// Эта функция заимствует срез
fn analyze_slice(slice: &amp;[i32]) {
    println!(&quot;первый элемент среза: {}&quot;, slice[0]);
    println!(&quot;в срезе {} элементов&quot;, slice.len());
}

fn main() {
    // Массив фиксированного размера (указывать сигнатуру типа необязательно)
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // Все элементы могут быть инициализированы одной и той же переменной
    let ys: [i32; 500] = [0; 500];

    // Индекс начинается с 0
    println!(&quot;первый элемент массива: {}&quot;, xs[0]);
    println!(&quot;второй элемент массива: {}&quot;, xs[1]);

    // `len` возвращает длину массива
    println!(&quot;размер массива: {}&quot;, xs.len());

    // Память для массивов выделяется в стеке
    println!(&quot;массив занимает {} байт&quot;, mem::size_of_val(&amp;xs));

    // Массивы могут быть автоматически заимствованы как срез
    println!(&quot;заимствуем весь массив, используя срез&quot;);
    analyze_slice(&amp;xs);

    // Срезы могут указывать на часть массива
    println!(&quot;заимствуем часть массива как срез&quot;);
    analyze_slice(&amp;ys[1 .. 4]);

    // Выход за границу массива заставит компилятор паниковать.
    // Не надо так.
    println!(&quot;{}&quot;, xs[5]);
}
</code></pre></pre>
<h1><a class="header" href="#Пользовательские-типы" id="Пользовательские-типы">Пользовательские типы</a></h1>
<p>В языке программирования Rust пользовательские типы данных
в основном создаются при помощи двух ключевых слов:</p>
<ul>
<li><code>struct</code>: определение структуры</li>
<li><code>enum</code>: определение перечисления</li>
</ul>
<p>Константы так же могут быть созданы с помощью ключевых слов <code>const</code> и <code>static</code>.</p>
<h1><a class="header" href="#Структуры" id="Структуры">Структуры</a></h1>
<p>Существует три типа структур, которые можно создать с помощью ключевого слова <code>struct</code>:</p>
<ul>
<li>Кортежная структура, которая, в общем, является именованным кортежем.</li>
<li>Классическая <a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">C структура</a>.</li>
<li>Единичная структура, которая не имеет полей, но может быть полезна для обобщённых типов.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8,
}

// A unit struct
struct Nil;

// A tuple struct
struct Pair(i32, f32);

// A struct with two fields
struct Point {
    x: f32,
    y: f32,
}

// Structs can be reused as fields of another struct
#[allow(dead_code)]
struct Rectangle {
    p1: Point,
    p2: Point,
}

fn main() {
    // Create struct with field init shorthand
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // Print debug struct
    println!(&quot;{:?}&quot;, peter);


    // Instantiate a `Point`
    let point: Point = Point { x: 0.3, y: 0.4 };

    // Access the fields of the point
    println!(&quot;point coordinates: ({}, {})&quot;, point.x, point.y);

    // Make a new point by using struct update syntax to use the fields of our other one
    let new_point = Point { x: 0.1, ..point };
    // `new_point.y` will be the same as `point.y` because we used that field from `point`
    println!(&quot;second point: ({}, {})&quot;, new_point.x, new_point.y);

    // Destructure the point using a `let` binding
    let Point { x: my_x, y: my_y } = point;

    let _rectangle = Rectangle {
        // struct instantiation is an expression too
        p1: Point { x: my_y, y: my_x },
        p2: point,
    };

    // Instantiate a unit struct
    let _nil = Nil;

    // Instantiate a tuple struct
    let pair = Pair(1, 0.1);

    // Access the fields of a tuple struct
    println!(&quot;pair contains {:?} and {:?}&quot;, pair.0, pair.1);

    // Destructure a tuple struct
    let Pair(integer, decimal) = pair;

    println!(&quot;pair contains {:?} and {:?}&quot;, integer, decimal);
}
</code></pre></pre>
<h3><a class="header" href="#Задание-5" id="Задание-5">Задание</a></h3>
<ol>
<li>Добавьте функцию <code>rect_area</code>, которая рассчитывает площадь прямоугольника (попробуйте использовать &quot;деструктуризацию&quot; (разбор на части)).</li>
<li>Добавьте функцию <code>square</code>, которая принимает в качестве аргументов <code>Point</code> и <code>f32</code>, а возвращает <code>Rectangle</code>, левый нижний угол которого соответствует <code>Point</code>, а ширина и высота соответствуют <code>f32</code>.</li>
</ol>
<h3><a class="header" href="#Смотрите-также-7" id="Смотрите-также-7">Смотрите также:</a></h3>
<p><a href="custom_types/../attribute.html"><code>атрибуты</code></a> и <a href="custom_types/../flow_control/match/destructuring.html">деструктуризация</a></p>
<h1><a class="header" href="#Перечисления" id="Перечисления">Перечисления</a></h1>
<p>Ключевое слово <code>enum</code> позволяет создавать тип данных,
который представляет собой один из нескольких возможных вариантов.
Любой вариант, действительный как <code>struct</code>, также действителен как <code>enum</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Create an `enum` to classify a web event. Note how both
// names and type information together specify the variant:
// `PageLoad != PageUnload` and `KeyPress(char) != Paste(String)`.
// Each is different and independent.
enum WebEvent {
    // An `enum` may either be `unit-like`,
    PageLoad,
    PageUnload,
    // like tuple structs,
    KeyPress(char),
    Paste(String),
    // or c-like structures.
    Click { x: i64, y: i64 },
}

// A function which takes a `WebEvent` enum as an argument and
// returns nothing.
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad =&gt; println!(&quot;page loaded&quot;),
        WebEvent::PageUnload =&gt; println!(&quot;page unloaded&quot;),
        // Destructure `c` from inside the `enum`.
        WebEvent::KeyPress(c) =&gt; println!(&quot;pressed '{}'.&quot;, c),
        WebEvent::Paste(s) =&gt; println!(&quot;pasted \&quot;{}\&quot;.&quot;, s),
        // Destructure `Click` into `x` and `y`.
        WebEvent::Click { x, y } =&gt; {
            println!(&quot;clicked at x={}, y={}.&quot;, x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()` creates an owned `String` from a string slice.
    let pasted  = WebEvent::Paste(&quot;my text&quot;.to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}

</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-8" id="Смотрите-также-8">Смотрите также:</a></h3>
<p><a href="custom_types/../flow_control/match.html"><code>match</code></a>, <a href="custom_types/../fn.html"><code>fn</code></a> и <a href="custom_types/../std/str.html"><code>String</code></a></p>
<h1><a class="header" href="#Декларация-use" id="Декларация-use">Декларация use</a></h1>
<p>Декларация <code>use</code> используется, чтобы
убрать необходимость указывать область видимости:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Атрибут, который убирает предупреждения компилятора
// о неиспользуемом коде
#![allow(dead_code)]

enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}

fn main() {
    // Используем `use` для каждого из вариантов, чтобы они были доступны
    // без указания области видимости.
    use Status::{Poor, Rich};
    // Автоматически используем `use` для каждого из вариантов в `Work`.
    use Work::*;

    // Эквивалентно `Status::Poor`.
    let status = Poor;
    // Эквивалентно to `Work::Civilian`.
    let work = Civilian;

    match status {
        // Обратите внимание, как используются варианты из перечисления `Status`
        // благодаря `use`
        Rich =&gt; println!(&quot;У богатого куча денег!&quot;),
        Poor =&gt; println!(&quot;У бедняка денег нет, но он держится...&quot;),
    }

    match work {
        // И снова используем варианты напрямую.
        Civilian =&gt; println!(&quot;Гражданин работает!&quot;),
        Soldier  =&gt; println!(&quot;Солдаты служат!&quot;),
    }
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-9" id="Смотрите-также-9">Смотрите также:</a></h3>
<p><a href="custom_types/enum/../../flow_control/match.html"><code>match</code> (сопоставление с образцом)</a> и <a href="custom_types/enum/../../mod/use.html"><code>use</code></a></p>
<h1><a class="header" href="#С-подобные" id="С-подобные">С-подобные</a></h1>
<p><code>enum</code> могут быть использованы как C-подобные перечисления.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Атрибут, который убирает предупреждения компилятора
// о неиспользуемом коде
#![allow(dead_code)]

// enum с неявным дискриминатором (начинается с 0)
enum Number {
    Zero,
    One,
    Two,
}

// enum с явным дискриминатором
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enums` может быть преобразован в целочисленное значение.
    println!(&quot;нулевой элемент {}&quot;, Number::Zero as i32);
    println!(&quot;первый элемент {}&quot;, Number::One as i32);

    println!(&quot;красный цвет #{:06x}&quot;, Color::Red as i32);
    println!(&quot;голубой цвет #{:06x}&quot;, Color::Blue as i32);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-10" id="Смотрите-также-10">Смотрите также:</a></h3>
<p><a href="custom_types/enum/../../types/cast.html">приведение типа</a></p>
<h1><a class="header" href="#Пример-Связанный-список" id="Пример-Связанный-список">Пример: Связанный список</a></h1>
<p>Пример использования <code>enums</code> для создания связанного списка:</p>
<pre><pre class="playpen"><code class="language-rust editable">use List::*;

enum List {
    // Cons: Кортежная структура, которая хранит элемент
    // и указатель на следующий узел
    Cons(u32, Box&lt;List&gt;),
    // Nil: Узел, обозначающий конец связанного списка
    Nil,
}

// Методы могут быть присоединены к перечислению
impl List {
    // Создаём пустой список
    fn new() -&gt; List {
        // `Nil` имеет тип `List`
        Nil
    }

    // Функция, которая принимает список и возвращает тот же список,
    // но с новым элементом в начале
    fn prepend(self, elem: u32) -&gt; List {
        // `Cons` также имеет тип `List`
        Cons(elem, Box::new(self))
    }

    // Возвращаем длину списка
    fn len(&amp;self) -&gt; u32 {
        // `self` должен быть сопоставлен (проверен на соответствие),
        // поскольку поведение этого метода зависит от варианта `self`
        // `self` имеет тип `&amp;List`, а `*self` имеет тип `List`, сопоставление на
        // конкретном типе `T` предпочтительнее, чем сопоставление по ссылке `&amp;T`
        match *self {
            // Мы не можем завладеть `tail`, т.к. `self` заимствован;
            // вместо этого возьмём ссылку на `tail`
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // Базовый случай: Пустой список имеет нулевую длину
            Nil =&gt; 0
        }
    }

    // Возвращаем представление списка в виде (размещённой в куче) строки
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!` похож на `print!`, но возвращает строку
                // размещённую в куче, вместо вывода на консоль
                format!(&quot;{}, {}&quot;, head, tail.stringify())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // Создаём пустой связанный список
    let mut list = List::new();

    // Присоединяем несколько элементов
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // Отображаем окончательное состояние списка
    println!(&quot;размер связанного списка: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-11" id="Смотрите-также-11">Смотрите также:</a></h3>
<p><a href="custom_types/enum/std/box.html"><code>Box</code></a> и <a href="custom_types/enum/fn/methods.html"><code>методы</code></a></p>
<h1><a class="header" href="#Константы" id="Константы">Константы</a></h1>
<p>В Rust есть два типа констант, которые могут быть объявлены
в любой области видимости, включая глобальную. Оба требуют явной аннотации типа:</p>
<ul>
<li><code>const</code>: Неизменяемая переменная (в общем случае).</li>
<li><code>static</code>: Возможно, <code>изменяемая</code> переменная с временем жизни <a href="custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code></a>. Статическое время жизни выводится и не должно быть указано. Доступ или модификация изменяемой статической переменной <a href="custom_types/../unsafe.html">небезопасно (см. <code>unsafe</code>)</a>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Константы объявлены в глобальной области видимости.
static LANGUAGE: &amp;str = &quot;Rust&quot;;
const THRESHOLD: i32 = 10;

fn is_big(n: i32) -&gt; bool {
    // Получаем доступ к константе внутри функции
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // Получаем доступ к константе внутри функции main
    println!(&quot;Это язык {}&quot;, LANGUAGE);
    println!(&quot;Установим предел, равный {}&quot;, THRESHOLD);
    println!(&quot;Число {} {} предела&quot;, n, if is_big(n) { &quot;больше&quot; } else { &quot;меньше&quot; });

    // Ошибка! `const` нельзя изменить.
    THRESHOLD = 5;
    // ИСПРАВЬТЕ ^ Закомментируйте эту строчку
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-12" id="Смотрите-также-12">Смотрите также:</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md">RFC для <code>const</code>/<code>static</code></a>,
<a href="custom_types/../scope/lifetime/static_lifetime.html">время жизни <code>'static</code></a></p>
<h1><a class="header" href="#Связывание-переменных" id="Связывание-переменных">Связывание переменных</a></h1>
<p>Rust предоставляет безопасность типов с помощью статической типизации.
Тип переменной может быть указан при объявление связи с переменной.
Тем не менее, в большинстве случаев, компилятор сможет определить тип переменной из контекста.</p>
<p>Значения (как и литералы) могут быть привязаны к переменным, используя оператор <code>let</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let an_integer = 1u32;
    let a_boolean = true;
    let unit = ();

    // скопировать значение `an_integer` в `copied_integer`
    let copied_integer = an_integer;

    println!(&quot;Целое: {:?}&quot;, copied_integer);
    println!(&quot;Логическое: {:?}&quot;, a_boolean);
    println!(&quot;Встречайте единичное значение: {:?}&quot;, unit);

    // Компилятор предупреждает о неиспользуемых переменных; эти предупреждения можно
    // отключить используя подчёркивание перед именем переменной
    let _unused_variable = 3u32;
    let noisy_unused_variable = 2u32;
    // ИСПРАВЬТЕ ^ Добавьте подчёркивание
}
</code></pre></pre>
<h1><a class="header" href="#Изменяемость" id="Изменяемость">Изменяемость</a></h1>
<p>По умолчанию связывание переменных является неизменяемым,
но с помощью модификатора <code>mut</code> можно разрешить изменения.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let _immutable_binding = 1;
    let mut mutable_binding = 1;

    println!(&quot;Перед изменением: {}&quot;, mutable_binding);

    // Ok
    mutable_binding += 1;

    println!(&quot;После изменения: {}&quot;, mutable_binding);

    // Ошибка!
    _immutable_binding += 1;
    // ИСПРАВЬТЕ ^ Закомментируйте эту строку
}
</code></pre></pre>
<p>Компилятор будет выводить подробные сообщения об ошибках, связанных с изменяемостью.</p>
<h1><a class="header" href="#Область-видимости-и-затенение" id="Область-видимости-и-затенение">Область видимости и затенение</a></h1>
<p>Связывание переменных имеет локальную область видимости, и живут эти переменные в <em>блоке</em>.
Блок — набор инструкций, заключённый между фигурными скобками <code>{}</code>.
Кроме того, допускается <a href="https://en.wikipedia.org/wiki/Variable_shadowing">затенение переменных</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Эта переменная живёт в функции main
    let long_lived_binding = 1;

    // Это блок, он имеет меньшую область видимости, чем функция main
    {
        // Эта переменная существует только в этом блоке
        let short_lived_binding = 2;

        println!(&quot;inner short: {}&quot;, short_lived_binding);

        // Эта переменная *затеняет* собой внешнюю
        let long_lived_binding = 5_f32;

        println!(&quot;inner long: {}&quot;, long_lived_binding);
    }
    // Конец блока

    // Ошибка! `short_lived_binding` нет в этой области видимости
    println!(&quot;outer short: {}&quot;, short_lived_binding);
    // ИСПРАВЬТЕ ^ Закомментируйте строку

    println!(&quot;outer long: {}&quot;, long_lived_binding);

    // Это связывание так же *скрывает* собой предыдущие
    let long_lived_binding = 'a';

    println!(&quot;outer long: {}&quot;, long_lived_binding);
}
</code></pre></pre>
<h1><a class="header" href="#Предварительное-объявление" id="Предварительное-объявление">Предварительное объявление</a></h1>
<p>Можно сначала объявить связь с переменной, а инициализировать её позже.
Однако, такая форма используется редко,
так как может привести к использованию неинициализированных переменных.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Объявляем связь с переменной
    let a_binding;

    {
        let x = 2;

        // Инициализируем связь
        a_binding = x * x;
    }

    println!(&quot;связь а: {}&quot;, a_binding);

    let another_binding;

    // Ошибка! Использование неинициализированной связи с переменной
    println!(&quot;другая связь: {}&quot;, another_binding);
    // ИСПРАВЬТЕ ^ Закомментируйте строку

    another_binding = 1;

    println!(&quot;другая связь: {}&quot;, another_binding);
}
</code></pre></pre>
<p>Компилятор запрещает использование неинициализированных переменных,
так как это привело бы к неопределённому поведению.</p>
<h1><a class="header" href="#Типы" id="Типы">Типы</a></h1>
<p>Rust предоставляет несколько механизмов изменения или определения примитивных
и пользовательских типов:</p>
<ul>
<li><a href="types/cast.html">Приведение</a> между примитивными типами</li>
<li>Указание желаемого типа при помощи <a href="types/literals.html">литералов</a></li>
<li>Использование <a href="types/inference.html">вывода типов</a></li>
<li><a href="types/alias.html">Псевдонимы</a> типов</li>
</ul>
<h1><a class="header" href="#Приведение-типов" id="Приведение-типов">Приведение типов</a></h1>
<p>Rust не предусматривает неявного преобразования типов (принудительное) между примитивными типами.
Но, явное преобразование типов (casting) можно выполнить используя ключевое слово <code>as</code>.</p>
<p>Правила, используемые для преобразование внутренних типов, такие же, как в языке C,
за исключением тех случаев, когда преобразование типов в языке C
вызывает неопределённое поведение.
Поведение всех приведений между встроенными типами чётко определено в Rust.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Убрать все предупреждения
// которые вызываются переполнением при преобразование типов.
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // Ошибка ! Нет неявного преобразования
    let integer: u8 = decimal;
    // ИСПРАВЬТЕ ^ Закомментируйте данную строку

    // Явное преобразование
    let integer = decimal as u8;
    let character = integer as char;

    println!(&quot;Casting: {} -&gt; {} -&gt; {}&quot;, decimal, integer, character);

    // Когда преобразовывается любое значение в беззнаковый тип T
    // std::T::MAX + 1 добавляется или вычитается до тех пор, пока значение
    // не будет помещаться в новый тип.

    // 1000 поместится в u16
    println!(&quot;1000 as a u16 is: {}&quot;, 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // Подробнее. Первые 8 младших битов (LSB) сохраняются,
    // а старшие биты (MSB) будут усечены.
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // -1 + 256 = 255
    println!(&quot;  -1 as a u8 is : {}&quot;, (-1i8) as u8);

    // Для положительных чисел результатом будет остаток от деления
    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);

    // Когда значение преобразовывается в знаковый тип,
    // побитовый результат будет таким же, как и
    // первое преобразование к соответствующему типу без знака. Если старший бит этого значения
    // равен 1, то это значение отрицательное.

    // За исключением случая, когда значение умещается в тип.
    println!(&quot; 128 as a i16 is: {}&quot;, 128 as i16);
    // 128 as u8 -&gt; 128, дополнительный код которого в 8 битах:
    println!(&quot; 128 as a i8 is : {}&quot;, 128 as i8);

    // повторяем примеры
    // 1000 as u8 -&gt; 232
    println!(&quot;1000 as a i8 is : {}&quot;, 1000 as i8);
    // и дополнительный код 232 - это -24
    println!(&quot; 232 as a i8 is : {}&quot;, 232 as i8);
}
</code></pre></pre>
<h1><a class="header" href="#Литералы" id="Литералы">Литералы</a></h1>
<p>Числовые литералы могут быть обозначены добавлением типа в качестве суффикса. Например,
чтобы указать, что литерал <code>42</code> должен иметь тип <code>i32</code>, необходимо написать <code>42i32</code>.</p>
<p>Тип литералов без суффикса будет зависеть от того, как они используются. Если нет никаких
ограничений, то компилятор будет использовать <code>i32</code> для целочисленных литералов, а <code>f64</code> для
литералов с плавающей точкой.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Литералы с суффиксами. Их тип известен при инициализации.
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // Литералы без суффиксов. Их тип будет зависеть от того, как их используют.
    let i = 1;
    let f = 1.0;

    // `size_of_val` возвращает размер переменной в байтах
    println!(&quot;size of `x` in bytes: {}&quot;, std::mem::size_of_val(&amp;x));
    println!(&quot;size of `y` in bytes: {}&quot;, std::mem::size_of_val(&amp;y));
    println!(&quot;size of `z` in bytes: {}&quot;, std::mem::size_of_val(&amp;z));
    println!(&quot;size of `i` in bytes: {}&quot;, std::mem::size_of_val(&amp;i));
    println!(&quot;size of `f` in bytes: {}&quot;, std::mem::size_of_val(&amp;f));
}
</code></pre></pre>
<p>В предыдущем коде используются некоторые вещи, которые не были объяснены ранее.
Вот краткое объяснение для нетерпеливых читателей:</p>
<ul>
<li><code>fun(&amp;foo)</code> используется для передаче аргумента в функцию <em>по ссылке</em>, вместо
передачи по значению (<code>fun(foo)</code>). Подробнее см. <a href="types/scope/borrow.html">заимствование</a> или соответствующую
<a href="http://rurust.github.io/rust_book_ru/src/references-and-borrowing.html">главу в книге</a>.</li>
<li><code>std::mem::size_of_val</code> является функцией, но вызывается с указанием <em>полного пути</em>.
Код можно разделить на логические единицы, называемые <em>модулями</em>. В данном случае,
функция определена в модуле <code>mem</code>, а модуль <code>mem</code> определён в <em>контейнере</em> <code>std</code>.
Подробнее см. <a href="types/mod.html">модули</a> и <a href="types/crates.html">контейнеры</a>,
а так же соответствующую 
<a href="http://rurust.github.io/rust_book_ru/src/crates-and-modules.html">главу в книге</a></li>
</ul>
<h1><a class="header" href="#Вывод-типов" id="Вывод-типов">Вывод типов</a></h1>
<p>Движок вывода типов весьма умён. Он делает куда больше,
чем просто смотрит на тип <a href="https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue">r-value</a> при инициализации.
Он также смотрит, как используется значение после инициализации, чтобы
вывести его тип. Вот расширенный пример вывода типов:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Благодаря выведению типов компилятор знает, `elem` имеет тип - u8.
    let elem = 5u8;

    // Создадим пустой вектор (расширяемый массив).
    let mut vec = Vec::new();
    // В данном месте компилятор не знает точный тип `vec`, он лишь знает,
    // что это вектор чего-то там (`Vec&lt;_&gt;`).

    // Добавляем `elem` в вектор.
    vec.push(elem);
    // Ага! Теперь компилятор знает, что `vec` - это вектор, который хранит в себе тип `u8`
    // (`Vec&lt;u8&gt;`)
    // ЗАДАНИЕ ^ Попробуйте закомментировать строку `vec.push(elem)`

    println!(&quot;{:?}&quot;, vec);
}
</code></pre></pre>
<p>Не потребовалось никакой аннотации типов переменных, компилятор счастлив, как и программист!</p>
<h1><a class="header" href="#Псевдонимы" id="Псевдонимы">Псевдонимы</a></h1>
<p>Оператор type используется, чтобы задать новое имя существующему типу.
Имя типа должно быть в стиле <code>CamelCase</code>, иначе компилятор выдаст предупреждение.
Исключением являются примитивные типы: <code>usize</code>, <code>f32</code> и другие.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `NanoSecond` это новое имя для `u64`.
type NanoSecond = u64;
type Inch = u64;

// Используйте этот атрибут, чтобы не выводить предупреждение
// о именах не в стиле CamelCase
#[allow(non_camel_case_types)]
type u64_t = u64;
// ЗАДАНИЕ ^ Попробуйте удалить атрибут

fn main() {
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    // Обратите внимание, что псевдонимы *не предоставляют* никакой
    // дополнительной безопасности типов, так как *не являются* новыми типами
    println!(&quot;{} nanoseconds + {} inches = {} unit?&quot;,
             nanoseconds,
             inches,
             nanoseconds + inches);
}
</code></pre></pre>
<p>Основное применение псевдонимов — сокращение размера кода: например, тип <code>IoResult&lt;T&gt;</code> является
псевдонимом типа Result&lt;T, IoError&gt;.</p>
<h3><a class="header" href="#Смотрите-также-13" id="Смотрите-также-13">Смотрите также:</a></h3>
<p><a href="types/attribute.html">Атрибуты</a></p>
<h1><a class="header" href="#Приведение-типов-1" id="Приведение-типов-1">Приведение типов</a></h1>
<p>Приведение типов в Rust осуществляется с помощью <a href="trait.html">типажей</a>.
В общем, при приведении к типу используются <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> и <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>,
но есть и более специфические типажи для часто используемых
случаев, например, для конвертации в <code>String</code> и обратно.</p>
<h1><a class="header" href="#from-и-into" id="from-и-into"><code>From</code> и <code>Into</code></a></h1>
<p>Типажи <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> и <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> связаны по своей сути, и это стало частью их реализации. Если вы можете конвертировать тип <code>А</code> в тип <code>В</code>, то будет легко предположить, что мы должны быть в состоянии конвертировать тип <code>В</code> в тип <code>А</code>.</p>
<h2><a class="header" href="#from" id="from"><code>From</code></a></h2>
<p>Типаж <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> позволяет типу определить, как он будет создаваться из другого типа, что предоставляет очень простой механизм конвертации между несколькими типами. Есть несколько реализаций этот типажа в стандартной библиотеке для преобразования примитивов и общих типов.</p>
<p>Для примера, мы можем легко конвертировать <code>str</code> в <code>String</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let my_str = &quot;привет&quot;;
let my_string = String::from(my_str);
#}</code></pre></pre>
<p>Мы можем сделать нечто похожее для определения конвертации для нашего собственного типа.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!(&quot;Мой номер {:?}&quot;, num);
}
</code></pre></pre>
<h2><a class="header" href="#into" id="into"><code>Into</code></a></h2>
<p>Типаж <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> является полной противоположностью типажа <code>From</code>. Так что если вы реализовали для вашего типа типаж  <code>From</code>, реализацию типажа <code>Into</code> вы получите бесплатно.</p>
<p>Использование типажа <code>Into</code> обычно требует спецификации типа, в который мы собираемся конвертировать, так как компилятор чаще всего не может это вывести.
Однако это небольшой компромисс, учитывая, что данную функциональность мы получаем бесплатно.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // Попробуйте убрать аннотацию типа
    let num: Number = int.into();
    println!(&quot;Мой номер {:?}&quot;, num);
}
</code></pre></pre>
<h1><a class="header" href="#fromstr-и-tostring" id="fromstr-и-tostring"><code>FromStr</code> и <code>ToString</code></a></h1>
<h2><a class="header" href="#Конвертация-в-строку" id="Конвертация-в-строку">Конвертация в строку</a></h2>
<p>Преобразовать любой тип в <code>String</code> так же просто, как и реализовать для него типаж <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>. Вместо того, чтобы делать это напрямую, вы должны реализовать типаж <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>fmt::Display</code></a>, который автоматически предоставляет реализацию <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>, а 
также позволяет распечатать тип, как обсуждалось в секции <a href="conversion/../hello/print.html"><code>print!</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt;

struct Circle {
    radius: i32
}

impl fmt::Display for Circle {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;Круг радиусом {}&quot;, self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!(&quot;{}&quot;, circle.to_string());
}
</code></pre></pre>
<h2><a class="header" href="#Парсинг-строки" id="Парсинг-строки">Парсинг строки</a></h2>
<p>Один из наиболее общим типов конвертации - это преобразование строки в число. Идиоматический подход это сделать при помощи функции <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code></a> и указания типа, в который будем преобразовывать, что можно сделать либо через выведение типа, либо при помощи 'turbofish'-синтаксиса.</p>
<p>Это преобразует строку в указанный тип при условии, что для этого типа реализован типаж <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a>. 
Он реализован для множества типов стандартной библиотеки. 
Чтобы получить эту функциональность для пользовательского типа, надо просто реализовать для этого типа типаж <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let parsed: i32 = &quot;5&quot;.parse().unwrap();
    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();

    let sum = parsed + turbo_parsed;
    println!(&quot;Сумма: {:?}&quot;, sum);
}
</code></pre></pre>
<h1><a class="header" href="#Выражения" id="Выражения">Выражения</a></h1>
<p>Программы на языке Rust - это (в основном) набор последовательных операторов:</p>
<pre><code>fn main() {
    // оператор
    // оператор
    // оператор
}
</code></pre>
<p>Существует несколько типов операторов в Rust.
Наиболее распространённые - оператор связывания и выражение, заканчивающееся <code>;</code>:</p>
<pre><code>fn main() {
    // оператор связывания
    let x = 5;

    // оператор выражения
    x;
    x + 1;
    15;
}
</code></pre>
<p>Блоки так же могут быть частью оператора выражения.
Они используются в качестве <a href="https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue">r-values</a> при присваивании.
Последнее выражение в блоке будет присвоено <a href="https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue">l-value</a>.
Однако, если последнее выражение в блоке оканчивается точкой с запятой,
в качестве значения будет возвращено <code>()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // Результат этого выражение будет присвоен переменной `y`
        x_cube + x_squared + x
    };

    let z = {
        // Т.к это выражение оканчивается на `;`, переменной `z` будет присвоен `()`
        2 * x;
    };

    println!(&quot;x равен {:?}&quot;, x);
    println!(&quot;y равен {:?}&quot;, y);
    println!(&quot;z равен {:?}&quot;, z);
}
</code></pre></pre>
<h1><a class="header" href="#Управление-потоком" id="Управление-потоком">Управление потоком</a></h1>
<p>Неотъемлемой частью любого языка программирования является изменение потоков управления:
<code>if</code>/<code>else</code>, <code>for</code> и другие. Давайте поговорим о них в языке Rust.</p>
<h1><a class="header" href="#ifelse" id="ifelse">if/else</a></h1>
<p>Ветвление с помощью <code>if</code>-<code>else</code> такое же, как и в других языка программирования.
В отличие от многих других языков программирования, логические условия не должны быть заключены
в круглые скобки и после каждого условия должен следовать блок.
Условия <code>if</code>-<code>else</code> являются выражениями, и все ветки должны возвращать одинаковый тип данных.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let n = 5;

    if n &lt; 0 {
        print!(&quot;{} — отрицательное&quot;, n);
    } else if n &gt; 0 {
        print!(&quot;{} — положительное&quot;, n);
    } else {
        print!(&quot;{} — нуль&quot;, n);
    }

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, малое по модулю число, умножим его в десять раз&quot;);

            // Это выражение вернёт `i32`.
            10 * n
        } else {
            println!(&quot;, большое по модулю число, уменьшим его вдвое&quot;);

            // И это выражение вернёт `i32`.
            n / 2
            // ЗАДАНИЕ ^ Попробуйте отбросить значение, добавив точку с запятой.
        };
    //   ^ Не забудьте добавить тут точку с запятой! Все операторы `let` требуют её..

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
}
</code></pre></pre>
<h1><a class="header" href="#loop" id="loop">loop</a></h1>
<p>Rust предоставляет ключевое слово <code>loop</code> для обозначения бесконечного цикла.</p>
<p>Оператор <code>break</code> используется чтобы выйти из цикла в любое время, оператор
<code>continue</code> используется чтобы пропустить оставшуюся часть цикла и начать новую итерацию.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut count = 0u32;

    println!(&quot;Давайте считать до бесконечности!&quot;);

    // Бесконечный цикл
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;три&quot;);

            // Пропустить оставшуюся часть цикла
            continue;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;Всё, достаточно&quot;);

            // Выйти из цикла
            break;
        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#Вложенность-и-метки" id="Вложенность-и-метки">Вложенность и метки</a></h1>
<p>Можно прерывать выполнение внешних циклов с помощью <code>break</code> или <code>continue</code>,
когда речь заходит о вложенных циклах.
Для этого циклы должны быть обозначены метками вроде <code>'label</code>,
а метки должны быть переданы операторам <code>break</code> или <code>continue</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(unreachable_code)]

fn main() {
    'outer: loop {
        println!(&quot;Вошли во внешний цикл&quot;);

        'inner: loop {
            println!(&quot;Вошли во внутренний цикл&quot;);

            // Это прервёт лишь внутренний цикл
            //break;

            // Это прервёт внешний цикл
            break 'outer;
        }

        println!(&quot;Эта точка не будет достигнута&quot;);
    }

    println!(&quot;Вышли из внешнего цикла&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#Возврат-из-циклов" id="Возврат-из-циклов">Возврат из циклов</a></h1>
<p>Одним из видов использования цикла <code>loop</code> является повторение операции, пока
она не будет выполнена. Если операция возвращает значение, вам может
потребоваться передать его в другую часть кода: поместите его после <code>break</code>,
и оно будет возвращено выражением <code>loop</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<h1><a class="header" href="#while" id="while">while</a></h1>
<p>Ключевое слово <code>while</code> используется для создания цикла, который будет выполняться,
пока условие истинно.</p>
<p>Давайте напишем печально известный <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> используя цикл <code>while</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Переменная счётчик
    let mut n = 1;

    // Цикл while будет работать, пока `n` меньше 101
    while n &lt; 101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }

        // Увеличиваем значение счётчика
        n += 1;
    }
}
</code></pre></pre>
<h1><a class="header" href="#Цикл-for" id="Цикл-for">Цикл for</a></h1>
<h2><a class="header" href="#for-и-диапазоны" id="for-и-диапазоны"><code>for</code> и диапазоны</a></h2>
<p>Конструкция <code>for in</code> может быть использована для итерации по <code>Итераторам (Iterator)</code>.
Один из самых простых способов создать итератор это использовать
диапазон значений <code>a..b</code>. Это вернёт нам значения от <code>a</code> (включительно) до <code>b</code>
(исключительно) за один шаг.</p>
<p>Давайте напишем FizzBuzz, используя <code>for</code> вместо <code>while</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `n` будет принимать значения: 1, 2, ..., 100 с каждой итерации
    for n in 1..101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<p>Также, может быть использован диапазон <code>a..=b</code>, включающий оба конца.
Код выше может быть записан следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `n` будет принимать значения: 1, 2, ..., 100 с каждой итерации
    for n in 1..=100 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<h2><a class="header" href="#for-и-итераторы" id="for-и-итераторы"><code>for</code> и итераторы</a></h2>
<p>Конструкция <code>for in</code> может взаимодействовать с  <code>Iterator</code> разными способами. 
Как обсуждается далее про <a href="flow_control/../trait/iter.html">типаж <code>Iterator</code></a>, цикл 
<code>for</code> применяет к предоставленной коллекции метод 
<code>into_iter</code>, чтобы преобразовать её в итератор. 
Это не единственный способ преобразования коллекции в 
итератор, также существуют другие функции: <code>iter</code> и 
<code>iter_mut</code>.</p>
<p>Эти 3 функции вернут разные отображения данных в вашей 
коллекции.</p>
<ul>
<li><code>iter</code> - эта функция заимствует каждый элемент коллекции на каждой итерации.Благодаря этому, он оставляет коллекцию нетронутой и доступной для использования после цикла.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust ">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter() {
        match name {
            &amp;&quot;Ferris&quot; =&gt; println!(&quot;Программисты Rust вокруг нас!&quot;),
            _ =&gt; println!(&quot;Привет {}&quot;, name),
        }
    }
}
</code></pre></pre>
<ul>
<li><code>into_iter</code> - эта функция потребляет коллекцию так что на каждой итерации предоставляются данные.Коллекция больше не доступна для использования так как владение ею перешло в эту функцию.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust ">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.into_iter() {
        match name {
            &quot;Ferris&quot; =&gt; println!(&quot;Программисты Rust вокруг нас!&quot;),
            _ =&gt; println!(&quot;Привет {}&quot;, name),
        }
    }
}
</code></pre></pre>
<ul>
<li><code>iter_mut</code> - эта функция делает изменяемое заимствование каждого элемента коллекции, позволяя изменять коллекцию на месте.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust ">fn main() {
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter_mut() {
        *name = match name {
            &amp;mut &quot;Ferris&quot; =&gt; &quot;Программисты Rust вокруг нас!&quot;,
            _ =&gt; &quot;Привет&quot;,
        }
    }

    println!(&quot;имена: {:?}&quot;, names);
}
</code></pre></pre>
<p>В вышеуказанных кусках кода, обратите на ветку 
<code>match</code>, которая имеет ключевое отличие в 
зависимости от типа выполнения итераций. Разница в типе, конечно, 
подразумевает различные действия, которые могут быть 
выполнены.</p>
<h3><a class="header" href="#Смотрите-также-14" id="Смотрите-также-14">Смотрите также:</a></h3>
<p><a href="flow_control/../trait/iter.html">Итераторы (Iterator)</a></p>
<h1><a class="header" href="#match" id="match">match</a></h1>
<p>Rust предоставляет ключевое слово <code>match</code>, которое используется для проверки на
соответствие шаблону. <code>match</code> можно использовать как <code>switch</code> в языке C.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let number = 13;
    // ЗАДАНИЕ ^ Попробуйте присвоить `number` другое значение

    println!(&quot;Tell me about {}&quot;, number);
    match number {
        // Сопоставление с одним значением
        1 =&gt; println!(&quot;One!&quot;),
        // Сопоставление с несколькими значениями
        2 | 3 | 5 | 7 | 11 =&gt; println!(&quot;This is a prime&quot;),
        // Сопоставление с диапазоном значений
        13...19 =&gt; println!(&quot;A teen&quot;),
        // Обработка остальных случаев
        _ =&gt; println!(&quot;Ain't special&quot;),
    }

    let boolean = true;
    // Match так же является выражением
    let binary = match boolean {
        // Ветви match должны обработать все возможные значения переменной
        false =&gt; 0,
        true =&gt; 1,
        // ЗАДАНИЕ ^ Попробуйте закомментировать эту ветвь
    };

    println!(&quot;{} -&gt; {}&quot;, boolean, binary);
}
</code></pre></pre>
<h1><a class="header" href="#Деструктуризация" id="Деструктуризация">Деструктуризация</a></h1>
<p>Блок <code>match</code> может  деструктурировать элементы в различных формах.</p>
<ul>
<li><a href="flow_control/match/destructuring/destructure_enum.html">Перечисления</a></li>
<li><a href="flow_control/match/destructuring/destructure_pointers.html">Указатели</a></li>
<li><a href="flow_control/match/destructuring/destructure_structures.html">Структуры</a></li>
<li><a href="flow_control/match/destructuring/destructure_tuple.html">Кортежи</a></li>
</ul>
<h1><a class="header" href="#Кортежи-1" id="Кортежи-1">Кортежи</a></h1>
<p>Кортежи можно деструктурировать с помощью <code>match</code> следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let pair = (0, -2);
    // ЗАДАНИЕ ^ Попробуйте другие значения для `pair`

    println!(&quot;Tell me about {:?}&quot;, pair);
    // Match можно использовать для деструктуризации кортежей
    match pair {
        // Деструктурируем два значения
        (0, y) =&gt; println!(&quot;Первое значение `0`, а `y` равно `{:?}`&quot;, y),
        (x, 0) =&gt; println!(&quot;`x` равно `{:?}`, а второе значение `0`&quot;, x),
        _      =&gt; println!(&quot;Неважно, какого они значения&quot;),
         // `_` означает, что значение не будет связано с переменной
    }
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-15" id="Смотрите-также-15">Смотрите также:</a></h3>
<p><a href="flow_control/match/destructuring/primitives/tuples.html">Tuples</a></p>
<h1><a class="header" href="#Перечисления-1" id="Перечисления-1">Перечисления</a></h1>
<p>Деструктуризация <code>enum</code> происходит следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust editable">// `allow` необходим, чтобы компилятор не выводил предупреждения,
// т.к используется только один вариант
#[allow(dead_code)]
enum Color {
    // Эти 3 перечисления определяют цвет по названию.
    Red,
    Blue,
    Green,
    // Остальные используют `u32` кортежи для идентификации цветовых моделей.
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    let color = Color::RGB(122, 17, 40);
    // ЗАДАНИЕ ^ Попробуйте другие значения для `color`

    println!(&quot;Какой это цвет?&quot;);
    // `enum` может быть деструктурирован с помощью `match`.
    match color {
        Color::Red   =&gt; println!(&quot;Красный цвет!&quot;),
        Color::Blue  =&gt; println!(&quot;Синий цвет!&quot;),
        Color::Green =&gt; println!(&quot;Зелёный цвет!&quot;),
        Color::RGB(r, g, b) =&gt;
            println!(&quot;Красный: {}, зелёный: {}, и синий: {}!&quot;, r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!(&quot;Тон: {}, насыщенность: {}, значение: {}!&quot;, h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!(&quot;Тон: {}, насыщенность: {}, светлота: {}!&quot;, h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!(&quot;Голубой: {}, пурпурный: {}, жёлтый: {}!&quot;, c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!(&quot;Голубой: {}, пурпурный: {}, жёлтый: {}, key (чёрный): {}!&quot;,
                c, m, y, k),
        // Нет необходимости в других ветвях, т.к были рассмотрены все варианты
    }
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-16" id="Смотрите-также-16">Смотрите также:</a></h3>
<p><a href="flow_control/match/destructuring/../../../attribute/unused.html"><code>#[allow(...)]</code></a>, <a href="https://en.wikipedia.org/wiki/Color_model">цветовая модель</a> и <a href="flow_control/match/destructuring/../../../custom_types/enum.html"><code>перечисления</code></a></p>
<h1><a class="header" href="#Указатели-и-ссылки" id="Указатели-и-ссылки">Указатели и ссылки</a></h1>
<p>Для указателей необходимо различать деструктуризацию и разыменование, 
поскольку это разные концепции, которые используются иначе, чем в языке <code>С</code>.</p>
<ul>
<li>Разыменование использует <code>*</code></li>
<li>Деструктуризация использует <code>&amp;</code>, <code>ref</code> и <code>ref mut</code></li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Присваиваем ссылку на тип `i32`. 
    // Символ `&amp;` означает, что присваивается ссылка.
    let reference = &amp;4;

    match reference {
        // Если `reference` - это шаблон, который сопоставляется с `&amp;val`,
        // то это приведёт к сравнению:
        // `&amp;i32`
        // `&amp;val`
        // ^ Мы видим, что если отбросить сопоставляемые `&amp;`, 
        // то переменной `val` должно быть присвоено `i32`.
        &amp;val =&gt; println!(&quot;Получаем значение через деструктуризацию: {:?}&quot;, val),
    }

    // Чтобы избежать символа `&amp;`, нужно разыменовывать ссылку до сопоставления.
    match *reference {
        val =&gt; println!(&quot;Получаем значение через разыменование: {:?}&quot;, val),
    }

    // Что если у нас нет ссылки? `reference` была с `&amp;`,
    // потому что правая часть была ссылкой. Но это не ссылка, 
    // потому что правая часть ею не является.
    let _not_a_reference = 3;

    // Rust предоставляет ключевое слово `ref` именно для этой цели. 
    // Оно изменяет присваивание так, что создаётся ссылка для элемента. 
    // Теперь ссылка присвоена.
    let ref _is_a_reference = 3;

    // Соответственно, для определения двух значений без ссылок, 
    // ссылки можно назначить с помощью `ref` и `ref mut`.
    let value = 5;
    let mut mut_value = 6;

    // Используйте ключевое слово `ref` для создания ссылки.
    match value {
        ref r =&gt; println!(&quot;Получили ссылку на значение: {:?}&quot;, r),
    }

    // Используйте `ref mut` аналогичным образом.
    match mut_value {
        ref mut m =&gt; {
            // Получаем ссылку. Её нужно разыменовать, 
            // прежде чем мы сможем что-то добавить.
            *m += 10;
            println!(&quot;Мы добавили 10. `mut_value`: {:?}&quot;, m);
        },
    }
}
</code></pre></pre>
<h1><a class="header" href="#Структуры-1" id="Структуры-1">Структуры</a></h1>
<p><code>Структуры</code> могут быть деструктурированы следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    struct Foo { x: (u32, u32), y: u32 }

    // деструктуризация члена структуры
    let foo = Foo { x: (1, 2), y: 3 };
    let Foo { x: (a, b), y } = foo;

    println!(&quot;a = {}, b = {},  y = {} &quot;, a, b, y);

    // Вы можете деструктурировать структуру и переименовывать переменные,
    // порядок при этом не важен

    let Foo { y: i, x: j } = foo;
    println!(&quot;i = {:?}, j = {:?}&quot;, i, j);

    // а так же можно проигнорировать часть переменных:
    let Foo { y, .. } = foo;
    println!(&quot;y = {}&quot;, y);

    // следующий код выдаст ошибку: в шаблоне нет упоминания поля `x`
    // let Foo { y } = foo;
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-17" id="Смотрите-также-17">Смотрите также:</a></h3>
<p><a href="flow_control/match/destructuring/../../../custom_types/structs.html">стуктуры</a>, <a href="flow_control/match/destructuring/../../../scope/borrow/ref.html">шаблон ref</a></p>
<h1><a class="header" href="#Ограничители-шаблонов" id="Ограничители-шаблонов">Ограничители шаблонов</a></h1>
<p>Внутри конструкции <code>match</code> можно добавить <em>ограничитель шаблонов</em>
для фильтрации возможных вариантов.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let pair = (2, -2);
    // ЗАДАНИЕ ^ Попробуйте разные значения `pair`

    println!(&quot;Расскажи мне о {:?}&quot;, pair);
    match pair {
        (x, y) if x == y =&gt; println!(&quot;Близнецы&quot;),
        // Данное ^ `условие if` является ограничителем шаблонов
        (x, y) if x + y == 0 =&gt; println!(&quot;Антиматерия, бабах!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;Первое число нечётно&quot;),
        _ =&gt; println!(&quot;Нет корреляции...&quot;),
    }
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-18" id="Смотрите-также-18">Смотрите также:</a></h3>
<p><a href="flow_control/match/primitives/tuples.html">Tuples</a></p>
<h1><a class="header" href="#Связывание" id="Связывание">Связывание</a></h1>
<p>Косвенный доступ к переменной делает невозможным ветвление и использование
переменной без повторной привязки. <code>match</code> предоставляет символ <code>@</code>
для привязки значения к имени:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Функция `age`, возвращающая `u32`.
fn age() -&gt; u32 {
    15
}

fn main() {
    println!(&quot;Скажи мне свой возраст&quot;);

    match age() {
        0             =&gt; println!(&quot;Я ещё не родился&quot;),
        // Можно было бы использовать только 1 ... 12 в `match`,
        // но какого возраста тогда был бы ребёнок? Вместо этого мы
        // привязываем `n` к последовательности 1 .. 12. 
        // Теперь мы можем сообщить возраст.
        n @ 1  ..= 12 =&gt; println!(&quot;Я ребёнок. Мне {:?}&quot;, n),
        n @ 13 ..= 19 =&gt; println!(&quot;Я подросток. Мне {:?}&quot;, n),
        // Ничего не привязываем.
        n             =&gt; println!(&quot;Я взрослый. Мне {:?}&quot;, n),
    }
}
</code></pre></pre>
<p>Вы также можете использовать привязку для &quot;деструктурирования&quot; 
вариантов <code>enum</code>, таких как <code>Option</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn some_number() -&gt; Option&lt;u32&gt; {
    Some(42)
}

fn main() {
    match some_number() {
        // Вариант `Some`, выбираем, если его значение, привязанное к `n`,
        // равно 42.
        Some(n @ 42) =&gt; println!(&quot;Ответ: {}!&quot;, n),
        // При других числах.
        Some(n)      =&gt; println!(&quot;Не интересно... {}&quot;, n),
        // Для всего остального (вариант `None`).
        _            =&gt; (),
    }
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-19" id="Смотрите-также-19">Смотрите также:</a></h3>
<p><a href="flow_control/match/../../fn.html">Функции</a>, <a href="flow_control/match/../../custom_types/enum.html"><code>enum</code></a> и <a href="flow_control/match/../../std/option.html"><code>Option</code></a></p>
<h1><a class="header" href="#if-let" id="if-let">if let</a></h1>
<p>В некоторых случаях использование <code>match</code> выглядит неуклюже. Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Создаём переменную `optional` типа `Option&lt;i32&gt;`
let optional = Some(7);

match optional {
    Some(i) =&gt; {
        println!(&quot;Это очень большая строка и `{:?}`&quot;, i);
        // ^ Нужно 2 отступа только для того, чтобы извлечь `i`
    },
    _ =&gt; {},
    // ^ Обязателен, так как `match` исчерпывающий. Не выглядит ли это
    // как потерянное пространство?
};

#}</code></pre></pre>
<p><code>if let</code> намного компактнее и выразительнее для данного случая и, кроме того, позволяет рассмотреть различные варианты ошибок.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Все переменные типа `Option&lt;i32&gt;`
    let number = Some(7);
    let letter: Option&lt;i32&gt; = None;
    let emoticon: Option&lt;i32&gt; = None;

    // Конструкция `if let` читает, как: &quot;Если `let` деструктуризирует `number` в
    // `Some(i)`, выполнить блок (`{}`).
    if let Some(i) = number {
        println!(&quot;Соответствует {:?}!&quot;, i);
    }

    // Если нужно указать, что делать, в случае ошибки, можно добавить else:
    if let Some(i) = letter {
        println!(&quot;Соответствует {:?}!&quot;, i);
    } else {
        // Ошибка деструктуризации. Переходим к обработке ошибки.
        println!(&quot;Не соответствует числу. Давайте попробуем строку!&quot;);
    }

    // Добавляем ещё одну ситуацию несоответствия образцу.
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!(&quot;Соответствует {:?}!&quot;, i);
    // Оцените условие `else if`, чтобы увидеть, 
    // должна ли быть альтернативная ветка отказа:
    } else if i_like_letters {
        println!(&quot;Не соответствует числу. Давайте попробуем строку!&quot;);
    } else {
        // Рассматриваем ложное условие. Эта ветвь по умолчанию:
        println!(&quot;Мне не нравится сравнивать строки. Давайте возьмём смайлик :)!&quot;);
    }
}
</code></pre></pre>
<p>Точно так же, <code>if let</code> может быть использован для сравнения любого значения перечисления:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Наш пример перечисления
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    // Создание переменных примера
    let a = Foo::Bar;
    let b = Foo::Baz;
    let c = Foo::Qux(100);
    
    // Переменная `a` соответствует `Foo::Bar`
    if let Foo::Bar = a {
        println!(&quot;a = Foo::Bar&quot;);
    }
    
    // Переменная `b` не соответствует `Foo::Bar`.
    // Поэтому ничего не выведется на экран
    if let Foo::Bar = b {
        println!(&quot;b = Foo::Bar&quot;);
    }
    
    // Переменная `c` соответствует `Foo::Qux`, которая имеет значение
    // аналогичное `Some()` как в предыдущем примере:
    if let Foo::Qux(value) = c {
        println!(&quot;c ={}&quot;, value);
    }

    // С `if let` также работает и привязка
    if let Foo::Qux(value @ 100) = c {
        println!(&quot;c = 100&quot;);
    }
}
</code></pre></pre>
<p>Другое преимущество: if let позволяет сопоставлять не параметризованные варианты перечисления, даже если перечисление не #[derive(PartialEq)], и мы не реализовали PartialEq для них. В некоторых случаях, классический if Foo::Bar == a не работает, потому что такие перечисления не могут быть равны. Однако, if let работает.</p>
<p>Хотите вызов? Исправьте следующий пример с использованием <code>if let </code>:</p>
<pre><code class="language-rust editable ignore">// Для это перечисление намеренно не добавлен #[derive(PartialEq)],
// и мы не реализовывали для него PartialEq. Вот почему сравнение Foo::Bar==a терпит неудачу.
enum Foo {Bar}

fn main() {
    let a = Foo::Bar;

    // Переменная соответствует Foo::Bar
    if Foo::Bar == a {
    // ^-- это вызовет ошибку компиляции. Используйте `if let` вместо этого.
        println!(&quot;a is foobar&quot;);
    }
}
</code></pre>
<h3><a class="header" href="#Смотрите-также-20" id="Смотрите-также-20">Смотрите также:</a></h3>
<p><a href="flow_control/../custom_types/enum.html"><code>enum</code></a>, <a href="flow_control/../std/option.html"><code>Option</code></a>, и <a href="https://github.com/rust-lang/rfcs/pull/160">RFC</a></p>
<h1><a class="header" href="#while-let" id="while-let">while let</a></h1>
<p>Так же, как и<code>if let</code>, <code>while let</code> может сделать неудобный <code>match</code>
более терпимым. Рассмотрим следующий пример, в котором мы увеличиваем значение <code>i</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Создадим переменную `optional` с типом `Option&lt;i32&gt;`
let mut optional = Some(0);

// Неоднократно повторим наш тест.
loop {
    match optional {
        // Если `optional` деструктурируется, выполним следующий блок.
        Some(i) =&gt; {
            if i &gt; 9 {
                println!(&quot;Больше 9, уходим отсюда!&quot;);
                optional = None;
            } else {
                println!(&quot;`i` равен `{:?}`. Попробуем еще раз.&quot;, i);
                optional = Some(i + 1);
            }
            // ^ Требует 3 уровня вложенности!
        },
        // Выходим из цикла в случаи ошибки деструктуризации:
        _ =&gt; { break; }
        // ^ Зачем это нужно? Должен быть способ сделать это лучше!
    }
}
#}</code></pre></pre>
<p>Использование <code>while let</code> делает этот пример немного приятнее:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Создадим переменную `optional` с типом `Option&lt;i32&gt;`
    let mut optional = Some(0);

    // Это можно прочитать так: &quot;Пока `let` деструктурирует `optional` в
    // `Some(i)`, выполняем блок (`{}`). В противном случае `break`.
    while let Some(i) = optional {
        if i &gt; 9 {
            println!(&quot;Больше 9, уходим отсюда!&quot;);
            optional = None;
        } else {
            println!(&quot;`i` равен `{:?}`. Попробуем ещё раз.&quot;, i);
            optional = Some(i + 1);
        }
        // ^ Меньше смещаемся вправо, к тому же
        // нет необходимости обрабатывать ошибки.
    }
    // ^ К `if let` можно добавить дополнительный блок `else`/`else if`
    // `while let` подобного нет.
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-21" id="Смотрите-также-21">Смотрите также:</a></h3>
<p><a href="flow_control/custom_types/enum.html"><code>enum</code></a>, <a href="flow_control/std/option.html"><code>Option</code></a>, and the <a href="https://github.com/rust-lang/rfcs/pull/214">RFC</a></p>
<h1><a class="header" href="#Функции" id="Функции">Функции</a></h1>
<p>Функции объявляются с помощью ключевого слова <code>fn</code>. Их аргументы имеют явно заданный тип,
как у переменных, и, если функция возвращает значение,
возвращаемый тип должен быть указан после стрелки <code>-&gt;</code>.</p>
<p>Последнее выражение в функции будет использовано как возвращаемое значение.
Так же можно использовать оператор <code>return</code>, чтобы вернуть значение из функции раньше,
даже из цикла или оператора <code>if</code>.</p>
<p>Давайте перепишем FizzBuzz используя функции!</p>
<pre><pre class="playpen"><code class="language-rust editable">// В отличие от С/С++, нет никаких ограничений касаемо порядка определений функций
fn main() {
    // Можно использовать функцию здесь, а определить где-нибудь потом
    fizzbuzz_to(100);
}

// Функция, возвращающая логическое значение
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    // Граничный случай, ранний возврат
    if rhs == 0 {
        return false;
    }

    // Это - выражение, ключевое слово `return` здесь не требуется
    lhs % rhs == 0
}

// Функция, которая «не возвращает» значение, на самом деле возвращает единичный тип `()`
fn fizzbuzz(n: u32) -&gt; () {
    if is_divisible_by(n, 15) {
        println!(&quot;fizzbuzz&quot;);
    } else if is_divisible_by(n, 3) {
        println!(&quot;fizz&quot;);
    } else if is_divisible_by(n, 5) {
        println!(&quot;buzz&quot;);
    } else {
        println!(&quot;{}&quot;, n);
    }
}

// Когда функция возвращает `()`, возвращаемый тип можно не указывать
fn fizzbuzz_to(n: u32) {
    for n in 1..n + 1 {
        fizzbuzz(n);
    }
}
</code></pre></pre>
<h1><a class="header" href="#Методы" id="Методы">Методы</a></h1>
<p>Методы - это функции, прикреплённые к объектам. Эти методы 
имеют допуск к данным объекта и другим его методам через 
ключевое слово <code>self</code>. Методы определяются под 
блоком <code>impl</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Point {
    x: f64,
    y: f64,
}

// Блок реализаций, все методы `Point` расположены здесь
impl Point {
    // Это статический метод
    // Статические методы не нуждаются в вызове от экземпляра
    // Эти методы, как правило, используются как конструкторы
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // Другой статический метод, берёт два аргумента
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // Это метод экземпляра
    // `&amp;self` - это сахар для `self: &amp;Self`, где `Self` - это тип
    // вызываемого объекта. В этом месте `Self` = `Rectangle`
    fn area(&amp;self) -&gt; f64 {
        // `self` даёт допуск к полям структуры через оператор точка
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs` - это метод `f64`, который возвращает абсолютную величину
        // вызываемого
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // Этот метод требует чтобы вызываемый объект был изменяемым
    // `&amp;mut self` - сахар для `self: &amp;mut Self`
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` владеет ресурсами: два целых числа в куче
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // Этот метод &quot;съедает&quot; ресурсы вызываемого объекта
    // `self` - сахар для `self: Self`
    fn destroy(self) {
        // деструктуризация `self`
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);

        // `first` и `second` выходят из области видимости и освобождаются
    }
}

fn main() {
    let rectangle = Rectangle {
        // Статические методы вызываются двойными двоеточиями
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // Метод экземпляра вызывается с помощью оператора точка
    // Обратите внимание, что первый аргумент `&amp;self` неявно пропускается т.е.
    // `rectangle.perimeter()` === `perimeter(&amp;rectangle)`
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // Ошибка! `rectangle` неизменяемый, но этот метод нуждается в изменяемом
    // объекте
    //rectangle.translate(1.0, 0.0);
    // ЗАДАНИЕ ^ Попробуйте удалить комментарий

    // Хорошо, изменяемый объект может вызывать изменяемые методы
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // Ошибка! `destroy` вызывает &quot;съеденный&quot; `pair`
    //pair.destroy();
    // ЗАДАНИЕ ^ Попробуйте удалить комментарий
}
</code></pre></pre>
<h1><a class="header" href="#Замыкания" id="Замыкания">Замыкания</a></h1>
<p>Замыкания в Rust, так же называемые лямбда, это функции,
которые замыкают своё окружение.
Для примера, замыкание, которое захватывает значение переменной x:</p>
<pre><code class="language-rust ignore">|val| val + x
</code></pre>
<p>Синтаксис и возможности замыканий делают их очень удобными
для использования &quot;на лету&quot;. Использование замыканий похоже на использование функций.
Однако, тип входных и возвращаемых значений <em>может</em> быть выведен, а
название аргумента <em>должно</em>  быть указано.</p>
<p>Другие характеристики замыканий включают в себя:</p>
<ul>
<li>использование <code>||</code> вместо <code>()</code> для аргументов.</li>
<li>опциональное ограничения тела функции (<code>{}</code>) для одного выражения
(в противном случае обязательно).</li>
<li>возможность захвата переменных за пределами окружения</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Инкремент с помощью замыкания и функции.
    fn  function            (i: i32) -&gt; i32 { i + 1 }

    // Замыкания анонимны. Тут мы связываем их с ссылками
    // Аннотация идентичны аннотации типов функции, но является опциональной
    // как и оборачивания тела в `{}`. Эти безымянные функции
    // назначены соответствующе названным переменным.
    let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
    let closure_inferred  = |i     |          i + 1  ;

    let i = 1;
    // Вызов функции и замыкания.
    println!(&quot;функция: {}&quot;, function(i));
    println!(&quot;замыкание с указанием типа: {}&quot;, closure_annotated(i));
    println!(&quot;замыкание с выводом типа: {}&quot;, closure_inferred(i));

    // Замыкание не принимает аргументов, но возвращает `i32`.
    // Тип возвращаемого значения выведен автоматически.
    let one = || 1;
    println!(&quot;замыкание, возвращающее один: {}&quot;, one());

}
</code></pre></pre>
<h1><a class="header" href="#Захват" id="Захват">Захват</a></h1>
<p>Замыкания довольно гибкие и делают всё, что требуется для работы с ними без
дополнительных указаний. Это позволяет захватывать переменные перемещая их или
заимствуя, в зависимости от необходимости.
Замыкания могут захватывать переменные:</p>
<ul>
<li>по ссылке: <code>&amp;T</code></li>
<li>по изменяемой ссылке: <code>&amp;mut T</code></li>
<li>по значению: <code>T</code></li>
</ul>
<p>Преимущественно, они захватывают переменные по ссылке, если явно не указан другой
способ.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    use std::mem;

    let color = &quot;green&quot;;

    // Замыкание для вывода `color`, которое немедленно заимствует (`&amp;`)
    // `color` и сохраняет замыкание в переменной `print`.
    // `color` будет оставаться заимствованным до выхода `print` из области
    // видимости. `println!` требует только ссылку, поэтому он не накладывает
    // дополнительных ограничений.
    let print = || println!(&quot;`color`: {}&quot;, color);

    // Вызываем замыкание, использующее заимствование.
    print();
    print();

    let mut count = 0;

    // Замыкание для увеличения `count` может принимать как `&amp;mut count`,
    // так и `count`, но использование `&amp;mut count` менее ограничено, так что
    // замыкание выбирает первый способ, т.е. немедленно заимствует `count`.
    //
    // `inc` должен быть `mut`, поскольку внутри него хранится `&amp;mut`.
    // Таким образом, вызов замыкания изменяет его, что недопустимо без `mut`.
    let mut inc = || {
        count += 1;
        println!(&quot;`count`: {}&quot;, count);
    };

    // Вызываем замыкание.
    inc();
    inc();

    //let reborrow = &amp;mut count;
    // ^ TODO: попробуйте раскомментировать эту строку.

    // Некопируемый тип.
    let movable = Box::new(3);

    // `mem::drop` требует `T`, так что захват производится по значению.
    // Копируемый тип будет скопирован в замыкание, оставив оригинальное
    // значение без изменения. Некопируемый тип должен быть перемещён, так что
    // `movable` немедленно перемещается в замыкание.
    let consume = || {
        println!(&quot;`movable`: {:?}&quot;, movable);
        mem::drop(movable);
    };

    // `consume` поглощает переменную, так что оно может быть вызвано только один раз.
    consume();
    //consume();
    // ^ TODO: Попробуйте раскомментировать эту строку.
}
</code></pre></pre>
<p>Использование <code>move</code> перед вертикальными линиями позваляет получить владение над захваченными переменными:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `Vec` не поддерживает копирование.
    let haystack = vec![1, 2, 3];

    let contains = move |needle| haystack.contains(needle);

    println!(&quot;{}&quot;, contains(&amp;1));
    println!(&quot;{}&quot;, contains(&amp;4));

    // `println!(&quot;Количество элементов {} в векторе&quot;, haystack.len());`
    // ^ уберите комментарий с этой строки и в результате получите ошибку компиляции,
    // потому что анализатор заимствований не позволяет использовать
    // переменную после передачи владения.
    
    //  Удалите `move` у замыкания и _haystack_ будет заимствован по неизменяемой 
    // ссылке, и удалённый комментарий теперь не вызывает ошибки.
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-22" id="Смотрите-также-22">Смотрите также:</a></h3>
<p><a href="fn/closures/../../std/box.html"><code>Box</code></a> и <a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a></p>
<h1><a class="header" href="#Как-входные-параметры" id="Как-входные-параметры">Как входные параметры</a></h1>
<p>В то время как замыкания Rust выбирают способ захвата переменных на лету, по
большей части без указания типов, эта двусмысленность недопустима при написании
функций. При использовании замыкания в качестве входного параметра, его тип
должен быть указан с использованием одного из <code>типажей</code>. Вот они, в порядке
уменьшения ограничений:</p>
<ul>
<li><code>Fn</code>: замыкание захватывает по ссылке (<code>&amp;T</code>)</li>
<li><code>FnMut</code>: замыкание захватывает по изменяемой ссылке (<code>&amp;mut T</code>)</li>
<li><code>FnOnce</code>: замыкание захватывает по значению (<code>T</code>)</li>
</ul>
<p>Компилятор стремится захватывать переменные наименее ограничивающим способом.</p>
<p>Для примера, рассмотрим аргумент, указанный как <code>FnOnce</code>. Это означает, что
замыкание <em>может</em> захватывать <code>&amp;T</code>, <code>&amp;mut T</code>, или <code>T</code>, но компилятор в итоге
будет выбирать в зависимости от того, как захваченные переменные используются
в замыкании.</p>
<p>Это связано с тем, что если перемещение возможно, тогда любой тип заимствования
также должен быть возможен. Отметим, что обратное не верно. Если параметр
указан как <code>Fn</code>, то захват переменных как <code>&amp;mut T</code> или <code>T</code> недопустим.</p>
<p>В следующем примере попробуйте поменять местами использование <code>Fn</code>, <code>FnMut</code>, и
<code>FnOnce</code>, чтобы увидеть результат:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Функция, которая принимает замыкание в качестве аргумента и вызывает его.
fn apply&lt;F&gt;(f: F) where
    // Замыкание ничего не принимает и не возвращает.
    F: FnOnce() {
    // ^ TODO: Попробуйте изменить это на `Fn` или `FnMut`.

    f();
}

// Функция, которая принимает замыкание и возвращает `i32`.
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    // Замыкание принимает `i32` и возвращает `i32`.
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = &quot;привет&quot;;
    // Некопируемый тип.
    // `to_owned` преобразует заимствованные данные в собственные.
    let mut farewell = &quot;пока&quot;.to_owned();

    // Захват двух переменных: `greeting` по ссылке и
    // `farewell` по значению.
    let diary = || {
        // `greeting` захватывается по ссылке: требует `Fn`.
        println!(&quot;Я сказал {}.&quot;, greeting);

        // Изменяемость требует от `farewell` быть захваченным
        // по изменяемой ссылке. Сейчас требуется `FnMut`.
        farewell.push_str(&quot;!!!&quot;);
        println!(&quot;Потом я закричал {}.&quot;, farewell);
        println!(&quot;Теперь я могу поспать. zzzzz&quot;);

        // Ручной вызов удаления требуется от `farewell`
        // быть захваченным по значению. Теперь требуется `FnOnce`.
        mem::drop(farewell);
    };

    // Вызов функции, которая выполняет замыкание.
    apply(diary);

    // `double` удовлетворяет ограничениям типажа `apply_to_3`
    let double = |x| 2 * x;

    println!(&quot;Удвоенное 3: {}&quot;, apply_to_3(double));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-23" id="Смотрите-также-23">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, и <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<h1><a class="header" href="#Анонимность-типов" id="Анонимность-типов">Анонимность типов</a></h1>
<p>Замыкания временно захватывают переменные из окружающих областей видимости.
Имеет ли это какие-либо последствия? Конечно. Как видите, использование
замыкания в аргументах функции требует <a href="fn/closures/generics.html">обобщённых типов</a> из-за
особенностей реализации замыканий:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// `F` должен быть обобщённым типом.
fn apply&lt;F&gt;(f: F) where
    F: FnOnce() {
    f();
}
#}</code></pre></pre>
<p>Во время определения замыкания компилятор неявно создаёт новую анонимную
структуру для хранения захваченных переменных, тем временем реализуя
функциональность для некого неизвестного типа с помощью одного из типажей: <code>Fn</code>,
<code>FnMut</code>, или <code>FnOnce</code>. Этот тип присваивается переменной, которая хранится до
самого вызова замыкания.</p>
<p>Так как этот новый тип заранее неизвестен, любое его использование в функции
потребует обобщённых типов. Тем не менее, неограниченный параметр типа <code>&lt;T&gt;</code>
по прежнему будет неоднозначным и недопустим. Таким образом, ограничение по
одному из типажей: <code>Fn</code>, <code>FnMut</code>, или <code>FnOnce</code> (которые он реализует) необходимо
для использования этого типа.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `F` должен реализовать `Fn` для замыкания, которое
// ничего не принимает и не возвращает - именно то,
// что нужно для `print`.
fn apply&lt;F&gt;(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // Захватываем `x` в анонимный тип и реализуем
    // `Fn` для него. Сохраняем его как `print`.
    let print = || println!(&quot;{}&quot;, x);

    apply(print);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-24" id="Смотрите-также-24">Смотрите также:</a></h3>
<p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">Подробный разбор</a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>,
и <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<h1><a class="header" href="#Входные-функции" id="Входные-функции">Входные функции</a></h1>
<p>Так как замыкания могут использоваться в аргументах, вы можете ожидать, что то
же самое можно сказать и про функции. И это действительно так! Если вы
объявляете функцию, принимающую замыкание как аргумент, то любая функция,
удовлетворяющая ограничениям типажа этого замыкания, может быть передана как
аргумент.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Объявляем функцию, которая принимает обобщённый тип `F`,
// ограниченный типажом `Fn`, и вызывает его.
fn call_me&lt;F: Fn()&gt;(f: F) {
    f();
}

// Объявляем функцию-обёртку, удовлетворяющую ограничению `Fn`
fn function() {
    println!(&quot;Я функция!&quot;);
}

fn main() {
    // Определяем замыкание, удовлетворяющее ограничению `Fn`
    let closure = || println!(&quot;Я замыкание!&quot;);

    call_me(closure);
    call_me(function);
}
</code></pre></pre>
<p>Стоит отметить, что типажи <code>Fn</code>, <code>FnMut</code> и <code>FnOnce</code> указывают, как
замыкание захватывает переменные из своей области видимости.</p>
<h3><a class="header" href="#Смотрите-также-25" id="Смотрите-также-25">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, и <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<h1><a class="header" href="#Как-выходные-параметры" id="Как-выходные-параметры">Как выходные параметры</a></h1>
<p>Замыкания могут использоваться как входные параметры, следовательно их возврат в
качестве выходных параметров также должен быть возможен. Однако, это сопряжено
с трудностями из-за того, что Rust в настоящее время поддерживает только возврат
конкретных (не обобщённых) типов. Типы анонимных замыканий, по определению,
неизвестны. И поэтому возвращение замыканий возможно только путём конкретизации
их типов. Это можно реализовать упаковав замыкание.</p>
<p>Возможные типажи для возвращаемых значений немного отличаются от прежних:</p>
<ul>
<li><code>Fn</code>: как раньше</li>
<li><code>FnMut</code>: как раньше</li>
<li><code>FnOnce</code>: здесь присутствуют некоторые неожиданности, поэтому необходим тип<a href="https://doc.rust-lang.org/std/boxed/trait.FnBox.html"><code>FnBox</code></a>, но он нестабилен в настоящее время. В будущем ожидаютсяизменения этой ситуации.</li>
</ul>
<p>Помимо этого, должно быть использовано ключевое слово <code>move</code>, чтобы
сигнализировать о том, что все переменные захватываются по значению. Это
необходимо, так как любые захваченные по ссылке значения будут удалены после
выхода из функции, оставляя недопустимые ссылки в замыкании.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn create_fn() -&gt; Box&lt;Fn()&gt; {
    let text = &quot;Fn&quot;.to_owned();

    Box::new(move || println!(&quot;Это a: {}&quot;, text))
}

fn create_fnmut() -&gt; Box&lt;FnMut()&gt; {
    let text = &quot;FnMut&quot;.to_owned();

    Box::new(move || println!(&quot;Это a: {}&quot;, text))
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();

    fn_plain();
    fn_mut();
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-26" id="Смотрите-также-26">Смотрите также:</a></h3>
<p><a href="fn/closures/../../std/box.html">Упаковка</a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, и <a href="fn/closures/../../generics.html">Обобщения</a>.</p>
<h1><a class="header" href="#Примеры-из-библиотеки-std" id="Примеры-из-библиотеки-std">Примеры из библиотеки <code>std</code></a></h1>
<p>Этот раздел содержит несколько примеров использования замыканий из библиотеки <code>std</code>.</p>
<h1><a class="header" href="#iteratorany" id="iteratorany">Iterator::any</a></h1>
<p><code>Iterator::any</code> - это функция, которая принимает итератор и возвращает <code>true</code>,
если любой элемент удовлетворяет предикату. Иначе возвращает <code>false</code>. Её
объявление:</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // Тип, по которому выполняется итерирование
    type Item;

    // `any` принимает `&amp;mut self`, что означает заимствование
    // и изменение, но не поглощение `self`.
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where
        // `FnMut` означает, что любая захваченная переменная
        // может быть изменена, но не поглощена. `Self::Item`
        // указывает на захват аргументов замыкания по значению.
        F: FnMut(Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` для векторов даёт `&amp;i32`. Приводим к `i32`.
    println!(&quot;2 в vec1: {}&quot;, vec1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()` для векторов даёт `i32`. Приведения не требуется.
    println!(&quot;2 в vec2: {}&quot;, vec2.into_iter().any(| x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` для массивов даёт `&amp;i32`.
    println!(&quot;2 в array1: {}&quot;, array1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()` для массивов неожиданно даёт `&amp;i32`.
    println!(&quot;2 в array2: {}&quot;, array2.into_iter().any(|&amp;x| x == 2));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-27" id="Смотрите-также-27">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>std::iter::Iterator::any</code></a></p>
<h1><a class="header" href="#iteratorfind" id="iteratorfind">Iterator::find</a></h1>
<p><code>Iterator::find</code> - это функция, которая принимает итератор и возвращает первый
элемент, который удовлетворяет предикату, в виде <code>Option</code>. Её объявление:</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // Тип, по которому выполняется итерирование
    type Item;

    // `find` принимает `&amp;mut self`, что означает заимствование и
    // изменение, но не поглощение `self`.
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where
        // `FnMut` означает, что любая захваченная переменная
        // может быть изменена, но не поглощена. `&amp;Self::Item`
        // указывает на захват аргументов замыкания по ссылке.
        P: FnMut(&amp;Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` для векторов даёт `&amp;i32`.
    let mut iter = vec1.iter();
    // `into_iter()` для векторов даёт `i32`.
    let mut into_iter = vec2.into_iter();

    // Ссылка на это даёт `&amp;&amp;i32`. Приводим к `i32`.
    println!(&quot;Найти 2 в vec1: {:?}&quot;, iter     .find(|&amp;&amp;x| x == 2));
    // Ссылка на это даёт `&amp;i32`. Приводим к `i32`.
    println!(&quot;Найти 2 в vec2: {:?}&quot;, into_iter.find(| &amp;x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` для массивов даёт `&amp;i32`
    println!(&quot;Найти 2 в array1: {:?}&quot;, array1.iter()     .find(|&amp;&amp;x| x == 2));
    // `into_iter()` для массивов неожиданно даёт `&amp;i32`
    println!(&quot;Найти 2 в array2: {:?}&quot;, array2.into_iter().find(|&amp;&amp;x| x == 2));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-28" id="Смотрите-также-28">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>std::iter::Iterator::find</code></a></p>
<h1><a class="header" href="#Функции-высшего-порядка" id="Функции-высшего-порядка">Функции высшего порядка</a></h1>
<p>Rust предоставляет Функции Высшего Порядка (ФВП). Это функции,
которые получают на вход одну или больше функций и
производят более полезные функции.
ФВП и ленивые итераторы дают языку Rust функциональный вид.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}

fn main() {
    println!(&quot;Найти сумму всех квадратов нечётных чисел не больше 1000&quot;);
    let upper = 1000;

    // Императивный подход
    // Объявляем переменную-накопитель
    let mut acc = 0;
    // Итерировать: 0, 1, 2, ... до бесконечности
    for n in 0.. {
        // Квадрат числа
        let n_squared = n * n;

        if n_squared &gt;= upper {
            // Остановить цикл, если превысили верхний лимит
            break;
        } else if is_odd(n_squared) {
            // Складывать число, если оно нечётное
            acc += n_squared;
        }
    }
    println!(&quot;императивный стиль: {}&quot;, acc);

    // Функциональный подход
    let sum_of_squared_odd_numbers: u32 =
        (0..).map(|n| n * n)             // Все натуральные числа возводим в квадрат
             .take_while(|&amp;n| n &lt; upper) // Ниже верхнего предела
             .filter(|n| is_odd(*n))     // Выбираем нечётные
             .fold(0, |sum, i| sum + i); // Суммируем
    println!(&quot;функциональный стиль: {}&quot;, sum_of_squared_odd_numbers);
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/core/option/enum.Option.html">Option</a>
и
<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a>
реализуют свою часть функций высшего порядка..</p>
<h1><a class="header" href="#Расходящиеся-функции" id="Расходящиеся-функции">Расходящиеся функции</a></h1>
<p>Расходящиеся функции никогда не возвращают результат. Они помечены с помощью <code>!</code>, который является пустым типом.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() -&gt; ! {
    panic!(&quot;Этот вызов никогда не вернёт управление.&quot;);
}
#}</code></pre></pre>
<p>В отличие от всех других типов, этот не может быть создан, потому что
набор всех возможных значений этого типа пуст. Обратите 
внимание, что он отличается от типа <code>()</code>, который 
имеет ровно одно возможное значение.</p>
<p>Например, эта функция имеет возвращаемое значение, хотя о нём
нет информации.</p>
<pre><pre class="playpen"><code class="language-rust">fn some_fn() {
    ()
}

fn main() {
    let a: () = some_fn();
    println!(&quot;Эта функция возвращает управление и вы можете увидеть эту строку.&quot;)
}
</code></pre></pre>
<p>В отличие от этой функции, которая никогда не вернёт элемент управления вызывающей стороне.</p>
<pre><code class="language-rust ignore">#![feature(never_type)]

fn main() {
    let x: ! = panic!(&quot;Этот вызов никогда не вернёт управление.&quot;);
    println!(&quot;вы никогда не увидете эту строку!&quot;);
}
</code></pre>
<p>Хотя это может показаться абстрактным понятием, на самом деле 
это очень полезно и может пригодится. Главное преимущество 
этого типа в том, что его можно привести к любому другому типу и 
поэтому используется в местах, где требуется точный тип, 
например в ветвях <code>match</code>. Это позволяет нам писать 
такой код:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    fn sum_odd_numbers(up_to: u32) -&gt; u32 {
        let mut acc = 0;
        for i in 0..up_to {
            // Обратите внимание, что возвращаемый тип этого выражения match должен быть u32
            // потому что такой тип в переменной &quot;addition&quot; .
            let addition: u32 = match i%2 == 1 {
                // Переменная &quot;i&quot; типа u32, что совершенно нормально.
                true =&gt; i,
                // С другой стороны выражение &quot;continue&quot; не возвращает
                // u32, но это тоже нормально, потому что это тип не возвращающий управление,
                // не нарушает требования к типу выражения match.
                false =&gt; continue,
            };
            acc += addition;
        }
        acc
    }
    println!(&quot;Сумма нечётных чисел до 9 (исключая): {}&quot;, sum_odd_numbers(9));
}
</code></pre></pre>
<p>Это также возвращаемый тип функций, которые содержат вечный 
цикл (например,  <code>loop {}</code>), как сетевые серверы или 
функции, завершающие процесс (например,  <code>exit()</code>).</p>
<h1><a class="header" href="#Модули" id="Модули">Модули</a></h1>
<p>Rust предоставляет мощную систему модулей, которая используется
для иерархического разделения кода на логические единицы (модули) и
управления видимостью (публичное и приватное) между ними.</p>
<p>Модуль - это набор элементов, таких как: функции, структуры, типажи, блоки реализации (<code>impl</code>)
и даже другие модули.</p>
<h1><a class="header" href="#Видимость" id="Видимость">Видимость</a></h1>
<p>По умолчанию, элементы модуля являются приватными,
но это можно изменить добавив модификатор <code>pub</code>.
Только публичные элементы модуля могут быть доступны за пределами его области видимости.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Модуль по имени `my_mod`
mod my_mod {
    // Все элементы модуля по умолчанию являются приватными.
    fn private_function() {
        println!(&quot;вызвана `my_mod::private_function()`&quot;);
    }

    // Используем модификатор `pub`, чтобы сделать элемент публичным.
    pub fn function() {
        println!(&quot;вызвана `my_mod::function()`&quot;);
    }

    // Приватные элементы модуля доступны другим элементам
    // данного модуля.
    pub fn indirect_access() {
        print!(&quot;вызвана `my_mod::indirect_access()`, которая\n&gt; &quot;);
        private_function();
    }

    // Модули так же могут быть вложенными
    pub mod nested {
        pub fn function() {
            println!(&quot;вызвана `my_mod::nested::function()`&quot;);
        }

        #[allow(dead_code)]
        fn private_function() {
            println!(&quot;вызвана `my_mod::nested::private_function()`&quot;);
        }

        // Функции объявленные с использованием синтаксиса `pub(in path)` будет видна
        // только в пределах заданного пути.
        // `path` должен быть родительским или наследуемым модулем
        pub(in my_mod) fn public_function_in_my_mod() {
            print!(&quot;вызвана `my_mod::nested::public_function_in_my_mod()`, которая\n &gt; &quot;);
            public_function_in_nested()
        }

        // Функции объявленные с использованием синтаксиса `pub(self)` будет видна
        // только в текущем модуле
        pub(self) fn public_function_in_nested() {
            println!(&quot;вызвана `my_mod::nested::public_function_in_nested&quot;);
        }

        // Функции объявленные с использованием синтаксиса `pub(super)` будет видна
        // только в родительском модуле
        pub(super) fn public_function_in_super_mod() {
            println!(&quot;вызвана my_mod::nested::public_function_in_super_mod&quot;);
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!(&quot;вызвана `my_mod::call_public_funcion_in_my_mod()`, которая\n&gt; &quot;);
        nested::public_function_in_my_mod();
        print!(&quot;&gt; &quot;);
        nested::public_function_in_super_mod();
    }

    // pub(crate) сделает функцию видимой для всего текущего контейнера
    pub(crate) fn public_function_in_crate() {
        println!(&quot;called `my_mod::public_function_in_crate()&quot;);
    }

    // Вложенные модули подчиняются тем же правилам видимости
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!(&quot;вызвана `my_mod::private_nested::function()`&quot;);
        }
    }
}

fn function() {
    println!(&quot;вызвана `function()`&quot;);
}

fn main() {
    // Модули позволяют устранить противоречия между элементами,
    // которые имеют одинаковые названия.
    function();
    my_mod::function();

    // Публичные элементы, включая те, что находятся во вложенном модуле,
    // доступны извне родительского модуля
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate) элементы можно вызвать от везде в этом же пакете
    my_mod::public_function_in_crate();
    
    // pub(in path) элементы могут вызываться только для указанного пути
    // Ошибка! функция `public_function_in_my_mod` приватная
    //my_mod::nested::public_function_in_my_mod();
    // TODO ^ Попробуйте раскомментировать эту строку

    // Приватные элементы модуля не доступны напрямую,
    // даже если вложенный модуль является публичным:

    // Ошибка! функция `private_function` приватная
    //my_mod::private_function();
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Ошибка! функция `private_function` приватная
    //my_modmy::nested::private_function();
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Ошибка! Модуль `private_nested` является приватным
    //my_mod::private_nested::function();
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку
}
</code></pre></pre>
<h1><a class="header" href="#Видимость-структуры" id="Видимость-структуры">Видимость структуры</a></h1>
<p>Структуры имеют дополнительный уровень видимости благодаря полями. По умолчанию
видимость полей приватная, но, это можно изменить с помощью модификатора <code>pub</code>.
Приватная видимость имеет значение только при обращении к структуре извне модуля,
где она определена, и необходимо скрыть информацию (инкапсуляция).</p>
<pre><pre class="playpen"><code class="language-rust editable">mod my {
   // Публичная структура с публичным полем обобщённого типа `T`
    pub struct OpenBox&lt;T&gt; {
        pub contents: T,
    }

    // Публичная структура с приватным полем обобщённого типа `T`
    #[allow(dead_code)]
    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        // Публичный конструктор
        pub fn new(contents: T) -&gt; ClosedBox&lt;T&gt; {
            ClosedBox {
                contents: contents,
            }
        }
    }
}

fn main() {
    // Публичная структура с публичным полем может быть создана, как обычно
    let open_box = my::OpenBox { contents: &quot;публичную информацию&quot; };

    // а их поля доступны всем.
    println!(&quot;Открытая упаковка хранит: {}&quot;, open_box.contents);

    // Публичные структуры с приватными полями не могут быть созданы, используя имя полей
    // Ошибка! `ClosedBox` имеет приватные поля
    //let closed_box = my::ClosedBox { contents: &quot;классифицированную информацию&quot; };
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Однако, структуры с приватными полями могут быть созданы с помощью
    // публичного конструктора
    let _closed_box = my::ClosedBox::new(&quot;классифицированную информацию&quot;);

    // нельзя получить доступ к приватным полям публичных структур.
    // Ошибка! Поле `contents` приватное
    //println!(&quot;Закрытая упаковка хранит: {}&quot;, _closed_box.contents);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-29" id="Смотрите-также-29">Смотрите также:</a></h3>
<p><a href="mod/generics.html">generics</a> и <a href="mod/fn/methods.html">методы</a></p>
<h1><a class="header" href="#Декларация-use-1" id="Декларация-use-1">Декларация <code>use</code></a></h1>
<p>Декларация <code>use</code> используется, чтобы связать полный путь с новым именем,
что упрощает доступ.</p>
<pre><code class="language-rust editable ignore">// extern crate deeply; // обычно эта строка есть и она не закомментирована!

use crate::deeply::nested::{
    my_first_function,
    my_second_function,
    AndATraitType
};

fn main() {
    my_first_function();
}
</code></pre>
<p>Вы можете использовать ключевое слово <code>as</code>, что импортировать сущности и функции под другим именем:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Привязать путь `deeply::nested::function` к `other_function`.
use deeply::nested::function as other_function;

fn function() {
    println!(&quot;вызвана `function()`&quot;);
}

mod deeply {
    pub mod nested {
        pub fn function() {
            println!(&quot;вызвана `deeply::nested::function()`&quot;)
        }
    }
}

fn main() {
    // Упрощённый доступ к `deeply::nested::function`
    other_function();

    println!(&quot;Entering block&quot;);
    {
        // Эквивалентно `use deeply::nested::function as function`.
        // `function()` затенение собой внешнюю функцию.
        use deeply::nested::function;
        function();

        // у привязок `use` локальная область видимости. В данном случае
        // внешняя `function()` затенена только в этом блоке.
        println!(&quot;Leaving block&quot;);
    }

    function();
}
</code></pre></pre>
<h1><a class="header" href="#super-и-self" id="super-и-self"><code>super</code> и <code>self</code></a></h1>
<p>Ключевые слова <code>super</code> и <code>self</code> в пути используются, 
чтобы устранить неоднозначность между используемыми элементами модуля.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn function() {
    println!(&quot;вызвана `function()`&quot;);
}

mod cool {
    pub fn function() {
        println!(&quot;called `cool::function()`&quot;);
    }
}

mod my {
    fn function() {
        println!(&quot;вызвана `my::function()`&quot;);
    }
    
    mod cool {
        pub fn function() {
            println!(&quot;вызвана `my::cool::function()`&quot;);
        }
    }
    
    pub fn indirect_call() {
        // Давайте вызовем  все функции под названием `function` в этой области видимости!
        print!(&quot;вызвана `my::indirect_call()`, с помощью которой\n&gt; &quot;);
        
        // Ключевое слово `self` ссылается на область видимости текущего модуля. 
        // В нашем случае - модуль `my`.
        // Вызов `self::function()`, так же как и вызов `function()` дают одинаковый результат,
        // т.к они ссылаются на одну и ту же функцию.
        self::function();
        function();
        
        // Мы так же можем использовать ключевое слово `self`,
        // чтобы получить доступ к другим модулям внутри модуля `my`:
        self::cool::function();
        
        // Ключевое слово `super` ссылается на родительскую область видимости (вне модуля `my`).
        super::function();
        
        // Этим действием мы свяжем `cool::function` в области видимости *контейнера*.
        // В данном случае область видимости контейнера является самой дальней областью видимости.
        {
            use cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}
</code></pre></pre>
<h1><a class="header" href="#Иерархия-файлов" id="Иерархия-файлов">Иерархия файлов</a></h1>
<p>Модули могут быть отображены на иерархию файлов и директорий.
Давайте разобьём <a href="mod/mod/visibility.html">пример с видимостью модулей</a> на файлы:</p>
<pre><code class="language-bash">$ tree .
.
|-- my
|   |-- inaccessible.rs
|   |-- mod.rs
|   `-- nested.rs
`-- split.rs
</code></pre>
<p>В <code>split.rs</code>:</p>
<pre><code class="language-rust ignore">// Эта декларация найдёт файл с именем `my.rs` или `my/mod.rs` и вставит
// его содержимое внутрь модуля с именем `my` в этой области видимости
mod my;

fn function() {
    println!(&quot;вызвана `function()`&quot;);
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}

</code></pre>
<p>В <code>my/mod.rs</code>:</p>
<pre><code class="language-rust ignore">// Точно так же, `mod inaccessible` и `mod nested` обнаружат файлы `nested.rs`
// и `inaccessible.rs`, и затем вставят их здесь в соответствующие модули

mod inaccessible;
pub mod nested;

pub fn function() {
    println!(&quot;вызвана `my::function()`&quot;);
}

fn private_function() {
    println!(&quot;вызывает `my::private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;вызвана `my::indirect_access()`, которая\n&gt; &quot;);

    private_function();
}
</code></pre>
<p>В <code>my/nested.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn function() {
    println!(&quot;вызвана `my::nested::function()`&quot;);
}

#[allow(dead_code)]
fn private_function() {
    println!(&quot;вызвана `my::nested::private_function()`&quot;);
}
</code></pre>
<p>В <code>my/inaccessible.rs</code>:</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
pub fn public_function() {
    println!(&quot;вызвана `my::inaccessible::public_function()`&quot;);
}
</code></pre>
<p>Давайте проверим, что все ещё работает, как раньше:</p>
<pre><code class="language-bash">$ rustc split.rs &amp;&amp; ./split
вызвана `my::function()`
вызвана `function()`
вызвана `my::indirect_access()`, которая
&gt; вызвана `my::private_function()`
вызвана `my::nested::function()`
</code></pre>
<h1><a class="header" href="#Контейнеры" id="Контейнеры">Контейнеры</a></h1>
<p>Контейнер (<code>crate</code>) — единица компиляции в языке Rust.
Когда вызывается <code>rustc some_file.rs</code>, <code>some_file.rs</code> обрабатывается как <em>файл контейнера</em>.
Если в <code>some_file.rs</code> есть декларация <code>mod</code>, то содержимое модуля
будет объединено с файлом контейнера <em>перед</em> его компиляцией.
Другими словами, модули <em>не</em> собираются отдельно, собираются лишь контейнеры.</p>
<p>Контейнер может быть скомпилирован в исполняемый файл или в библиотеку.
По умолчанию, <code>rustc</code> создаёт из контейнера исполняемый файл.
Это поведение может быть изменено добавлением флага <code>--crate-type</code> к <code>rustc</code>.</p>
<h1><a class="header" href="#Библиотеки" id="Библиотеки">Библиотеки</a></h1>
<p>Давайте создадим библиотеку и посмотрим, как связать её с другим контейнером.</p>
<pre><code class="language-rust ignore">pub fn public_function() {
    println!(&quot;вызвана `public_function()` библиотеки rary&quot;);
}

fn private_function() {
    println!(&quot;вызвана `private_function()` библиотеки rary&quot;);
}

pub fn indirect_access() {
    print!(&quot;вызвана `indirect_access()` библиотеки rary, и в ней\n&gt; &quot;);

    private_function();
}
</code></pre>
<pre><code class="language-bash">$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
</code></pre>
<p>Библиотеки получают префикс «lib», и по умолчанию имеют то же имя,
что и их контейнеры, но это имя можно изменить
с помощью <a href="crates/attribute/crate.html">атрибута <code>crate_name</code></a>.</p>
<h1><a class="header" href="#extern-crate" id="extern-crate"><code>extern crate</code></a></h1>
<p>Чтобы связать контейнер с новой библиотекой, нужна декларация <code>extern crate</code>.
Она не только свяжет библиотеку, но и импортирует все элементы в модуль
с тем же именем, что и сама библиотека.
Правила видимости, применимые к модулям, так же применимы и к библиотекам.</p>
<pre><code class="language-rust ignore">// Ссылка на `library`. Импортируем элементы, как модуль `rary`
extern crate rary;

fn main() {
    rary::public_function();

    // Ошибка! Функция `private_function` приватная
    //rary::private_function();

    rary::indirect_access();
}
</code></pre>
<pre><code class="language-bash"># Где library.rlib путь к скомпилированной библиотеке. Предположим, что
# она находится в той же директории:
$ rustc executable.rs --extern rary=library.rlib &amp;&amp; ./executable
вызвана `public_function()` библиотеки rary
вызвана `indirect_access()` библиотеки rary, и в ней
&gt; вызвана `private_function()` библиотеки rary
</code></pre>
<h1><a class="header" href="#cargo" id="cargo">Cargo</a></h1>
<p><code>cargo</code> - официальный менеджер пакетов языка Rust. В нем много функций
для улучшения качества кода и увеличения скорости разработки! К ним относятся:</p>
<ul>
<li>Управление зависимостями и интеграция с <a href="https://crates.io">crates.io</a> (официальный реестр пакетов Rust)</li>
<li>Осведомлённость о модульных тестах</li>
<li>Осведомлённость о тестах производительности</li>
</ul>
<p>Эта глава рассказывает об основах, но вы можете найти полное описание
по адресу <a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a>.</p>
<h1><a class="header" href="#Зависимости" id="Зависимости">Зависимости</a></h1>
<p>Большинство программ зависят от нескольких библиотек. Если вам приходилось
когда-либо управлять зависимостями вручную, вы знаете, сколько боли это
может доставить. К счастью экосистема языка Rust содержит такой
инструмент как <code>cargo</code>! <code>cargo</code> может управлять зависимостями проекта.</p>
<p>Создание нового проекта на языке Rust:</p>
<pre><code class="language-sh"># Исполняемый проект (проект с программой)
cargo new foo

# ИЛИ библиотека
cargo new --lib foo
</code></pre>
<p>Для остальной части этой главы предполагается, что мы делаем двоичный файл, а не
библиотеку, но все понятия одинаковы.</p>
<p>После приведённых выше команд, вы должны увидеть что-то вроде этого:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p><code>main.rs</code> - это корневой файл вашего нового проекта.
<code>Cargo.toml</code> - это конфигурационный файл этого проекта (<code>foo</code>) для <code>cargo</code>.
Если посмотрите внутрь файла, вы должны увидеть что-то вроде этого:</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
</code></pre>
<p>Поле <code>name</code> под <code>package</code> определяет имя проекта. Оно используется
если Вы будете его публиковать на <code>crates.io</code> (более подробно позже).
Также это имя выходного файла при компиляции.</p>
<p>Поле <code>version</code> - это версия пакета, записанное с использованием системы
<a href="http://semver.org/">семантического версионирования</a>.</p>
<p>Поле <code>authors</code> содержит список авторов пакета и используется при публикации.</p>
<p>В секции <code>dependencies</code> Вы можете указывать зависимости вашего проекта.</p>
<p>Предположим, что вы хотите, чтобы ваша программа имела отличный CLI.
Вы можете найти много хороших пакетов на <a href="https://crates.io">crates.io</a><a href="https://crates.io">(официальный реестр пакетов языка Rust). Один из популярных вариантов - </a><a href="https://crates.io/crates/clap">clap</a>. На момент написания этой статьи
самой последней опубликованной версией <code>clap</code> является <code>2.27.1</code>.
Для добавления зависимости в ваш проект, вы можете просто добавить
соответствующую запись в Ваш <code>Cargo.toml</code> под <code>dependencies</code>: <code>clap = &quot;2.27.1&quot;</code>.
И конечно, <code>extern crate clap</code> в <code>main.rs</code>. И это все! Вы можете начать
использовать <code>clap</code> в вашей программе.</p>
<p><code>cargo</code> также поддерживает <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">другие типы зависимостей</a>. Здесь только
небольшие примеры:</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
clap = &quot;2.27.1&quot; # из crates.io
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; } # из онлайн репозитория
bar = { path = &quot;../bar&quot; } # из локальной файловой системы
</code></pre>
<p><code>cargo</code> больше чем менеджер зависимостей. Все поддерживаемые возможности доступны
в <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">спецификации формата</a> <code>Cargo.toml</code>.</p>
<p>Для сборки проекта Вы можете выполнить команду <code>cargo build</code> в любой директории проекта
(включая поддиректории!). Также Вы можете выполнить <code>cargo run</code> для сборки и запуска.
Обратите внимание, что эти команды разрешат все зависимости, скачают пакеты
если нужно, и соберут все, включая ваш пакет. (Обратите внимание, что он собирает только то,
что ещё не собрал, подобно <code>make</code>).</p>
<p>Вот и все!</p>
<h1><a class="header" href="#Соглашения" id="Соглашения">Соглашения</a></h1>
<p>В предыдущей главе мы видели следующую иерархию каталогов:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>Предположим, что мы хотим иметь два двоичных файла в одном проекте. Что
тогда?</p>
<p>Оказывается, <code>cargo</code> это поддерживает. Двоичный файл по умолчанию называется <code>main.rs</code>,
это мы видели раньше, но вы можете добавить дополнительные файлы, поместив
их в каталог <code>bin/</code>:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    ├── main.rs
    └── bin
        └── my_other_bin.rs
</code></pre>
<p>Чтобы сказать <code>cargo</code> скомпилировать или запустить этот двоичный файл,
мы просто передаём <code>cargo</code> флаг <code>--bin my_other_bin</code>, где <code>my_other_bin</code>
это имя двоичного файла, с которым мы хотим работать.</p>
<p>Помимо дополнительных двоичных файлов, в <code>cargo</code> есть
<a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">встроенная поддержка</a> примеров, модульных тестов,
интеграционных тестов и тестов на производительность.</p>
<p>В следующей главе мы более подробно рассмотрим тесты.</p>
<h1><a class="header" href="#Тестирование" id="Тестирование">Тестирование</a></h1>
<p>Как мы знаем, тестирование является неотъемлемой частью любого программного обеспечения! Rust имеет первоклассную поддержку модульного и интеграционного тестирования (см.
<a href="https://doc.rust-lang.org/book/ch11-00-testing.html">главу о тестировании в TRPL</a>).</p>
<p>Из разделов тестирования, приведённых выше, мы знаем, как писать модульные и интеграционные тесты. Организационно, мы можем расположить модульные тесты в модулях, которые они тестируют, а интеграционные - в собственном каталоге <code>tests/</code>:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
├── src
│   └── main.rs
└── tests
    ├── my_test.rs
    └── my_other_test.rs
</code></pre>
<p>Каждый файл в каталоге <code>tests</code> - это отдельный интеграционный тест.</p>
<p><code>cargo</code>  естественно, обеспечивает простой способ запуска всех ваших тестов!</p>
<pre><code class="language-shell">$ cargo test
</code></pre>
<p>Вы должны увидеть примерно такой результат:</p>
<pre><code class="language-shell">$ cargo test
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 3 tests
test test_bar ... ok
test test_baz ... ok
test test_foo_bar ... ok
test test_foo ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Вы также можете запустить тесты, чьё имя соответствует шаблону:</p>
<pre><code class="language-shell">$ cargo test test_foo
</code></pre>
<pre><code class="language-shell">$ cargo test test_foo
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 2 tests
test test_foo ... ok
test test_foo_bar ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>Одно слово предостережения: Cargo может выполнять несколько тестов одновременно, поэтому убедитесь, что они не участвуют в гонках друг с другом. Например, если они все выводят в файл, вы должны заставить их записывать в разные файлы.</p>
<h1><a class="header" href="#Скрипты-сборки" id="Скрипты-сборки">Скрипты сборки</a></h1>
<p>Иногда обычной сборки, предоставляемой cargo, недостаточно. Возможно вашему крейту нужны некоторые предварительные условия, прежде чем он успешно скомпилируется, например кодогенерация или предварительно должен скомпилироваться какой-то нативный код. Для решения этой проблемы, мы имеем скрипты сборки, которые cargo может запустить.</p>
<p>Для добавления скрипта сборки в ваш пакет, вы можете указать его в <code>Cargo.toml</code> следующим образом:</p>
<pre><code class="language-toml">[package]
...
build = &quot;build.rs&quot;
</code></pre>
<p>Иначе по умолчанию cargo будет искать файл <code>build.rs</code> в директории проекта.</p>
<h2><a class="header" href="#Как-использовать-скрипт-сборки" id="Как-использовать-скрипт-сборки">Как использовать скрипт сборки</a></h2>
<p>Скрипт сборки - это просто другой файл на Rust, который будет скомпилирован и вызван до компиляции чего-либо другого в пакете. Следовательно он может быть использовать для выполнения предварительных условий вашего крейта.</p>
<p>Через переменные окружения cargo предоставляет скрипту входные параметры <a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">описанные здесь</a>, которые могут быть использованы.</p>
<p>Скрипт возвращает значения через stdout. Все напечатанные строки записываются в 
<code>target/debug/build/&lt;pkg&gt;/output</code>. Кроме того, строки с префиксом <code>cargo:</code> напрямую интерпретируются cargo и следовательно могут быть использованы для объявления параметров для компиляции пакета.</p>
<p>Больше информации и примеров можно найти в <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">спецификации cargo</a>.</p>
<h1><a class="header" href="#Атрибуты" id="Атрибуты">Атрибуты</a></h1>
<p>Атрибуты - это метаданные, применяемые к какому-либо модулю, контейнеру или их элементу.
Благодаря атрибутам можно:</p>
<!-- TODO: Link these to their respective examples -->
<ul>
<li><a href="attribute/cfg.html">задать условия компиляции кода</a></li>
<li><a href="attribute/crate.html">задать имя, версию и тип (библиотека или исполняемый файл) контейнера</a></li>
<li>отключить <a href="https://en.wikipedia.org/wiki/Lint_%28software%29">lints</a> (предупреждения)</li>
<li>включить возможности компилятора (макросы, глобальный импорт и другое.)</li>
<li>связаться с внешней библиотекой</li>
<li>пометить функции как юнит тесты</li>
<li>пометить функции, которые будут частью бенчмарка</li>
</ul>
<p>Когда атрибуты применяются ко всему контейнеру, их синтаксис будет <code>#![crate_attribute]</code>,
а когда они применяются к модулю или элементу модуля,
их синтаксис станет <code>#[item_attribute]</code> (обратите внимание на отсутствие <code>!</code>).</p>
<p>Атрибуты могут принимать аргументы с различным синтаксисом:</p>
<ul>
<li><code>#[attribute = &quot;value&quot;]</code></li>
<li><code>#[attribute(key = &quot;value&quot;)]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<p>Атрибуты могут иметь несколько значений и могут быть разделены несколькими строками:</p>
<pre><code class="language-rust ignore">#[attribute(value, value2)]


#[attribute(value, value2, value3,
            value4, value5)]
</code></pre>
<h1><a class="header" href="#dead_code" id="dead_code"><code>dead_code</code></a></h1>
<p>Компилятор предоставляет <a href="https://en.wikipedia.org/wiki/Lint_%28software%29"><em>проверку</em></a> <code>dead_code</code>,
которая предупреждает о неиспользованных функциях. Атрибут <em>dead_code</em> можно использовать, чтобы отключить данную проверку.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn used_function() {}

// `#[allow(dead_code)]` - атрибут, который убирает проверку на неиспользуемый код
#[allow(dead_code)]
fn unused_function() {}

fn noisy_unused_function() {}
// ИСПРАВЬТЕ ^ Добавьте атрибут `dead_code`, чтобы убрать предупреждение

fn main() {
    used_function();
}
</code></pre></pre>
<p>Обратите внимание, что в реальных программах, вы должны удалить неиспользуемый код.
В этих примерах мы разрешаем оставить неиспользуемый код в некоторых местах,
но, это только для примера!</p>
<h1><a class="header" href="#Контейнеры-1" id="Контейнеры-1">Контейнеры</a></h1>
<p>Атрибут <code>crate_type</code> используется, чтобы сказать компилятору,
какой контейнер является библиотекой (и каким типом библиотеки),
а какой исполняемым файлом. Атрибут <code>crate_name</code> используется для указания имени контейнера.</p>
<p>Однако важно отметить, что атрибуты <code>crate_type</code> и <code>create_name</code> <strong>не имеют значения</strong> при использовании пакетного менеджера Cargo.
В виду того, что Cargo используется для большинства проектов на Rust,
это значит в реальном мире использование <code>crate_type</code> и <code>crate_name</code>
достаточно ограничено.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Этот контейнер - библиотека
#![crate_type = &quot;lib&quot;]
// Эта библиотека называется &quot;rary&quot;
#![crate_name = &quot;rary&quot;]

pub fn public_function() {
    println!(&quot;вызвана `public_function()` библиотеки `rary`&quot;);
}

fn private_function() {
    println!(&quot;вызвана `private_function()` библиотеки `rary`&quot;);
}

pub fn indirect_access() {
    print!(&quot;вызвана `indirect_access()` библиотеки `rary`, и в ней\n&gt; &quot;);

    private_function();
}
</code></pre></pre>
<p>Если мы используем атрибут <code>crate_type</code>,
то нам больше нет необходимости передавать флаг <code>--crate-type</code> компилятору.</p>
<pre><code class="language-bash">$ rustc lib.rs
$ ls lib*
library.rlib
</code></pre>
<h1><a class="header" href="#cfg" id="cfg"><code>cfg</code></a></h1>
<p>Условная компиляция возможна благодаря двум операторам:</p>
<ul>
<li>Атрибуту <code>cfg</code>: <code>#[cfg(...)]</code>, который указывается на месте атрибута</li>
<li>Макросу <code>cfg!</code>: <code>cfg!(...)</code>, который можно использовать в условных выражениях</li>
</ul>
<p>Оба имеют идентичный синтаксис для принятия аргументов.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Эта функция будет скомпилирована только в том случае, если целевая ОС будет linux
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
    println!(&quot;Вы работаете в linux!&quot;);
}

// А эта функция будет скомпилирована, если целевая ОС *не* linux
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
    println!(&quot;Вы работаете *не* в linux!&quot;);
}

fn main() {
    are_you_on_linux();
    
    println!(&quot;Вы уверены?&quot;);
    if cfg!(target_os = &quot;linux&quot;) {
        println!(&quot;Да. Это точно linux!&quot;);
    } else {
        println!(&quot;Да. Это точно *не* linux!&quot;);
    }
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-30" id="Смотрите-также-30">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">the reference</a>, <a href="https://doc.rust-lang.org/std/macro.cfg!.html"><code>cfg!</code></a>, и <a href="attribute/macros.html">macros</a>.</p>
<h1><a class="header" href="#Собственные-условия" id="Собственные-условия">Собственные условия</a></h1>
<p>Некоторые условия, например, <code>target_os</code> предоставляются компилятором.
Если мы хотим создать собственные условия, 
то их необходимо передать компилятору используя флаг <code>--cfg</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">#[cfg(some_condition)]
fn conditional_function() {
    println!(&quot;condition met!&quot;);
}

fn main() {
    conditional_function();
}
</code></pre></pre>
<p>Попробуйте запустить без указания флага <code>cfg</code>.</p>
<p>С указанием флага <code>cfg</code>:</p>
<pre><code class="language-bash">$ rustc --cfg some_condition custom.rs &amp;&amp; ./custom
condition met!
</code></pre>
<h1><a class="header" href="#Обобщения" id="Обобщения">Обобщения</a></h1>
<p><em>Обобщения</em> позволяют обобщить типы и функциональность для более общих случаев. Они
чрезвычайно полезны благодаря уменьшению дублирования кода, однако могут привести к
сравнительному усложнению синтаксиса. А именно, использование обобщений требует особого
внимания при определении допустимых реальных типов которыми могут заменяться обобщённые.
Наиболее простым и распространённым применением обобщений является обобщение параметров
типа.</p>
<p>Обобщить параметр типа можно используя угловые скобки и верхний <a href="https://en.wikipedia.org/wiki/CamelCase">верблюжий регистр</a>:
<code>&lt;Aaa, Bbb, ...&gt;</code>. &quot;Обобщённые параметры типа&quot; обычно представлены как <code>&lt;T&gt;</code>. В Rust,
&quot;обобщённым&quot; также принято называть все, что может принимать один или более обобщённых
параметров типа <code>&lt;T&gt;</code>. Любой тип, указанный в качестве параметра обобщённого типа,
является обобщённым, а всё остальное является конкретным (не обобщённым).</p>
<p>Например, объявление <em>обобщённой функции</em> <code>foo</code> принимающей аргумент <code>T</code> любого типа:</p>
<pre><code class="language-rust ignore">fn foo&lt;T&gt;(arg: T) { ... }
</code></pre>
<p>Поскольку <code>T</code> был объявлен как обобщённый тип, посредством <code>&lt;T&gt;</code>, он считается обобщённым
когда используется как <code>(arg: T)</code>. Это работает даже если <code>T</code> был определён как <code>структура</code>.</p>
<p>Пример ниже демонстрирует синтаксис в действии:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Конкретный тип `A`.
struct A;

// В определении типа `Single` первому использованию `A` не предшествует `&lt;A&gt;`.
// Поэтому `Single` имеет конкретный тип, и `A` определена выше.
struct Single(A);
//            ^ Здесь `A` в первый раз используется в `Single`.

// В данном примере, `&lt;T&gt;` предшествует первому использованию `T`,
// поэтому `SingleGen` является обобщённым типом.
// Поскольку тип параметра `T` является обобщённым, он может быть чем угодно, включая
// конкретный тип `A`, определённый выше.
struct SingleGen&lt;T&gt;(T);

fn main() {
    // `Single` имеет конкретный тип и явно принимает параметр `A`.
    let _s = Single(A);

    // Создаём переменную `_char` типа `SingleGen&lt;char&gt;`
    // и присваиваем ей значение `SingleGen('a')`.
    // В примере ниже, тип параметра `SingleGen` явно определён.
    let _char: SingleGen&lt;char&gt; = SingleGen('a');

    // Здесь, `SingleGen` также может иметь неявно определённый параметр типа:
    let _t    = SingleGen(A); // Используется структура `A`, объявленная выше.
    let _i32  = SingleGen(6); // Используется `i32`.
    let _char = SingleGen('a'); // Используется `char`.
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-31" id="Смотрите-также-31">Смотрите также:</a></h3>
<p><a href="custom_types/structs.html"><code>Структуры</code> </a></p>
<h1><a class="header" href="#Функции-1" id="Функции-1">Функции</a></h1>
<p>Тот же набор правил применяется и к функциям: тип <code>T</code> становится
обобщённым, когда предшествует <code>&lt;T&gt;</code>.</p>
<p>При использовании обобщённых функций, иногда требуется явно указывать тип
данных параметров. Это может быть необходимо в случае, если вызываемая функция возвращает
обобщённый тип или у компилятора недостаточно информации для вывода необходимого
типа данных.</p>
<p>Вызов функции с явно указанными типами данных параметров выглядит так:
<code>fun::&lt;A, B, ...&gt;()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct A; // Конкретный тип `A`.
struct S(A); // Конкретный тип `S`.
struct SGen&lt;T&gt;(T); // Обобщённый тип `SGen`.

// Все следующие функции становятся владельцем переменной, переданной в них.
// После передачи, она сразу выходит из области видимости и освобождается.

// Объявляем функцию `reg_fn`, которая принимает аргумент `_s` типа `S`.
// Здесь отсутствует `&lt;T&gt;`, поэтому это не обобщённая функция.
fn reg_fn(_s: S) {}

// Объявляем функцию `gen_spec_t`, которая принимает аргумент `_s` типа `SGen&lt;T&gt;`.
// В ней явно задан параметр типа `A`, но поскольку `A` не был указан
// как параметр обобщённого типа для `gen_spec_t`, то он не является обобщённым.
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// Объявляем функцию `gen_spec_i32`, которая принимает аргумент `_s` типа `SGen&lt;i32&gt;`.
// В ней явно задан тип `i32`, который является определённым типом.
// Поскольку `i32` не является обобщённым типом, эта функция
// также не является обобщённой.
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// Объявляем функцию `generic`, которая принимает аргумент `_s` типа `SGen&lt;T&gt;`.
// Поскольку `SGen&lt;T&gt;` предшествует `&lt;T&gt;`, эта функция
// является обобщённой над `T`.
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // Используем не обобщённые функции.
    reg_fn(S(A)); // Конкретный тип.
    gen_spec_t(SGen(A)); // Неявно определён тип параметра `A`.
    gen_spec_i32(SGen(6)); // Неявно определён тип параметра `i32`.

    // Явно определён тип параметра `char` в `generic()`.
    generic::&lt;char&gt;(SGen('a'));

    // Неявно определён параметр типа `char` в `generic()`.
    generic(SGen('c'));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-32" id="Смотрите-также-32">Смотрите также:</a></h3>
<p><a href="generics/fn.html">Функции</a> и <a href="generics/custom_types/structs.html">структуры</a></p>
<h1><a class="header" href="#Реализация" id="Реализация">Реализация</a></h1>
<p>Подобно функциям, реализации требуют выполнения некоторых условий, чтобы оставаться обобщёнными.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct S; // Конкретный тип `S`
struct GenericVal&lt;T&gt;(T); // Обобщенный тип `GenericVal`

// Реализация GenericVal, где мы явно указываем типы данных параметров:
impl GenericVal&lt;f32&gt; {} // Указываем тип `f32`
impl GenericVal&lt;S&gt; {} // Указываем тип `S`, который мы определили выше

// `&lt;T&gt;` должен указываться перед типом, чтобы оставаться обобщённым
impl&lt;T&gt; GenericVal&lt;T&gt; {}
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">struct Val {
    val: f64,
}

struct GenVal&lt;T&gt; {
    gen_val: T,
}

// Реализация Val
impl Val {
    fn value(&amp;self) -&gt; &amp;f64 {
        &amp;self.val
    }
}

// Реализация GenVal для обобщённого типа `T`
impl&lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T {
        &amp;self.gen_val
    }
}

fn main() {
    let x = Val { val: 3.0 };
    let y = GenVal { gen_val: 3i32 };

    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-33" id="Смотрите-также-33">Смотрите также:</a></h3>
<p><a href="generics/../scope/lifetime/fn.html">Функции, возвращающие ссылки</a>, <a href="generics/../fn/methods.html"><code>impl</code></a> и <a href="generics/../custom_types/structs.html"><code>struct</code></a></p>
<h1><a class="header" href="#Типажи" id="Типажи">Типажи</a></h1>
<p>Конечно <code>типажи</code> тоже могут быть обобщёнными. Здесь мы определяем, тот
который повторно реализует <code>типаж</code> <code>Drop</code> как обобщённый метод, чтобы
удалить себя и входные данные.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Некопируемые типы.
struct Empty;
struct Null;

// Обобщённый типаж от `T`.
trait DoubleDrop&lt;T&gt; {
    // Определим метод для типа вызывающего объекта,
    // который принимает один дополнительный параметр `T` и ничего с ним не делает.
    fn double_drop(self, _: T);
}

// Реализация `DoubleDrop&lt;T&gt;` для любого общего параметра `T` и
// вызывающего объекта `U`.
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // Этот метод получает право владения на оба переданных аргумента и
    // освобождает их.
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // Освободить `empty` и `null`.
    empty.double_drop(null);

    //empty;
    //null;
    // ^ TODO: Попробуйте раскомментировать эти строки.
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-34" id="Смотрите-также-34">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>, <a href="generics/../custom_types/structs.html"><code>struct</code></a> и <a href="generics/../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#Ограничения" id="Ограничения">Ограничения</a></h1>
<p>При работе с обобщениями параметры типа часто должны использовать типажи
в качестве <em>ограничений</em>, чтобы определить какие функциональные возможности
реализует тип. Например, в следующем примере для печати используется
типаж <code>Display</code> и поэтому требуется <code>T</code> ограничить по <code>Display</code>.
Это значит что <code>T</code> <em>должен</em> реализовать <code>Display</code>.</p>
<pre><code class="language-rust ignore">// Определим функцию `printer`, которая принимает обобщённый тип `T`,
// который должен реализовать типаж `Display`
fn printer&lt;T: Display&gt;(t: T) {
    println!(&quot;{}&quot;, t);
}
</code></pre>
<p>Ограничение сужает список типов, допустимых к использованию. То есть:</p>
<pre><code class="language-rust ignore">struct S&lt;T: Display&gt;(T);

// Ошибка! `Vec&lt;T&gt;` не реализует `Display`. Эта
// специализация не удастся
let s = S(vec![1]);
</code></pre>
<p>Другой эффект ограничения заключается в том, что обобщённые экземпляры
имеют доступ к <a href="generics/fn/methods.html"><code>методам</code></a> типажей, указанных в ограничениях. Например:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Типаж, который реализует маркер печати: `{:?}`.
use std::fmt::Debug;

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Rectangle {
    fn area(&amp;self) -&gt; f64 { self.length * self.height }
}

#[derive(Debug)]
struct Rectangle { length: f64, height: f64 }
#[allow(dead_code)]
struct Triangle  { length: f64, height: f64 }

// Обобщённый тип `T` должен реализовать `Debug`. Независимо
// от типа, это будет работать правильно.
fn print_debug&lt;T: Debug&gt;(t: &amp;T) {
    println!(&quot;{:?}&quot;, t);
}

// `T` должен реализовать `HasArea`. Любая функция, которая удовлетворяет
// ограничению может получить доступ к функции `area` из `HasArea`.
fn area&lt;T: HasArea&gt;(t: &amp;T) -&gt; f64 { t.area() }

fn main() {
    let rectangle = Rectangle { length: 3.0, height: 4.0 };
    let _triangle = Triangle  { length: 3.0, height: 4.0 };

    print_debug(&amp;rectangle);
    println!(&quot;Area: {}&quot;, area(&amp;rectangle));

    //print_debug(&amp;_triangle);
    //println!(&quot;Area: {}&quot;, area(&amp;_triangle));
    // ^ TODO: Попробуйте раскомментировать эти строки.
    // | Ошибка: Не реализован `Debug` или `HasArea`.
}
</code></pre></pre>
<p>Утверждения <a href="generics/generics/where.html"><code>where</code></a> также могут использоваться для применения
ограничений в некоторых случаях, чтобы добавить выразительности.</p>
<h3><a class="header" href="#Смотрите-также-35" id="Смотрите-также-35">Смотрите также:</a></h3>
<p><a href="generics/../hello/print.html"><code>std::fmt</code></a><a href="generics/../hello/print.html">, </a><a href="generics/../custom_types/structs.html"><code>struct</code></a> и <a href="generics/../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#Пример-пустые-ограничения" id="Пример-пустые-ограничения">Пример: пустые ограничения</a></h1>
<p>Следствием того, как работают ограничения по типажу, является то,
что даже если <code>типаж</code> не включает в себя какие-либо функциональные
возможности, вы все равно можете использовать его в качестве ограничения.
Примерами таких типажей являются <code>Eq</code> и <code>Ord</code> из стандартной библиотеки.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// Эти функции действительны только для типов реализующих эти типажи.
// То, что типажи пусты, не имеет значения.
fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { &quot;красная&quot; }
fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { &quot;синяя&quot; }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;

    // `red()` не будет работать для blue_jay, ни наоборот,
    // из-за ограничений по типажу.
    println!(&quot;Кардинал {} птица&quot;, red(&amp;cardinal));
    println!(&quot;Голубая сойка {} птица&quot;, blue(&amp;blue_jay));
    //println!(&quot;Индюк {} птица&quot;, red(&amp;_turkey));
    // ^ TODO: Попробуйте раскомментировать эту строку.
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-36" id="Смотрите-также-36">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>std::cmp::Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>std::cmp::Ord</code></a> и <a href="generics/bounds/../../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#Множественные-ограничения" id="Множественные-ограничения">Множественные ограничения</a></h1>
<p>Множественные ограничения по типажу могут быть применены с помощью <code>+</code>.
Разные типы разделяются с помощью <code>,</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::{Debug, Display};

fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T) {
    println!(&quot;Debug: `{:?}`&quot;, t);
    println!(&quot;Display: `{}`&quot;, t);
}

fn compare_types&lt;T: Debug, U: Debug&gt;(t: &amp;T, u: &amp;U) {
    println!(&quot;t: `{:?}&quot;, t);
    println!(&quot;u: `{:?}&quot;, u);
}

fn main() {
    let string = &quot;words&quot;;
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&amp;string);
    //compare_prints(&amp;array);
    // ЗАДАНИЕ ^ Попробуйте удалить комментарий.

    compare_types(&amp;array, &amp;vec);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-37" id="Смотрите-также-37">Смотрите также:</a></h3>
<p><a href="generics/../hello/print.html"><code>std::fmt</code></a> и <a href="generics/../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#Утверждения-where" id="Утверждения-where">Утверждения where</a></h1>
<p>Ограничение типажа также может быть выражено с помощью утверждения <code>where</code>
непосредственно перед открытием <code>{</code>, а не при первом упоминании типа.
Кроме того, утверждения <code>where</code> могут применять ограничения типажей к 
произвольным типам, а не только к параметрам типа.</p>
<p>В некоторых случаях утверждение <code>where</code> является полезным:</p>
<ul>
<li>При указании обобщённых типов и ограничений типажей отдельно,
код становится более ясным:</li>
</ul>
<pre><code class="language-rust ignore">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// Выражение ограничений типажей через утверждение `where`
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
</code></pre>
<ul>
<li>Использование утверждения <code>where</code> более выразительно, чем использование
обычного синтаксиса. В этом примере <code>impl</code> не может быть непосредственно
выражен без утверждения <code>where</code>:</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// Потому что в противном случае мы должны были бы выразить это как
// `T: Debug` или использовать другой метод косвенного подхода,
// для этого требуется утверждение `where`:
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // Мы хотим использовать `Option&lt;T&gt;: Debug` как наше ограничение
    // типажа, потому то это то, что будет напечатано. В противном случае
    // использовалось бы неправильное ограничение типажа.
    fn print_in_option(self) {
        println!(&quot;{:?}&quot;, Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-38" id="Смотрите-также-38">Смотрите также:</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">RFC</a>, <a href="generics/custom_types/structs.html"><code>структуры</code></a>, и <a href="generics/trait.html"><code>типажи</code></a></p>
<h1><a class="header" href="#new-type-идиома" id="new-type-идиома">New Type идиома</a></h1>
<p>Идиома <code>newtype</code> гарантирует во время компиляции, 
что программе передаётся значение правильного типа.</p>
<p>Например, функция верификации возраста, которая проверяет 
возраст в годах <em>должна</em> получать значение типа 
<code>Years</code>.</p>
<pre><pre class="playpen"><code class="language-rust ">struct Years(i64);

struct Days(i64);

impl Years {
    pub fn to_days(&amp;self) -&gt; Days {
        Days(self.0 * 365)
    }
}


impl Days {
    /// truncates partial years
    pub fn to_years(&amp;self) -&gt; Years {
        Years(self.0 / 365)
    }
}

fn old_enough(age: &amp;Years) -&gt; bool {
    age.0 &gt;= 18
}

fn main() {
    let age = Years(5);
    let age_days = age.to_days();
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age));
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days.to_years()));
    // println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days));
}
</code></pre></pre>
<p>Удалите комментарий с последнего <code>println</code>, чтобы увидеть, что тип 
должен быть <code>Years</code>.</p>
<p>Чтобы получить из <code>newtype</code>-переменной значение 
базового типа, вы можете использовать кортежный синтаксис, 
как в примере:</p>
<pre><pre class="playpen"><code class="language-rust ">struct Years(i64);

fn main() {
    let years = Years(42);
    let years_as_primitive: i64 = years.0;
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-39" id="Смотрите-также-39">Смотрите также:</a></h3>
<p><a href="generics/../custom_types/structs.html"><code>struct</code></a></p>
<h1><a class="header" href="#Ассоциированные-элементы" id="Ассоциированные-элементы">Ассоциированные элементы</a></h1>
<p>&quot;Ассоциированные элементы&quot; относятся к набору правил, 
касающихся элементов различных типов. Это расширение для 
обобщённых типажей, которое позволяет им определить новый 
элемент внутри себя.</p>
<p>Каждый такой элемент называется <em>ассоциированным типом</em>
и предоставляет упрощённый шаблон использования, когда 
<code>trait</code> является обобщённым для своего контейнера.</p>
<h3><a class="header" href="#Смотрите-также-40" id="Смотрите-также-40">Смотрите также:</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md">RFC</a></p>
<h1><a class="header" href="#Проблема" id="Проблема">Проблема</a></h1>
<p><code>trait</code>, являющийся обобщённым для своего контейнера, есть требование к спецификации типа - пользователи <code>trait</code> <em>должны</em> специфицировать все обобщённые типы.</p>
<p>В примере ниже, <code>trait</code> <code>Contains</code> позволяет 
использовать обобщённые типы <code>A</code> и <code>B</code>.
Затем этот типаж реализуется для типа <code>Container</code>, в 
котором <code>A</code> и <code>B</code> специфицированы, как 
<code>i32</code>, чтобы их можно было использовать в функции 
<code>fn difference()</code>.</p>
<p>Потому что <code>Contains</code> имеет обобщение, мы должны 
явно указать <em>все</em> обобщённые типы для 
<code>fn difference()</code>. На практике, мы хотим выразить 
<code>A</code> и <code>B</code> через <em>входной 
параметр</em> <code>C</code>. Как вы можете увидеть в следующем 
разделе, ассоциированные типы предоставляют именно эту 
возможность.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Container(i32, i32);

// Типаж, который проверяет, сохранены ли 2 элемента в контейнере.
// Также он может вернуть первое или последнее значение.
trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool; // Явно требует `A` и `B`.
    fn first(&amp;self) -&gt; i32; // Не требует явного `A` или `B`.
    fn last(&amp;self) -&gt; i32;  // Не требует явного `A` или `B`.
}

impl Contains&lt;i32, i32&gt; for Container {
    // Истина, если сохранённые цифры равны.
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // Берём первую цифру.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Берём последнюю цифру.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

// `C` содержит `A` и `B`. В свете этого, необходимость снова явно указывать `A` и
// `B` огорчает.
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Содержатся ли в контейнере {} и {}? {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;Первое число: {}&quot;, container.first());
    println!(&quot;Последнее число: {}&quot;, container.last());

    println!(&quot;Разница: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-41" id="Смотрите-также-41">Смотрите также:</a></h3>
<p><a href="generics/assoc_items/../../custom_types/structs.html"><code>struct</code></a> и <a href="generics/assoc_items/../../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#Ассоциированные-типы" id="Ассоциированные-типы">Ассоциированные типы</a></h1>
<p>Использование &quot;ассоциированных типов&quot; улучшает общую 
читаемость кода через локальное перемещение внутренних типов в 
типаж в качестве <em>выходных</em> типов. Синтаксис для 
объявления <code>trait</code> будет следующим:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// `A` и `B` определены в типаже при помощи ключевого слова `type`.
// (Обратите внимание: в данном контексте `type` отличается `type`, который
// используется в псевдонимах).
trait Contains {
    type A;
    type B;

    // Обновлённый синтаксис для обращения к этим двум ассоциированным типам.
    fn contains(&amp;self, &amp;Self::A, &amp;Self::B) -&gt; bool;
}
#}</code></pre></pre>
<p>Обратите внимание, что функции, использующие <code>trait</code> <code>Contains</code> больше не требуют указания <code>A</code> или <code>B</code>:</p>
<pre><code class="language-rust ignore">// Без использования ассоциированных типов
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; { ... }

// С использованием ассоциированных типов
fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }
</code></pre>
<p>Давайте перепишем пример их предыдущего раздела с использованием ассоциированных типов:</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Container(i32, i32);

// Типаж, который проверяет, сохранены ли 2 элемента в контейнере.
// Также он может вернуть первое или последнее значение.
trait Contains {
    // Объявляем общие типы, которые будут использовать методы.
    type A;
    type B;

    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains for Container {
    // Определяем, какими будут типы `A` и `B`. Если `входящий` тип
    // `Container(i32, i32)`, тогда `выходящие` типы определяются, как
    // `i32` и `i32`.
    type A = i32;
    type B = i32;

    // `&amp;Self::A` и `&amp;Self::B` также будут здесь уместны.
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }
    // Берём первую цифру.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Берём последнюю цифру.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Содержатся ли в контейнере {} и {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;Первое число: {}&quot;, container.first());
    println!(&quot;Последнее число: {}&quot;, container.last());

    println!(&quot;Разница: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h1><a class="header" href="#phantomdata-параметры" id="phantomdata-параметры">PhantomData-параметры</a></h1>
<p>Параметры фантомного типа - единственное, что не отображается во 
время выполнения, но проверяется статически (и только статически) 
во время компиляции.</p>
<p>Типы данных могут использовать дополнительные обобщённые типы 
в качестве параметров-маркеров или для выполнения проверки 
типов во время компиляции. Эти дополнительные параметры не 
сохраняют значения и не имеют поведения во время выполнения.</p>
<p>В следующем примере мы совместили <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">std::marker::PhantomData</a> и концепцию параметров фантомных типов для создания кортежей разных типов.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::marker::PhantomData;

// Фантомная кортежная структура, которая имеет обобщение `A` со скрытым параметром `B`.
#[derive(PartialEq)] // Разрешаем для данного типа сравнения.
struct PhantomTuple&lt;A, B&gt;(A,PhantomData&lt;B&gt;);

// Фантомная структура, которая имеет обобщение `A` со скрытым параметром `B`.
#[derive(PartialEq)] // Разрешаем для данного типа сравнения.
struct PhantomStruct&lt;A, B&gt; { first: A, phantom: PhantomData&lt;B&gt; }

// Заметьте: память выделена для обобщённого типа `A`, но не для `B`.
//           Следовательно, `B` не может быть использована в вычислениях.

fn main() {
    // Здесь `f32` и `f64` - скрытые параметры.
    // Тип PhantomTuple объявлен с `&lt;char, f32&gt;`.
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);
    // Тип PhantomTuple объявлен с `&lt;char, f64&gt;`.
    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    // Тип определён как `&lt;char, f32&gt;`.
    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    // Тип определён как `&lt;char, f64&gt;`.
    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    
    // Ошибка времени компиляции! Типы не совпадают, так что сравнение не может быть произведено:
    //println!(&quot;_tuple1 == _tuple2 даёт в результате: {}&quot;,
    //          _tuple1 == _tuple2);
    
    // Ошибка времени компиляции! Типы не совпадают, так что сравнение не может быть произведено:
    //println!(&quot;_struct1 == _struct2 даёт в результате: {}&quot;,
    //          _struct1 == _struct2);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-42" id="Смотрите-также-42">Смотрите также:</a></h3>
<p><a href="generics/../trait/derive.html"><code>derive</code></a>, <a href="generics/../custom_types/structs.html"><code>struct</code></a> и <a href="generics/../custom_types/structs.html">кортежные структуры</a></p>
<h1><a class="header" href="#Пример-unit-clarification" id="Пример-unit-clarification">Пример: unit clarification</a></h1>
<p>Полезный метод преобразования единиц измерения может быть 
получен путём реализации типажа <code>Add</code> с 
параметром фантомного типа. 
<code>trait``Add</code> рассмотрен ниже:</p>
<pre><code class="language-rust ignore">// Эта конструкция будет навязывать: `Self + RHS = Output`
// где RHS по умолчанию Self, если иное не указано в реализации.
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}

// `Output` должен быть `T&lt;U&gt;` так что `T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`.
impl&lt;U&gt; Add for T&lt;U&gt; {
    type Output = T&lt;U&gt;;
    ...
}
</code></pre>
<p>Вся реализация:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops::Add;
use std::marker::PhantomData;

/// Создаём пустые перечисления для определения типов единиц измерения.
#[derive(Debug, Clone, Copy)]
enum Inch {}
#[derive(Debug, Clone, Copy)]
enum Mm {}

/// `Length` - тип с параметром фантомного типа `Unit`,
/// и не обобщён для типа длины (который `f64`).
///
/// Для `f64` уже реализованы типажи `Clone` и `Copy`.
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);

/// Типаж `Add` объявляет поведение оператора `+`.
impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
     type Output = Length&lt;Unit&gt;;

    // add() возвращает новую структуру `Length`, содержащую сумму.
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // `+` вызывает реализацию `Add` для `f64`.
        Length(self.0 + rhs.0, PhantomData)
    }
}

fn main() {
    // Объявим, что `one_foot` имеет парамет фантомного типа `Inch`.
    let one_foot:  Length&lt;Inch&gt; = Length(12.0, PhantomData);
    // `one_meter` имеет параметр фантомного типа `Mm`.
    let one_meter: Length&lt;Mm&gt;   = Length(1000.0, PhantomData);

    // `+` вызывает метод `add()`, который мы реализовали для `Length&lt;Unit&gt;`.
    //
    // Так как `Length` реализует `Copy`, `add()` не поглощает
    // `one_foot` и `one_meter`, а копирует их в `self` и `rhs`.
    let two_feet = one_foot + one_foot;
    let two_meters = one_meter + one_meter;

    // Сложение работает.
    println!(&quot;один фут + один фут = {:?} фута&quot;, two_feet.0);
    println!(&quot;один метр + один метр = {:?} метра&quot;, two_meters.0);

    // Бессмысленные операции потерпят неудачу, как и должно быть:
    // Ошибка времени компиляции: несоответствие типов.
    //let one_feter = one_foot + one_meter;
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-43" id="Смотрите-также-43">Смотрите также:</a></h3>
<p><a href="generics/phantom/../../scope/borrow.html">Заимствование (<code>&amp;</code>)</a>, <a href="generics/phantom/../../generics/bounds.html">ограничения (<code>X: Y</code>)</a>, <a href="generics/phantom/../../custom_types/enum.html">перечисления</a>, <a href="generics/phantom/../../fn/methods.html"><code>impl &amp; self</code></a>,
<a href="generics/phantom/../../trait/ops.html">перегрузка</a>, <a href="generics/phantom/../../scope/borrow/ref.html"><code>ref</code></a>, <a href="generics/phantom/../../trait.html">типажи (<code>X for Y</code>)</a> и <a href="generics/phantom/../../custom_types/structs.html">кортежные структуры</a>.</p>
<h1><a class="header" href="#Правила-области-видимости" id="Правила-области-видимости">Правила области видимости</a></h1>
<p>Области видимости играют важную роль во владении, заимствовании
и времени жизни. То есть, они указывают компилятору, когда
заимствования действительны, когда ресурсы могут быть освобождены,
и когда переменные создаются или уничтожаются.</p>
<h1><a class="header" href="#raii" id="raii">RAII</a></h1>
<p>Переменные в Rust не только держат данные в стеке, они также могут <em>владеть</em>
ресурсами; к примеру, <code>Box&lt;T&gt;</code> владеет памятью в куче. Поскольку Rust строго
придерживается идиоме <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>, то когда объект выходит за зону видимости, вызывается
его деструктор, а ресурс, которым он <em>владеет</em> освобождается.</p>
<p>Такое поведение защищает от багов, связанных с <em>утечкой ресурсов.</em>
Вам больше никогда не потребуется вручную освобождать память или же беспокоиться
об её утечках! Небольшой пример:</p>
<pre><pre class="playpen"><code class="language-rust editable">// raii.rs
fn create_box() {
    // Выделить память для целого число в куче
    let _box1 = Box::new(3i32);

    // `_box1` здесь уничтожается, а память освобождается
}

fn main() {
    // Выделить память для целого числа в куче
    let _box2 = Box::new(5i32);

    // Вложенная область видимости:
    {
        // Выделить память для ещё одного целого числа в куче
        let _box3 = Box::new(4i32);

        // `_box3` здесь уничтожается, а память освобождается
    }

    // Создаём большое количество упаковок. Просто потому что можем.
    // Здесь нет необходимости освобождать память вручную!
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2` здесь уничтожается, а память освобождается
}
</code></pre></pre>
<p>Конечно, мы можем убедиться, что в нашей программе нет ошибок с памятью,
используя <a href="http://valgrind.org/info/"><code>valgrind</code></a>:</p>
<pre><code class="language-bash">$ rustc raii.rs &amp;&amp; valgrind ./raii
==26873== Memcheck, a memory error detector
==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==26873== Command: ./raii
==26873==
==26873==
==26873== HEAP SUMMARY:
==26873==     in use at exit: 0 bytes in 0 blocks
==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated
==26873==
==26873== All heap blocks were freed -- no leaks are possible
==26873==
==26873== For counts of detected and suppressed errors, rerun with: -v
==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</code></pre>
<p>Утечки отсутствуют!</p>
<h2><a class="header" href="#Деструктор" id="Деструктор">Деструктор</a></h2>
<p>Понятие деструктора в Rust обеспечивается через типаж <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>.
Деструктор вызывается, когда ресурс выходит за пределы области видимости.
Этот типаж не требуется реализовать для каждого типа.
Реализовать его для вашего типа вам потребуется, только если
требуется своя логика при удалении экземпляра типа.</p>
<p>Выполните пример ниже, чтобы увидеть, как работает типаж <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>. Когда переменная в функции <code>main</code> выходит за пределы области действия,
будет вызван пользовательский деструктор.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct ToDrop;

impl Drop for ToDrop {
    fn drop(&amp;mut self) {
        println!(&quot;ToDrop is being dropped&quot;);
    }
}

fn main() {
    let x = ToDrop;
    println!(&quot;Made a ToDrop!&quot;);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-44" id="Смотрите-также-44">Смотрите также:</a></h3>
<p><a href="scope/../std/box.html">Упаковка</a></p>
<h1><a class="header" href="#Владение-и-перемещение" id="Владение-и-перемещение">Владение и перемещение</a></h1>
<p>Поскольку переменные ответственны за освобождение своих ресурсов,
<strong>ресурсы могут иметь лишь одного владельца</strong>.  Это ограничение предотвращает
возможность высвобождения ресурсов более одно раза. Обратите внимание,
что не все переменные владеют своим ресурсом (например, <a href="scope/flow_control/match/destructuring/destructure_pointers.html">ссылки</a>).</p>
<p>При присваивании (<code>let x = y</code>) или при передаче функции аргумента по значению (<code>foo(x)</code>),
<em>владение</em> ресурсами передаётся. В языке Rust это называется <em>перемещением.</em></p>
<p>После перемещения ресурсов, переменная, владевшая ресурсами ранее, не может быть
использована. Это предотвращает создание висячих указателей.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Эта функция берёт во владение память, выделенную в куче
fn destroy_box(c: Box&lt;i32&gt;) {
    println!(&quot;Уничтожаем упаковку, в которой хранится {}&quot;, c);

    // `c` уничтожится, а память будет освобождена
}

fn main() {
    // Целое число выделенное в стеке
    let x = 5u32;

    // *Копируем* `x` в `y`. В данном случае нет ресурсов для перемещения
    let y = x;

    // Оба значения можно использовать независимо
    println!(&quot;x равен {}, а y равен {}&quot;, x, y);

    // `a` - указатель на целое число, выделенное в куче
    let a = Box::new(5i32);

    println!(&quot;a содержит: {}&quot;, a);

    // *Перемещаем* `a` в `b`
    let b = a;
    // Адрес указателя `a` копируется (но не данные) в `b`.
    // Оба указателя указывают на одни и те же данные в куче, но
    // `b` теперь владеет ими.

    // Ошибка! `a` больше не может получить доступ к данным, потому что
    // больше не владеет данными в куче.
    //println!(&quot;a содержит: {}&quot;, a);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Эта функция берет во владение память, выделенную в куче, которой ранее владела `b`
    destroy_box(b);

    // Поскольку в данный момент память в куче уже освобождена, это действие
    // приведёт к разыменованию освобождённой памяти, но это запрещено компилятором
    // Ошибка! Причина та же, что и в прошлый раз
    //println!(&quot;b содержит: {}&quot;, b);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку
}
</code></pre></pre>
<h1><a class="header" href="#Изменяемость-1" id="Изменяемость-1">Изменяемость</a></h1>
<p>Изменяемость данных может быть изменена при передаче владения.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let immutable_box = Box::new(5u32);

    println!(&quot;immutable_box содержит в себе {}&quot;, immutable_box);

    // Ошибка изменяемости
    //*immutable_box = 4;

    // *Переместить* упаковку, изменив её владение (и изменяемость)
    let mut mutable_box = immutable_box;

    println!(&quot;mutable_box содержит в себе {}&quot;, mutable_box);

    // Изменяем данные внутри упаковки
    *mutable_box = 4;

    println!(&quot;mutable_box now содержит в себе {}&quot;, mutable_box);
}
</code></pre></pre>
<h1><a class="header" href="#Заимствование" id="Заимствование">Заимствование</a></h1>
<p>Большую часть времени мы хотим обращаться к данным без получения владения над
ними. Для этого Rust предоставляет механизм <em>заимствования</em> Вместо передачи
объектов по значению (<code>T</code>), объекты могут быть переданы по ссылке (<code>&amp;T</code>).</p>
<p>Компилятор статически гарантирует, что ссылки <em>всегда</em> указывают на допустимые
объекты посредством проверки заимствований. К примеру, исходный объект не может
быть уничтожен, пока существуют ссылки на него.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Эта функция берёт во владение упаковку и уничтожает её
fn eat_box_i32(boxed_i32: Box&lt;i32&gt;) {
    println!(&quot;Уничтожаем упаковку в которой хранится {}&quot;, boxed_i32);
}

// Эта функция заимствует i32
fn borrow_i32(borrowed_i32: &amp;i32) {
    println!(&quot;Это число равно: {}&quot;, borrowed_i32);
}

fn main() {
    // Создаём упакованное i32, и i32 на стеке
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // Заимствуем содержимое упаковки. При этом мы не владеем ресурсом.
    // Содержимое может быть заимствовано снова.
    borrow_i32(&amp;boxed_i32);
    borrow_i32(&amp;stacked_i32);

    {
        // Получаем ссылку на данные, которые хранятся внутри упаковки
        let _ref_to_i32: &amp;i32 = &amp;boxed_i32;

        // Ошибка!
        // Нельзя уничтожать упаковку `boxed_i32` пока данные внутри заимствованы.
        eat_box_i32(boxed_i32);
        // ИСПРАВЬТЕ ^ Закомментируйте эту строку

        // `_ref_to_i32` покидает область видимости и больше не является заимствованным ресурсом.
    }

    // `boxed_i32` теперь может получить владение над `eat_box` и быть уничтожено
    eat_box_i32(boxed_i32);
}
</code></pre></pre>
<h1><a class="header" href="#Изменяемость-2" id="Изменяемость-2">Изменяемость</a></h1>
<p>Изменяемые данные могут быть заимствованы с возможностью 
изменения при помощи <code>&amp;mut T</code>. Это называется 
<em>изменяемая ссылка</em> и даёт заимствующему 
возможность чтения и записи. В отличие от неё, 
<code>&amp;T</code> заимствует данные через неизменяемую 
ссылку и заимствующий может читать данные, но не может 
модифицировать их:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&amp;'static str` - это ссылка на строку, расположенную в неизменяемой памяти
    author: &amp;'static str,
    title: &amp;'static str,
    year: u32,
}

// Эта функция получает ссылку на книгу
fn borrow_book(book: &amp;Book) {
    println!(&quot;Я неизменяемо заимствовала {} - {} издания&quot;, book.title, book.year);
}

// Эта функция получает изменяемую ссылку на книгу и устанавливает поле `year` в 2014
fn new_edition(book: &amp;mut Book) {
    book.year = 2014;
    println!(&quot;Я изменяемо заимствовала {} - {} издания&quot;, book.title, book.year);
}

fn main() {
    // Создаём неизменяемую книгу в переменной `immutabook`
    let immutabook = Book {
        // строковый литерал имеет тип `&amp;'static str`
        author: &quot;Douglas Hofstadter&quot;,
        title: &quot;Gödel, Escher, Bach&quot;,
        year: 1979,
    };

    // Создаём изменяемую копию `immutabook` и называем её `mutabook`
    let mut mutabook = immutabook;
    
    // Неизменяемое заимствование неизменяемого объекта
    borrow_book(&amp;immutabook);

    // Неизменяемое заимствование изменяемого объекта
    borrow_book(&amp;mutabook);
    
    // Заимствование изеняемого объекта как изменяемого
    new_edition(&amp;mut mutabook);
    
    // Ошибка! Нельзя заимствовать неизменяемый объект как изменяемый
    new_edition(&amp;mut immutabook);
    // ИСПРАВЬТЕ ^ Добавьте комментарий для этой строки
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-45" id="Смотрите-также-45">Смотрите также:</a></h3>
<p><a href="scope/borrow/../lifetime/static_lifetime.html"><code>static</code></a></p>
<h1><a class="header" href="#Замораживание" id="Замораживание">Замораживание</a></h1>
<p>Когда данные заимствуются, они заодно и <em>замораживаются</em>. <em>Замороженные</em> данные
не могут быть изменены до тех пор, пока все ссылки не выйдут за область видимости:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let mut _mutable_integer = 7i32;

    {
        // Заимствуем `_mutable_integer`
        let large_integer = &amp;_mutable_integer;

        // Ошибка! `_mutable_integer` заморожена в этой области видимости
        _mutable_integer = 50;
        // ИСПРАВЬТЕ ^ Закомментируйте эту строку

        println!(&quot;Неизменяемое заимствование числа {}&quot;, large_integer);

        // `large_integer` выходит из области видимости
    }

    // Ок! `_mutable_integer` не заморожена в этой области видимости
    _mutable_integer = 3;
}
</code></pre></pre>
<h1><a class="header" href="#Алиасинг" id="Алиасинг">Алиасинг</a></h1>
<p>Данные могут быть заимствованы без возможности изменения любое количество раз, но пока такое заимствование существует, оригинальные данные не могут быть заимствованы с возможностью изменения. С другой стороны, 
одновременно может быть только <em>одно</em> изменяемое 
заимствование. Исходные данные могут быть снова заимствованы 
только <em>после</em> того, как изменяемая ссылка выйдет из 
области видимости.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Point { x: i32, y: i32, z: i32 }

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    {
        let borrowed_point = &amp;point;
        let another_borrow = &amp;point;

        // Данные могут быть доступны через ссылки и владельца этих данных
        println!(&quot;Точка имеет координаты: ({}, {}, {})&quot;,
                 borrowed_point.x, another_borrow.y, point.z);

        // Ошбика! Нельзя изменяемо заимствовать `point`, так как она уже
        // неизменяемо заимствована.
        //let mutable_borrow = &amp;mut point;
        // TODO ^ Попробуйте раскомментировать эту строку

        // Неизменяемые ссылки вышли из области видимости
    }

    {
        let mutable_borrow = &amp;mut point;

        // Меняем при помощи изменяемой ссылки
        mutable_borrow.x = 5;
        mutable_borrow.y = 2;
        mutable_borrow.z = 1;

        // Ошибка! Нельзя неизменяемо заимствовать `point` так как она уже
        // заимствована изменяемо.
        //let y = &amp;point.y;
        // TODO ^ Попробуйте раскомментировать эту строку

        // Ошибка! Нельзя вывести на экран потому что `println!` берёт неизменяемую ссылку.
        //println!(&quot;Point Z coordinate is {}&quot;, point.z);
        // TODO ^ Попробуйте раскомментировать эту строку

        // Ok! Изменяемая ссылка может быть передана `println!` как неизменяемая
        println!(&quot;Точка имеет координаты: ({}, {}, {})&quot;,
                 mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);

        // Изменяемая ссылка вышла из области видимости
    }

    // Неизменяемая ссылка на `point` снова разрешена
    let borrowed_point = &amp;point;
    println!(&quot;Точка имеет координаты: ({}, {}, {})&quot;,
             borrowed_point.x, borrowed_point.y, borrowed_point.z);
}
</code></pre></pre>
<h1><a class="header" href="#ref-паттерн" id="ref-паттерн"><code>ref</code> паттерн</a></h1>
<p>Когда мы используем сопоставление с образцом или 
деструктурируем при помощи <code>let</code>, можно 
использовать ключевое слово <code>ref</code> для получения 
ссылки на поле структуры или кортежа. Пример ниже показывает 
несколько случаев, когда это может быть полезно:</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // Заимствование с `ref` по левую сторону от присваивания, эквивалетно
    // заимствованию с `&amp;` по правую сторону.
    let ref ref_c1 = c;
    let ref_c2 = &amp;c;

    println!(&quot;ref_c1 равно ref_c2: {}&quot;, *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // `ref` также может использоваться при деструктуризации структур.
    let _copy_of_x = {
        // `ref_to_x` - ссылка на поле `x` в `point`.
        let Point { x: ref ref_to_x, y: _ } = point;

        // Возвращаем копию поля `x` из `point`.
        *ref_to_x
    };

    // Изменяемая копия `point`
    let mut mutable_point = point;

    {
        // `ref` может использоваться вместе с `mut` для получения изменяемой ссылки.
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // Изменяем поле `y` переменной `mutable_point` через изменяемую ссылку.
        *mut_ref_to_y = 1;
    }

    println!(&quot;point ({}, {})&quot;, point.x, point.y);
    println!(&quot;mutable_point ({}, {})&quot;, mutable_point.x, mutable_point.y);

    // Изменяемый кортеж с указателем
    let mut mutable_tuple = (Box::new(5u32), 3u32);
    
    {
        // Деструктурируем `mutable_tuple` чтобы изменить значение `last`.
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }
    
    println!(&quot;tuple {:?}&quot;, mutable_tuple);
}
</code></pre></pre>
<h1><a class="header" href="#Времена-жизни" id="Времена-жизни">Времена жизни</a></h1>
<p><em>Время жизни</em> - это конструкция, которую компилятор (или более конкретно,
его анализатор заимствований) использует, чтобы убедиться, что все
заимствования действительны. В частности время жизни переменной
начинается с момента её создания и заканчивается когда она уничтожается.
Времена жизни и области видимости упоминаются часто вместе, но
они не совпадают.</p>
<p>Возьмём, например, случай когда мы заимствуем переменную через <code>&amp;</code>.
Срок действия заимствования определяется местом его объявления.
В результате, заимствование действительно до тех пор,
пока оно не закончится или пока кредитор не будет уничтожен. Однако,
область заимствования определяется местом использования ссылки.</p>
<p>В следующем примере и в остальной части этого раздела мы увидим, как
времена жизни связаны с областями видимости, а также как они различаются.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Времена жизни аннотированы линиями, обозначающими
// создание и уничтожение каждой переменной.
// `i` имеет самое длинное время жизни, так как его область охватывает
// полностью оба заимствования `borrow1` и `borrow2`.
// Продолжительность заимствования `borrow1` по сравнению с
// заимствованием `borrow2` не имеет значения, так как они не пересекаются.
fn main() {
    let i = 3; // Lifetime for `i` starts. ────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &amp;i; // `borrow1` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow1: {}&quot;, borrow1); //              ││
    } // `borrow1 ends. ──────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &amp;i; // `borrow2` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow2: {}&quot;, borrow2); //              ││
    } // `borrow2` ends. ─────────────────────────────────┘│
    //                                                     │
}   // Lifetime ends. ─────────────────────────────────────┘
</code></pre></pre>
<p>Обратите внимание, что для меток времени жизни не назначаются имена или типы.
Это ограничивает то, как время жизни будет использоваться, как мы увидим далее.</p>
<h1><a class="header" href="#Явное-аннотирование" id="Явное-аннотирование">Явное аннотирование</a></h1>
<p>Анализатор заимствований использует явные аннотации времён 
жизни для определения того, как долго ссылки будут 
действительны. В случаях, когда времена жизни не скрыты<sup class="footnote-reference"><a href="#1">1</a></sup>, Rust 
требует их явного аннотирования, чтобы определить какое у 
ссылки должно быть время жизни. Для явного аннотирования 
времени жизни используется синтаксис с символом апострофа, как 
тут:</p>
<pre><code class="language-rust ignore">foo&lt;'a&gt;
// `foo` имеет параметр времени жизни `'a`
</code></pre>
<p>Подобно <a href="scope/lifetime/../../fn/closures/anonymity.html">замыканиям</a>, явное использование времён жизни 
требует обобщённого параметра. Кроме того, такой синтаксис 
показывает, что время жизни <code>foo</code> не может 
превышать <code>'a</code>. Явная аннотация для типа имеет 
форму <code>&amp;'a T</code>, где <code>'a</code> уже задана.</p>
<p>В случаях со множественными временами жизни, синтаксис будет 
подобен следующему:</p>
<pre><code class="language-rust ignore">foo&lt;'a, 'b&gt;
// `foo` имеет параметры времён жизни `'a` и `'b`
</code></pre>
<p>В данном случае, время жизни <code>foo</code> не может 
превышать <em>ни <code>'a</code>, ни <code>'b</code></em>.</p>
<p>Рассмотрим следующий пример, в котором используется явная аннотация времён жизни:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// `print_refs` получает две ссылки на `i32`, имеющие различные
// времена жизни `'a` и `'b`. Оба этих времени жизни должны существовать
// не меньше, чем функция `print_refs`.
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;x равно {} и y равно {}&quot;, x, y);
}

// Функция, не имеющая аргументов, но имеющая параметр времени жизни `'a`.
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // ОШИБКА: `_x` не живёт достаточно долго (`_x` does not live long enough)
    //let y: &amp;'a i32 = &amp;_x;
    // Попытка использования времени жизни `'a` для явного аннотирования 
    // внутри функции приведёт к ошибке, так как время жизни у `&amp;_x` короче, чем
    // у `y`. Коротное время жизни не может быть приведено к длинному.
}

fn main() {
    // Создадим переменные, которые далее будут заимствованы.
    let (four, nine) = (4, 9);
    
    // Заимствуем (`&amp;`) обе переменные и передадим их в функцию.
    print_refs(&amp;four, &amp;nine);
    // Любой ввод, который заимствуется, должен жить дольше, чем заимствующий. 
    // Другими словами, время жизни `four` и `nine` должно
    // быть больше, чем время жизни `print_refs`.
    
    failed_borrow();
    // `failed_borrow` не содержит ссылок, заставляющих `'a` быть
    // больше, чем время жизни функции, но `'a` больше.
    // Поскольку время жизни никогда не ограничено, оно, по умолчанию, равно `'static`.
}
</code></pre></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="scope/lifetime/elision.html">сокрытие</a> позволяет скрыть аннотации времён жизни, но они всё же присутствуют.</p>
</div>
<h3><a class="header" href="#Смотрите-также-46" id="Смотрите-также-46">Смотрите также:</a></h3>
<p><a href="scope/lifetime/../../generics.html">Обобщения</a> и <a href="scope/lifetime/../../fn/closures.html">замыкания</a></p>
<h1><a class="header" href="#Функции-2" id="Функции-2">Функции</a></h1>
<p>Сигнатуры функции с указанием времени жизни имеют некоторые ограничения:</p>
<ul>
<li>любая ссылка <em>должна</em> иметь аннотированное время жизни</li>
<li>любая возвращаемая ссылка <em>должна</em> иметь то же время жизни, что входящая ссылкаили <code>static</code>.</li>
</ul>
<p>Кроме того, обратите внимание, что возврат ссылок из функции, которая не имеет ссылок во входных аргументах, запрещен, если он
приведет к возвращению ссылок на недопустимые данные. В следующем примере показаны
некоторые действительные формы функции со временем жизни:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Одна входная ссылка со временем жизни `'a`, которая
// будет жить как минимум до конца функции.
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`print_one`: x is {}&quot;, x);
}

// Использование времени жизни также возможно с изменяемыми ссылками.
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// Несколько элементов с различными временами жизни. В этом случае
// было бы хорошо, чтобы у обоих ссылок было одно время жизни `'a`,
// в более сложных случаях может потребоваться различное время жизни.
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;`print_multi`: x is {}, y is {}&quot;, x, y);
}

// Возврат переданных на вход ссылок допустим.
// Однако должен быть указано правильное время жизни.
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

//fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String { &amp;String::from(&quot;foo&quot;) }
// Код написанный выше является недопустимым: время жизни `'a`
// должно жить после выхода из функции.
// Здесь, `&amp;String::from(&quot;foo&quot;)` создает ссылку на `String`
// Данные будут удалены после выхода из области видимости, и
// будет возвращена ссылка на недопустимые данные.

fn main() {
    let x = 7;
    let y = 9;
    
    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);
    
    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-47" id="Смотрите-также-47">Смотрите также:</a></h3>
<p><a href="scope/lifetime/fn.html">функции</a></p>
<h1><a class="header" href="#Методы-1" id="Методы-1">Методы</a></h1>
<p>Методы аннотируются аналогично функциям:</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Owner(i32);

impl Owner {
    // Время жизни аннотируется как в отдельной функции.
    fn add_one&lt;'a&gt;(&amp;'a mut self) {
        self.0 += 1;
    }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!(&quot;`print`: {}&quot;, self.0);
    }
}

fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-48" id="Смотрите-также-48">Смотрите также:</a></h3>
<p><a href="scope/lifetime/fn/methods.html"><code>Методы</code></a></p>
<h1><a class="header" href="#Структуры-2" id="Структуры-2">Структуры</a></h1>
<p>Аннотирование времени жизни в структурах аналогично функциям:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Тип `Borrowed`, в котором находится ссылка на `i32`.
// Ссылка на `i32` должна пережить `Borrowed`.
#[derive(Debug)]
struct Borrowed&lt;'a&gt;(&amp;'a i32);

// Аналогично, обе ссылки расположенные здесь, должны пережить эту структуру.
#[derive(Debug)]
struct NamedBorrowed&lt;'a&gt; {
    x: &amp;'a i32,
    y: &amp;'a i32,
}

// Перечисление, которое указывает на `i32` или на ссылку.
#[derive(Debug)]
enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number = Either::Num(y);

    println!(&quot;x заимствован в {:?}&quot;, single);
    println!(&quot;x и y заимствованы в {:?}&quot;, double);
    println!(&quot;x заимствован в {:?}&quot;, reference);
    println!(&quot;y *не* заимствован в {:?}&quot;, number);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-49" id="Смотрите-также-49">Смотрите также:</a></h3>
<p><a href="scope/lifetime/custom_types/structs.html"><code>Структуры</code></a></p>
<h1><a class="header" href="#Типажи-1" id="Типажи-1">Типажи</a></h1>
<p>Аннотирование времён жизни для методов типажей в основном 
похоже на аннотирование в функциях. Обратите внимание, что 
<code>impl</code> также может иметь аннотацию времени жизни.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Структура с аннотированным временем жизни.
#[derive(Debug)]
 struct Borrowed&lt;'a&gt; {
     x: &amp;'a i32,
 }

// Аннотированное время жизни для реализации.
impl&lt;'a&gt; Default for Borrowed&lt;'a&gt; {
    fn default() -&gt; Self {
        Self {
            x: &amp;10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();
    println!(&quot;b равно {:?}&quot;, b);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-50" id="Смотрите-также-50">Смотрите также:</a></h3>
<p><a href="scope/lifetime/../../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#Ограничения-1" id="Ограничения-1">Ограничения</a></h1>
<p>Так же, как и обобщённые типы, времена жизни (обобщённое само по себе) могут быть ограничены.
Для них знак <code>:</code> имеет немного другое значение,
но знак <code>+</code> такое же. Прочитайте следующую заметку:</p>
<ol>
<li><code>T: 'a</code>: <em>Все</em> ссылки в <code>T</code> должны пережить время жизни <code>'a</code>.</li>
<li><code>T: Trait + 'a</code>: Тип <code>T</code> должен реализовать типаж <code>Trait</code> и <em>все</em> ссылкив <code>T</code> должны пережить <code>'a</code>.</li>
</ol>
<p>Пример ниже демонстрирует синтаксис в действии и использует его после ключевого слова <code>where</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::Debug; // Типаж с ограничениями.

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref` содержит ссылки на обобщённый тип `T` который имеет
// неизвестное время жизни `'a`. `T` ограничен так, что любые
// *ссылки* в `T` должны пережить `'a`.
// Кроме того, время жизни `Ref` не может превышать `'a`.

// Обобщённая функция, которая показывает использование типажа `Debug`.
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!(&quot;`print`: t это {:?}&quot;, t);
}

// Здесь приводится ссылка на `T`, где `T` реализует
// `Debug` и все *ссылки* в `T` переживают `'a`.
// К тому же, `'a` должен пережить функцию.
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!(&quot;`print_ref`: t это {:?}&quot;, t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-51" id="Смотрите-также-51">Смотрите также:</a></h3>
<p><a href="scope/lifetime/../../generics.html">Обобщения</a>, <a href="scope/lifetime/../../generics/bounds.html">ограничения в обобщениях</a> и
<a href="scope/lifetime/../../generics/multi_bounds.html">множественные ограничения в обобщениях</a></p>
<h1><a class="header" href="#Приведение-coercion" id="Приведение-coercion">Приведение (coercion)</a></h1>
<p>Длинное время жизни может быть приведено к короткому, 
благодаря чему всё работает нормально внутри области 
видимости, хотя кажется, что не должно. Это достигается за счёт того что компилятор Rust выполняет приведение времён жизни и за счёт 
объявления разницы между ними разницы:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Здесь Rust выводит наиболее короткое время жизни.
// Затем обе ссылки приводятся к этому времени жизни.
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}

// `&lt;'a: 'b, 'b&gt;` читается как &quot;время жизни `'a` не меньше, чем время жизни `'b`&quot;.
// Здесь мы получаем  `&amp;'a i32` и в результате приведения возвращаем `&amp;'b i32`.
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'b i32 {
    first
}

fn main() {
    let first = 2; // Более длинное время жизни
    
    {
        let second = 3; // Более короткое время жизни
        
        println!(&quot;Произведение равно {}&quot;, multiply(&amp;first, &amp;second));
        println!(&quot;{} первое&quot;, choose_first(&amp;first, &amp;second));
    };
}
</code></pre></pre>
<h1><a class="header" href="#static" id="static">Static</a></h1>
<p><code>'static</code> - наибольшее возможное время жизни и 
длится в течение всей жизни работающей программы. 
<code>'static</code> может быть приведено к более короткому 
времени жизни. Есть два способа сделать переменную со 
временем жизни <code>'static</code> и в результате обоих 
способов, переменная хранится в неизменяемой памяти бинарного 
файла:</p>
<ul>
<li>Создание константы с ключевым словом <code>static</code>.</li>
<li>Создание <em>строкового</em> литерала, имеющего тип <code>&amp;'static str</code>.</li>
</ul>
<p>Рассмотрим следующий пример, который показывает оба метода:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Создадим константу со временем жизни `'static`.
static NUM: i32 = 18;

// Вернём ссылку на `NUM`, у которой собственное время жизни `'static` 
// приводится ко времени жизни аргумента.
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        // Создадим *строковый* литерал и выведем его:
        let static_string = &quot;Я в неизменяемой памяти&quot;;
        println!(&quot;static_string: {}&quot;, static_string);

        // Когда `static_string` выходит из области видимости, ссылка
        // на неё больше не может быть использована, но данные остаются в бинарном файле.
    }
    
    {
        // Создадим число для использования в `coerce_static`:
        let lifetime_num = 9;

        // Приведём `NUM` ко времени жизни `lifetime_num`:
        let coerced_static = coerce_static(&amp;lifetime_num);

        println!(&quot;coerced_static: {}&quot;, coerced_static);
    }
    
    println!(&quot;NUM: {} остаётся доступным!&quot;, NUM);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-52" id="Смотрите-также-52">Смотрите также:</a></h3>
<p><a href="scope/lifetime/../../custom_types/constants.html"><code>'static</code> константы</a></p>
<h1><a class="header" href="#Сокрытие" id="Сокрытие">Сокрытие</a></h1>
<p>Некоторые шаблоны времён жизни достаточно общие и поэтому 
анализатор заимствований может позволить вам опустить их чтобы 
ускорить написание кода и увеличить его читаемость.
Это известно как сокрытие времён жизни. Сокрытие появилось в Rust, 
исключительно из-за того, что они применяются к общим шаблонам.</p>
<p>Следующий код показывает несколько примеров сокрытия. Для более полного описания сокрытия, обратитесь к главе про [a0}сокрытие времён жизни в TRPL.</p>
<pre><pre class="playpen"><code class="language-rust editable">// По существу, `elided_input` и `annotated_input` имеют одинаковую сигнатуру
// потому что время жизни `elided_input` выводится компилятором:
fn elided_input(x: &amp;i32) {
    println!(&quot;`elided_input`: {}&quot;, x);
}

fn annotated_input&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`annotated_input`: {}&quot;, x);
}

// Аналогично, `elided_pass` и `annotated_pass` имеют идентичные сигнатуры
// потому что время жизни неявно добавлено к `elided_pass`:
fn elided_pass(x: &amp;i32) -&gt; &amp;i32 { x }

fn annotated_pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 3;

    elided_input(&amp;x);
    annotated_input(&amp;x);

    println!(&quot;`elided_pass`: {}&quot;, elided_pass(&amp;x));
    println!(&quot;`annotated_pass`: {}&quot;, annotated_pass(&amp;x));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-53" id="Смотрите-также-53">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">сокрытие</a></p>
<h1><a class="header" href="#Типажи-2" id="Типажи-2">Типажи</a></h1>
<p><code>Типаж (trait)</code> - это набор методов, определённых для неизвестного типа:
<code>Self</code>. Они могут получать доступ к другим методам,
которые были объявлены в том же типаже.</p>
<p>Типажи могут быть реализованы для любых типов данных. В примере ниже,
мы определили группу методов <code>Animal</code>. Типаж <code>Animal</code> реализован для типа данных
<code>Sheep</code>, что позволяет использовать методы из <code>Animal</code> внутри <code>Sheep</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Sheep { naked: bool, name: &amp;'static str }

trait Animal {
    // Сигнатура статического метода, `Self` ссылается на реализующий тип.
    fn new(name: &amp;'static str) -&gt; Self;

    // Сигнатура метода экземпляра; они возвращают строки.
    fn name(&amp;self) -&gt; &amp;'static str;
    fn noise(&amp;self) -&gt; &amp;'static str;

    // Типаж может содержать определение метода по умолчанию
    fn talk(&amp;self) {
        println!(&quot;{} говорит {}&quot;, self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // Методы типа могут использовать методы типажа, реализованного для этого типа.
            println!(&quot;{} уже без волос...&quot;, self.name());
        } else {
            println!(&quot;{} подстригается!&quot;, self.name);

            self.naked = true;
        }
    }
}

// Реализуем типаж `Animal` для `Sheep`.
impl Animal for Sheep {
    // `Self` реализующий тип: `Sheep`.
    fn new(name: &amp;'static str) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; &amp;'static str {
        self.name
    }

    fn noise(&amp;self) -&gt; &amp;'static str {
        if self.is_naked() {
            &quot;baaaaah?&quot;
        } else {
            &quot;baaaaah!&quot;
        }
    }

    // Методы по умолчанию могут быть переопределены.
    fn talk(&amp;self) {
        // Например, мы добавили немного спокойного миросозерцания...
        println!(&quot;{} делает паузу... {}&quot;, self.name, self.noise());
    }
}

fn main() {
    // Аннотация типа в данном случае необходима.
    let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;);
    // ЗАДАНИЕ ^ Попробуйте убрать аннотацию типа

    dolly.talk();
    dolly.shear();
    dolly.talk();
}
</code></pre></pre>
<h1><a class="header" href="#Атрибут-derive" id="Атрибут-derive">Атрибут <code>Derive</code></a></h1>
<p>Компилятор способен предоставить основные реализации для некоторых типажей
с помощью <a href="trait/../attribute.html">атрибута</a> <code>#[derive]</code>. Эти типажи могут быть
реализованы вручную, если необходимо более сложное поведение.</p>
<p>Ниже приводится список выводимых типажей:</p>
<ul>
<li>Типажи сравнения:<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></li>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, для создания <code>T</code> из <code>&amp;T</code> с помощью копии.</li>
<li><a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>Copy</code></a>, чтобы создать тип семантикой копирования, вместо семантики перемещения.</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a>, чтобы вычислить хеш из <code>&amp;T</code>.</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>, чтобы создать пустой экземпляр типа данных.</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>, чтобы отформатировать значение с помощью <code>{:?}</code>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">// `Centimeters`, кортежная структура, которую можно сравнить
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`, кортежная структура, которую можно напечатать
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// `Seconds`, кортежная структура без дополнительных атрибутов
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    // Ошибка: `Seconds` не может быть напечатана; не реализован типаж `Debug`
    //println!(&quot;Одна секунда выглядит как: {:?}&quot;, _one_second);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Ошибка: `Seconds` нельзя сравнить; не реализован типаж `PartialEq`
    //let _this_is_true = (_one_second == _one_second);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    let foot = Inches(12);

    println!(&quot;Один фут равен {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;меньше&quot;
        } else {
            &quot;больше&quot;
        };

    println!(&quot;Один фут {} одного метра.&quot;, cmp);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-54" id="Смотрите-также-54">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#derive"><code>derive</code></a></p>
<h1><a class="header" href="#Перегрузка-операторов" id="Перегрузка-операторов">Перегрузка операторов</a></h1>
<p>В Rust, множество операторов могут быть перегружены с помощью типажей. То есть, некоторые
операторы могут использоваться для выполнения различных задач на основе вводимых аргументов.
Это возможно, потому что операторы являются синтаксическим сахаром для вызова методов. Например,
оператор <code>+</code> в <code>a + b</code> вызывает метод <code>add</code> (как в <code>a.add(b)</code>).
Метод <code>add</code> является частью типажа <code>Add</code>.
Следовательно, оператор <code>+</code> могут использовать все, кто реализуют типаж <code>Add</code>.</p>
<p>Список типажей, таких как <code>Add</code>, которые перегружают операторы, доступен <a href="https://doc.rust-lang.org/core/ops/">здесь</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// Типаж `std::ops::Add` используется для указания функциональности `+`.
// Здесь мы объявим `Add&lt;Bar&gt;` - типаж сложения, со вторым
// операндом типа `Bar`.
// Следующий блок реализует операцию: Foo + Bar = FooBar
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        println!(&quot;&gt; Вызвали Foo.add(Bar)&quot;);

        FooBar
    }
}

// Если мы поменяем местами типы, то получим реализацию некоммутативного сложения.
// Здесь мы объявим `Add&lt;Foo&gt;` - типаж сложения, со вторым
// операндом типа `Foo`.
// Этот блок реализует операцию: Bar + Foo = BarFoo
impl ops::Add&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -&gt; BarFoo {
        println!(&quot;&gt; Вызвали Bar.add(Foo)&quot;);

        BarFoo
    }
}

fn main() {
    println!(&quot;Foo + Bar = {:?}&quot;, Foo + Bar);
    println!(&quot;Bar + Foo = {:?}&quot;, Bar + Foo);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-55" id="Смотрите-также-55">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/core/ops/trait.Add.html">Add</a>, <a href="https://doc.rust-lang.org/book/second-edition/appendix-02-operators.html">Syntax Index</a></p>
<h1><a class="header" href="#Типаж-drop" id="Типаж-drop">Типаж Drop</a></h1>
<p>Типаж <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> имеет только один метод: <code>drop</code>, который вызывается автоматически,
когда объект выходит из области видимости. Основное применение типажа <code>Drop</code>
заключается в том, чтобы освободить ресурсы, которыми владеет экземпляр реализации.</p>
<p><code>Box</code>, <code>Vec</code>, <code>String</code>, <code>File</code>, и <code>Process</code> - это некоторые примеры типов, которые
реализуют типаж <code>Drop</code> для освобождения ресурсов. Типаж <code>Drop</code> также может быть
реализован вручную для любых индивидуальных типов данных.</p>
<p>В следующем примере мы добавим вывод в консоль к функции <code>drop</code>, чтобы было видно,
когда она вызывается.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Droppable {
    name: &amp;'static str,
}

// Это простая реализация `drop`, которая добавляет вывод в консоль.
impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;&gt; Сбросили {}&quot;, self.name);
    }
}

fn main() {
    let _a = Droppable { name: &quot;a&quot; };

    // блок А
    {
        let _b = Droppable { name: &quot;b&quot; };

        // блок Б
        {
            let _c = Droppable { name: &quot;c&quot; };
            let _d = Droppable { name: &quot;d&quot; };

            println!(&quot;Выходим из блока Б&quot;);
        }
        println!(&quot;Вышли из блока Б&quot;);

        println!(&quot;Выходим из блока А&quot;);
    }
    println!(&quot;Вышли из блока А&quot;);

    // Переменную можно сбросить вручную с помощью функции `drop`.
    drop(_a);
    // ЗАДАНИЕ ^ Попробуйте закомментировать эту строку

    println!(&quot;Конец главной функции.&quot;);

    // *Нельзя* сбросить `_a` снова, потому что переменная уже
    // (вручную) сброшена.
}
</code></pre></pre>
<h1><a class="header" href="#Итераторы" id="Итераторы">Итераторы</a></h1>
<p>Типаж <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a> используется для итерирования
по коллекциям, таким как массивы.</p>
<p>Типаж требует определить метод <code>next</code>, для получения следующего элемента.
Данный метод в блоке <code>impl</code> может быть определён
вручную или автоматически (как в массивах и диапазонах).</p>
<p>Для удобства использования, например в цикле <code>for</code>, некоторые коллекции
превращаются в итераторы с помощью метода <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>.into_iterator()</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Fibonacci {
    curr: u32,
    next: u32,
}

// Реализация `Iterator` для `Fibonacci`.
// Для реализации типажа `Iterator` требуется реализовать метод `next`.
impl Iterator for Fibonacci {
    type Item = u32;
    
    // Здесь мы определяем последовательность, используя `.curr` и `.next`.
    // Возвращаем тип `Option&lt;T&gt;`:
    //     * Когда в `Iterator` больше нет значений, будет возвращено `None`.
    //     * В противном случае следующее значение оборачивается в `Some` и возвращается.
    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {
        let new_next = self.curr + self.next;

        self.curr = self.next;
        self.next = new_next;

        // Поскольку последовательность Фибоначчи бесконечна,
        // то `Iterator` никогда не вернет `None`, и всегда будет
        // возвращаться `Some`.
        Some(self.curr)
    }
}

// Возвращается генератор последовательности Фибоначчи.
fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 0, next: 1 }
}

fn main() {
    // `0..3` это `Iterator`, который генерирует : 0, 1, и 2.
    let mut sequence = 0..3;

    println!(&quot;Четыре подряд вызова `next`на 0..3&quot;);
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());

    // `for` работает через `Iterator` пока тот не вернет `None`.
    // каждое значение `Some` распаковывается  и привязывается к переменной (здесь это `i`).
    println!(&quot;Итерирование по 0..3 используя `for`&quot;);
    for i in 0..3 {
        println!(&quot;&gt; {}&quot;, i);
    }

    // Метод `take(n)` уменьшает `Iterator` до его первых `n` членов.
    println!(&quot;Первые четыре члена последовательности Фибоначчи: &quot;);
    for i in fibonacci().take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    // Метод `skip(n)` сокращает `Iterator`, отбрасывая его первые `n` членов.
    println!(&quot;Следующие четыре члена последовательности Фибоначчи: &quot;);
    for i in fibonacci().skip(4).take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    let array = [1u32, 3, 3, 7];

    // Метод `iter` превращает `Iterator` в массив/срез.
    println!(&quot;Итерирование по массиву {:?}&quot;, &amp;array);
    for i in array.iter() {
        println!(&quot;&gt; {}&quot;, i);
    }
}
</code></pre></pre>
<h1><a class="header" href="#Типаж-clone" id="Типаж-clone">Типаж Clone</a></h1>
<p>При работе с ресурсами, стандартным поведением является передача их (ресурсов)
в ходе выполнения или вызов функции. Однако, иногда нам нужно
также объявить копию ресурса.</p>
<p>Типаж <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> помогает нам сделать именно это. Чаще всего, мы можем
использовать метод <code>.clone()</code> объявленный типажом <code>Clone</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Единичная структура без ресурсов
#[derive(Debug, Clone, Copy)]
struct Nil;

// Кортежная структура с ресурсами, которая реализует типаж `Clone`
#[derive(Clone, Debug)]
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

fn main() {
    // Объявим экземпляр `Nil`
    let nil = Nil;
    // Скопируем `Nil`, который не имеет ресурсов для перемещения
    let copied_nil = nil;

    // Оба `Nil`s могут быть использованы независимо
    println!(&quot;оригинал: {:?}&quot;, nil);
    println!(&quot;копия: {:?}&quot;, copied_nil);

    // Объявим экземпляр `Pair`
    let pair = Pair(Box::new(1), Box::new(2));
    println!(&quot;оригинал: {:?}&quot;, pair);

    // Скопируем `pair` в `moved_pair`, перенаправляя ресурсы
    let moved_pair = pair;
    println!(&quot;копия: {:?}&quot;, moved_pair);

    // Ошибка! `pair` потеряла свои ресурсы
    //println!(&quot;оригинал: {:?}&quot;, pair);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Скопируем `moved_pair` в `cloned_pair` (включая ресурсы)
    let cloned_pair = moved_pair.clone();
    // Сбросим оригинальную пару используя std::mem::drop
    drop(moved_pair);

    // Ошибка! `moved_pair` была сброшена
    //println!(&quot;копия: {:?}&quot;, moved_pair);
    // ЗАДАНИЕ ^ Попробуйте раскомментировать эту строку

    // Полученный результат из .clone() все ещё можно использовать!
    println!(&quot;клон: {:?}&quot;, cloned_pair);
}
</code></pre></pre>
<h1><a class="header" href="#macro_rules" id="macro_rules">macro_rules!</a></h1>
<p>Rust предоставляет мощную систему макросов, которая позволяет
использовать метапрограммирование. Как вы могли видеть в предыдущих главах,
макросы выглядят как функции, но их имя заканчивается восклицательным знаком (<code>!</code>).
Вместо вызова функции, макросы расширяются в исходный код, который впоследствии
компилируется с остальной частью программы.
Однако, в отличие от макросов на C и других языках, макросы Rust расширяются
в абстрактные синтаксические деревья, а не в подстановку строк,
поэтому Вы не получаете неожиданных ошибок приоритета операций.</p>
<p>Макросы создаются с помощью макроса <code>macro_rules!</code></p>
<pre><pre class="playpen"><code class="language-rust editable">// Этот простой макрос называется `say_hello`.
macro_rules! say_hello {
    // `()` указывает, что макрос не принимает аргументов.
    () =&gt; (
        // Макрос будет раскрываться с содержимым этого блока.
        println!(&quot;Hello!&quot;);
    )
}

fn main() {
    // Этот вызов будет раскрыт в код `println!(&quot;Hello&quot;);`
    say_hello!()
}
</code></pre></pre>
<p>Так почему же макросы полезны?</p>
<ol>
<li>
<p>Не повторяйтесь. Есть много случаев, когда вам может понадобиться подобная
функциональность в нескольких местах, но с различными типами. Чаще всего написание
макроса - это полезный способ избежать повторения кода. (Подробнее об этом позже)</p>
</li>
<li>
<p>Предметно-ориентированные языки. Макросы позволяют определить специальный синтаксис для
конкретной цели. (Подробнее об этом позже)</p>
</li>
<li>
<p>Вариативные интерфейсы. Иногда требуется определить интерфейс, который
имеет переменное количество аргументов. Пример: <code>println!</code>, который может принять любое
количество аргументов в зависимости от строки формата. (Подробнее об этом позже)</p>
</li>
</ol>
<h1><a class="header" href="#Синтаксис" id="Синтаксис">Синтаксис</a></h1>
<p>В следующем подразделе мы посмотрим как в Rust объявить 
макрос. Есть три основные идеи:</p>
<ul>
<li><a href="macros/designators.html">Шаблоны и указатели</a></li>
<li><a href="macros/overload.html">Перегрузка</a></li>
<li><a href="macros/repeat.html">Повторение</a></li>
</ul>
<h1><a class="header" href="#Указатели" id="Указатели">Указатели</a></h1>
<p>Аргументы макроса имеют префикс знака доллара <code>$</code> и тип аннотируется
с помощью <em>указателей фрагмента</em>:</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! create_function {
    // Этот макрос принимает аргумент идентификатора `ident` и
    // создаёт функцию с именем `$func_name`.
    // Идентификатор `ident` используют для обозначения имени переменной/функции.
    ($func_name:ident) =&gt; (
        fn $func_name() {
            // Макрос `stringify!` преобразует `ident` в строку.
            println!(&quot;Вызвана функция {:?}()&quot;,
                     stringify!($func_name))
        }
    )
}

// Создадим функции с именами `foo` и `bar` используя макрос, указанный выше.
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // Этот макрос принимает выражение типа `expr` и напечатает
    // его как строку вместе с результатом.
    // Указатель `expr` используют для обозначения выражений.
    ($expression:expr) =&gt; (
        // `stringify!` преобразует выражение в строку *без изменений*.
        println!(&quot;{:?} = {:?}&quot;,
                 stringify!($expression),
                 $expression);
    )
}

fn main() {
    foo();
    bar();

    print_result!(1u32 + 1);

    // Напомним, что блоки тоже являются выражениями!
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });
}
</code></pre></pre>
<p>Это список всех указателей:</p>
<ul>
<li><code>block</code></li>
<li><code>expr</code> используют для обозначения выражений</li>
<li><code>ident</code> используют для обозначения имени переменной/функции</li>
<li><code>item</code></li>
<li><code>literal</code> используется для литеральных констант</li>
<li><code>pat</code> (<em>образец</em>)</li>
<li><code>path</code></li>
<li><code>stmt</code> (<em>единственный оператор</em>)</li>
<li><code>tt</code> (<em>единственное дерево лексем</em>)</li>
<li><code>ty</code> (<em>тип</em>)</li>
<li><code>vis</code> (<em>спецификатор видимости</em>)</li>
</ul>
<p>Полный список указателей, вы можете увидеть в <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Rust Reference</a>.</p>
<h1><a class="header" href="#Перегрузка" id="Перегрузка">Перегрузка</a></h1>
<p>Макросы могут быть перегружены, принимая различные комбинации аргументов.
В этом плане, <code>macro_rules!</code> может работать аналогично блоку сопоставления (match):</p>
<pre><pre class="playpen"><code class="language-rust editable">// `test!` будет сравнивать `$left` и `$right`
// по разному, в зависимости от того, как вы объявите их:
macro_rules! test {
    // Не нужно разделять аргументы запятой.
    // Можно использовать любой шаблон!
    ($left:expr; and $right:expr) =&gt; (
        println!(&quot;{:?} и {:?} это {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    );
    // ^ каждый блок должен заканчиваться точкой с запятой.
    ($left:expr; or $right:expr) =&gt; (
        println!(&quot;{:?} или {:?} это {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    );
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}
</code></pre></pre>
<h1><a class="header" href="#Повторение" id="Повторение">Повторение</a></h1>
<p>Макросы могут использовать знак <code>+</code> в списке аргументов, чтобы указать, какие аргументы
могут повторяться хоть один раз, или знак <code>*</code>, чтобы указать, какие аргументы могут
повторяться ноль или несколько раз.</p>
<p>В следующем примере, шаблон, окружённый <code>$(...),+</code> будет
сопоставлять одно или несколько выражений, разделённых запятыми.
Также обратите внимание, что точка с запятой является
необязательной в последнем случае.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `min!` посчитает минимальное число аргументов.
macro_rules! find_min {
    // Простой вариант:
    ($x:expr) =&gt; ($x);
    // `$x` следует хотя бы одному `$y,`
    ($x:expr, $($y:expr),+) =&gt; (
        // Вызовем `find_min!` на конце `$y`
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!(&quot;{}&quot;, find_min!(1u32));
    println!(&quot;{}&quot;, find_min!(1u32 + 2 , 2u32));
    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));
}
</code></pre></pre>
<h1><a class="header" href="#dry-Не-повторяйся" id="dry-Не-повторяйся">DRY (Не повторяйся)</a></h1>
<p>Макросы позволяют писать DRY код, путём разделения общих частей функций
и/или набор тестов. Вот пример, который реализует и тестирует операторы
<code>+=</code>, <code>*=</code> и <code>-=</code> на <code>Vec&lt;T&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // Указатель `tt` (единственное дерево лексем) используют для
    // операторов и лексем.
    ($a:ident, $b: ident, $func:ident, $op:tt) =&gt; (
        assert!($a.len() == $b.len(),
                &quot;{:?}: несоответствие размеров: {:?} {:?} {:?}&quot;,
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    )
}

macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; (
        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    )
}

// Реализуем функции `add_assign`, `mul_assign`, и `sub_assign`.
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ($func: ident, $x:expr, $y:expr, $z:expr) =&gt; {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                    super::$func(&amp;mut x, &amp;y);

                    assert_eq!(x, z);
                }
            }
        }
    }

    // Протестируем `add_assign`, `mul_assign` и `sub_assign`
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}
</code></pre></pre>
<pre><code class="language-bash">$ rustc --test dry.rs &amp;&amp; ./dry
running 3 tests
test test::mul_assign ... ok
test test::add_assign ... ok
test test::sub_assign ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<h1><a class="header" href="#domain-specific-languages-dsls" id="domain-specific-languages-dsls">Domain Specific Languages (DSLs)</a></h1>
<p>DSL - это мини язык, встроенный в макросы Rust. Это полностью 
допустимый код на Rust, так как система макросов разворачивается 
в нормальные конструкции, но выглядит как маленький язык. Это 
позволяет вам определять краткий или интуитивный синтаксис для 
некоторой функциональности (в пределах границ).</p>
<p>Предположим, я хочу определить небольшое API для калькулятора. 
Я хотел бы предоставить выражение и вывести результат в консоль.</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! calculate {
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Заставим быть переменную целым числом.
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};
}

fn main() {
    calculate! {
        eval 1 + 2 // хе-хе, `eval` _не_ ключевое слово Rust!
    }

    calculate! {
        eval (1 + 2) * (3 / 4)
    }
}
</code></pre></pre>
<p>Вывод:</p>
<pre><code class="language-txt">1 + 2 = 3
(1 + 2) * (3 / 4) = 0
</code></pre>
<p>Это очень простой пример, но можно разработать и гораздо более 
сложные интерфейсы, такие как <a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a> 
или <a href="https://crates.io/crates/clap"><code>clap</code></a>.</p>
<p>Также обратите внимание на две пары скобок в макросе. Внешняя 
пара является частью синтаксиса <code>macro_rules!</code>, в 
дополнение к <code>()</code> или <code>[]</code>.</p>
<h1><a class="header" href="#Вариативные-интерфейсы" id="Вариативные-интерфейсы">Вариативные интерфейсы</a></h1>
<p>Интерфейсы с <em>переменным числом параметров</em> (вариативные интерфейсы) принимают произвольное число 
аргументов. Например,  <code>println!</code> может принимать 
произвольное число аргументов, как определено в формате строки.</p>
<p>Мы можем расширить наш макрос <code>calculate!</code> из 
предыдущей главы, чтобы он имел вариативный интерфейс:</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! calculate {
    // Шаблон для единичного `eval`
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Заставим быть переменную целым числом.
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};

    // Рекурсивно декомпозируем несколько `eval`
    (eval $e:expr, $(eval $es:expr),+) =&gt; {{
        calculate! { eval $e }
        calculate! { $(eval $es),+ }
    }};
}

fn main() {
    calculate! { // Смотри, мама! Вариативный `calculate!`!
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }
}
</code></pre></pre>
<p>Вывод:</p>
<pre><code class="language-txt">1 + 2 = 3
3 + 4 = 7
(2 * 3) + 1 = 7
</code></pre>
<h1><a class="header" href="#Обработка-ошибок" id="Обработка-ошибок">Обработка ошибок</a></h1>
<p>Обработка ошибок - это процесс управления возможными сбоями. 
Например ошибка чтения файла и последующее использование <em>плохих</em> данных могут прояснить проблематику.
Уведомление и явное управление этими ошибками сохранит оставшуюся часть программы от различных неожиданностей.</p>
<p>В Rust есть разные пути работы с ошибками, которые описаны в следующих главах. Они все имеют те или иные отличия и разные варианты использования. Как правило большого пальца:</p>
<p>Явный <code>panic</code> в основном применим для тестирования и работы с невосстановимыми ошибками.
При прототипировании его можно использовать, например, когда работаем с ещё не реализованными функциями, но в этом случае лучше использовать более говорящее <code>unimplemented</code>. 
В тестах <code>panic</code> - разумный способ явного оповещения об ошибке.</p>
<p>Тип <code>Option</code> предназначен для случаев, когда значение не обязательно или когда отсутствие значения не является ошибкой. 
Например, корневые директории <code>/</code> и <code>C:</code> не имеют родителя. При работе с <code>Option</code>, 
для прототипирования и случаев, когда мы точно знаем, что 
значение должно быть, отлично подходит <code>unwrap</code>. Однако более полезен <code>expect</code>, так как он позволяет 
указать сообщение об ошибке на случай, если что-то пойдёт не так.</p>
<p>Когда есть вероятность, что что-то пойдёт не так и вызывающая 
сторона должна как-то обработать эту ситуацию, используйте <code>Result</code>. 
Вы также можете использовать <code>unwrap</code> и <code>expect</code> (пожалуйста, не делайте этого, если вы не пишете тест или не прототипируете).</p>
<p>Для более полного изучения обработки ошибок, обратитесь к <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">соответствующему разделу в книге</a>.</p>
<h1><a class="header" href="#panic" id="panic"><code>panic</code></a></h1>
<p>Самый простой механизм обработки ошибок, с которым мы познакомимся – это <code>panic</code>.
Он печатает сообщение с ошибкой, начинает процедуру
раскрутки стека и, чаще всего, завершает программу. В данном примере мы явно вызываем <code>panic</code> в случае ошибки:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn give_princess(gift: &amp;str) {
    // Принцесса ненавидит змей, поэтому нам нужно остановиться, если она не одобрит!
    if gift == &quot;змея&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;Я люблю тебя, {}!!!!!&quot;, gift);
}

fn main() {
    give_princess(&quot;плюшевый мишка&quot;);
    give_princess(&quot;змея&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#option-и-unwrap" id="option-и-unwrap"><code>Option</code> и <code>unwrap</code></a></h1>
<p>В последнем примере мы показали, что мы по собственному 
желанию можем вызвать сбой программы. Мы сказали нашей 
программе вызвать <code>panic</code>, если принцессе подарят 
несоответствующий подарок - змею. Но что если принцесса 
ожидает подарок, но не получает его? Этот случай тоже плохой, так 
что и он должен быть обработан!</p>
<p>Мы <em>можем</em> проверить пустую строку (<code>&quot;&quot;</code>) так же, как мы сделали это со змеёй.
Поскольку мы используем Rust, давайте укажем компилятору случаи, когда подарка нет.</p>
<p>Перечисление (<code>enum</code>) из стандартной библиотеки (<code>std</code>), называющееся <code>Option&lt;T&gt;</code>, используется, когда значение может отсутствовать. Оно проявляется как одна из двух опций (<code>option</code>s):</p>
<ul>
<li><code>Some(T)</code>: элемент типа <code>T</code> найден</li>
<li><code>None</code>: элемент не найден</li>
</ul>
<p>Эти случаи могут быть явно обработаны через  <code>match</code> или неявно с <code>unwrap</code>. Неявная обработка либо вернёт внутренний элемент, либо вызовет <code>panic</code>.</p>
<p>Обратите внимание, что можно вручную настроить сообщение отображаемое при вызове <code>panic</code> с помощью <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect">expect</a>, но <code>unwrap</code> в противном случае оставляет нам менее понятный вывод, чем явная обработка. В следующем примере явная обработка при желании даёт более контролируемый результат, сохраняя при этом возможности <code>panic</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Простолюдин видел всё это, и может справиться с любым подарком хорошо.
// Все подарки обрабатываются с помощью `match`.
fn give_commoner(gift: Option&lt;&amp;str&gt;) {
    // Укажите порядок действий для каждого случая.
    match gift {
        Some(&quot;змея&quot;)  =&gt; println!(&quot;Фу! Я унесу эту змею обратно в лес.&quot;),
        Some(inner)   =&gt; println!(&quot;{}? Как хороший.&quot;, inner),
        None          =&gt; println!(&quot;Нет подарка? Ну что же.&quot;),
    }
}

// Наша защищённая принцесса будет паниковать при виде змей.
// Все подарки обрабатываются неявно через `unwrap`.
fn give_princess(gift: Option&lt;&amp;str&gt;) {
    // `unwrap` вызовет `panic` когда получит `None`.
    let inside = gift.unwrap();
    if inside == &quot;змея&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;Я люблю {}!!!!!&quot;, inside);
}

fn main() {
    let food  = Some(&quot;капуста&quot;);
    let snake = Some(&quot;змея&quot;);
    let void  = None;

    give_commoner(food);
    give_commoner(snake);
    give_commoner(void);

    let bird = Some(&quot;малиновка&quot;);
    let nothing = None;

    give_princess(bird);
    give_princess(nothing);
}
</code></pre></pre>
<h1><a class="header" href="#Комбинаторы-map" id="Комбинаторы-map">Комбинаторы: <code>map</code></a></h1>
<p><code>match</code> - возможный метод для работы с <code>Option</code>.
Однако постоянное его использование может быть утомительным, 
особенно с операциями, которые получают только проверенные 
данные.
В этом случае можно использовать <a href="https://doc.rust-lang.org/book/glossary.html#combinators">комбинаторы</a>, которые 
позволяют управлять потоком выполнения в модульном режиме.</p>
<p><code>Option</code> имеет встроенный метод, зовущийся <code>map()</code>, комбинатор для простого преобразования <code>Some -&gt; Some</code> и <code>None -&gt; None</code>. Для большей гибкости, несколько вызовов <code>map()</code> могут быть связаны друг с другом в цепочку.</p>
<p>В следующем примере, <code>process()</code> заменяет все предшествующие ей функции, оставаясь, при этом, компактной:</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { Apple, Carrot, Potato }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// Очистка продуктов. Если продуктов нет, то возвращаем `None`.
// Иначе вернём очищенные продукты.
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// Нарезка продуктов. Если продуктов нет, то возвращаем `None`.
// Иначе вернём нарезанные продукты.
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// Приготовление еды. Здесь, для обработки вариантов, мы используем 
// `map()` вместо `match`.
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// Функция для последовательной очистки, нарезке и приготовлении продуктов.
// Мы объединили в цепочку несколько вызовов `map()` для упрощения кода.
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

// Проверим, есть ли еда, прежде чем её съесть
fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!(&quot;Ммм. Я люблю {:?}&quot;, food),
        None       =&gt; println!(&quot;О, нет! Это не съедобно.&quot;),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));
    // Давайте сейчас попробуем проще выглядящую `process()`.
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-56" id="Смотрите-также-56">Смотрите также:</a></h3>
<p><a href="error/option_unwrap/../../fn/closures.html">Замыкания</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>Option::map()</code></a></p>
<h1><a class="header" href="#Комбинаторы-and_then" id="Комбинаторы-and_then">Комбинаторы: <code>and_then</code></a></h1>
<p><code>map()</code> описывался как использование цепочек 
функций для упрощения выражения <code>match</code>.
Однако использование <code>map()</code> с функцией, которая в 
качестве результата возвращает <code>Option&lt;T&gt;</code> 
приводит к вложенности <code>Option&lt;Option&lt;T&gt;&gt;</code>. Такая цепочка из множества вызовов в итоге может 
запутать. Вот тут и появляется другой комбинатор, зовущийся 
<code>and_then()</code>, известный в некоторых языках как 
<code>flatmap</code>.</p>
<p><code>and_then()</code> запускает функцию, которая на вход получает обёрнутое значение, а возвращает результирующее 
значение. Если <code>Option</code> равен <code>None</code>, то 
он вернёт <code>None</code>.</p>
<p>В следующем примере, <code>cookable_v2()</code> возвращает<br />
<code>Option&lt;Food&gt;</code>. Используя <code>map()</code> 
вместо <code>and_then()</code> мы получим 
<code>Option&lt;Option&lt;Food&gt;&gt;</code>, который является 
не правильным типом для <code>eat()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

// У нас нет ингридиентов для приготовления Sushi.
fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

// У нас есть рецепты для всего, за исключением Cordon Bleu.
fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}

// Для приготовления блюда нам необходимы и рецепт, и ингредиент.
// Мы можем представить логику, как цепочку из`match`:
fn cookable_v1(food: Food) -&gt; Option&lt;Food&gt; {
    match have_recipe(food) {
        None       =&gt; None,
        Some(food) =&gt; match have_ingredients(food) {
            None       =&gt; None,
            Some(food) =&gt; Some(food),
        },
    }
}

// Для удобства это может быть переписано с использованием более компактного `and_then()`:
fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_recipe(food).and_then(have_ingredients)
}

fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) =&gt; println!(&quot;Yay! В {:?} мы будем есть {:?}.&quot;, day, food),
        None       =&gt; println!(&quot;О, нет. Мы не будем есть в {:?}?&quot;, day),
    }
}

fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-57" id="Смотрите-также-57">Смотрите также:</a></h3>
<p><a href="error/option_unwrap/../../fn/closures.html">Замыкания</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, и <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then"><code>Option::and_then()</code></a></p>
<h1><a class="header" href="#result" id="result"><code>Result</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> является более богатой версией типа <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, тип который описывает возможную <em>ошибку</em> вместо возможного её <em>отсутствия</em>.</p>
<p><code>Result&lt;T, E&gt;</code> имеет два возможных значения:</p>
<ul>
<li><code>Ok&lt;T&gt;</code>: Значение типа <code>T</code></li>
<li><code>Err&lt;E&gt;</code>: Ошибка обработки элемента, типа <code>E</code></li>
</ul>
<p>По соглашению, ожидаемый результат <code>Ok</code>, тогда как не ожидаемый - <code>Err</code>.</p>
<p>Подобно <code>Option</code>, <code>Result</code> имеет множество ассоциированных с ним методов. Например, <code>unwrap()</code> или возвращает <code>T</code>, или вызывает <code>panic</code>. 
Для обработки результата у <code>Result</code> существует множество комбинаторов, которые совпадают с комбинаторами <code>Option</code>.</p>
<p>При работе с Rust вы, скорее всего, столкнётесь с методами, которые возвращают тип Result, например метод parse(). Не всегда
можно разобрать строку в другой тип, поэтому parse() возвращает Result, указывающий на возможный сбой.</p>
<p>Давайте посмотрим, что происходит, когда мы успешно и безуспешно попытаемся преобразовать строку с помощью <code>parse()</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; i32 {
    // Давайте попробуем использовать `unwrap()` чтобы получить число. Он нас укусит?
    let first_number = first_number_str.parse::&lt;i32&gt;().unwrap();
    let second_number = second_number_str.parse::&lt;i32&gt;().unwrap();
    first_number * second_number
}

fn main() {
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    println!(&quot;удовоенное {}&quot;, twenty);

    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    println!(&quot;удвоенное {}&quot;, tt);
}
</code></pre></pre>
<p>При неудаче, <code>parse()</code> оставляет на с ошибкой, с 
которой <code>unwrap()</code> вызывает <code>panic</code>. Дополнительно, <code>panic</code> завершает нашу программу и 
предоставляет неприятное сообщение об ошибке.</p>
<p>Для повышения качества наших сообщений об ошибка, мы должны более явно указать возвращаемый тип и рассмотреть возможной явной обработки ошибок.</p>
<h2><a class="header" href="#Использование-result-в-main" id="Использование-result-в-main">Использование <code>Result</code> в <code>main</code></a></h2>
<p>Также <code>Result</code> может быть возвращаемым типом функции <code>main</code>, если это указано явно. Обычно функция <code>main</code> имеют следующую форму:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>Однако <code>main</code> также может и возвращать тип <code>Result</code>. Если ошибка происходит в пределах функции <code>main</code>, то она возвращает код ошибки и выводит отладочное представление ошибки (используя типаж <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>). Следующий пример показывает такой сценарий и затрагивает аспекты, описанные в <a href="error/result/early_returns.html">последующем разделе</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn main() -&gt; Result&lt;(), ParseIntError&gt; {
    let number_str = &quot;10&quot;;
    let number = match number_str.parse::&lt;i32&gt;() {
        Ok(number)  =&gt; number,
        Err(e) =&gt; return Err(e),
    };
    println!(&quot;{}&quot;, number);
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#map-для-result" id="map-для-result"><code>map</code> для <code>Result</code></a></h1>
<p>Паника в предыдущем примере делает код ненадёжным.
Обычно, мы хотим вернуть ошибку вызывающей стороне, чтобы 
уже она решала, как с ней поступить.</p>
<p>Первое, что нам нужно знать - это с каким типом ошибки мы 
работаем. Для определения типа <code>Err</code>, мы посмотрим 
на <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a>, реализованную с типажом 
<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> для <a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>.
В результате, тип <code>Err</code> указан как 
<a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>.</p>
<p>В примере ниже, простой <code>match</code> делает код более громоздким.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// Мы используем сопоставление с образцом без `unwrap()` и меняем тип результата.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; {
            match second_number_str.parse::&lt;i32&gt;() {
                Ok(second_number)  =&gt; {
                    Ok(first_number * second_number)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n равно {}&quot;, n),
        Err(e) =&gt; println!(&quot;Ошибка: {}&quot;, e),
    }
}

fn main() {
    // Это даёт разумный ответ.
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // Следующее теперь предоставляет более понятное сообщение об ошибке.
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<p>К счастью, <code>map</code>, <code>and_then</code> многие 
другие комбинаторы <code>Option</code> также реализованы и 
для <code>Result</code>. 
<a href="https://doc.rust-lang.org/std/result/enum.Result.html" data-md-type="link">Документация по <code>Result</code></a> содержит полный 
их список.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// Как и с `Option`, мы можем использовать комбинаторы, как `map()`.
// Эта функция в основном идентична предыдущей и читается как:
// изменяем n при валидном значении, иначе передаём ошибку.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n равно {}&quot;, n),
        Err(e) =&gt; println!(&quot;Ошибка: {}&quot;, e),
    }
}

fn main() {
    // Это даёт разумный ответ.
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // Следующее теперь предоставляет более понятное сообщение об ошибке.
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<h1><a class="header" href="#Псевдонимы-для-result" id="Псевдонимы-для-result">Псевдонимы для <code>Result</code></a></h1>
<p>Как насчёт случая, когда мы хотим использовать конкретный тип <code>Result</code> много раз?
Напомним, что Rust позволяет нам создавать <a href="error/result/types/alias.html">псевдонимы</a>. Мы можем
удобно объявить псевдоним для конкретного <code>Result</code>.</p>
<p>Особенно полезным может быть создание псевдонимов на уровне модулей. Ошибки,
найденные в конкретном модуле, часто имеют один и тот же тип <code>Err</code>, поэтому один
псевдоним может лаконично объявить <em>все</em> ассоциированные <code>Results</code>.
Это настолько полезно, что библиотека <code>std</code> обеспечивает даже один: <code>io::Result</code>!</p>
<p>Ниже приведён краткий пример для демонстрации синтаксиса:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// Объявим обобщённый псевдоним для `Result` с типом ошибки `ParseIntError`.
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// Используем вышеуказанный псевдоним для обозначения
// нашего конкретного типа `Result`.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

// Здесь псевдоним снова позволяет нам сэкономить место.
fn print(result: AliasedResult&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n это {}&quot;, n),
        Err(e) =&gt; println!(&quot;Ошибка: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-58" id="Смотрите-также-58">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a></p>
<h1><a class="header" href="#Ранний-выход" id="Ранний-выход">Ранний выход</a></h1>
<p>В предыдущем примере мы явно обработали ошибки при помощи комбинаторов.
Другой способ сделать это - использовать комбинацию выражения 
<code>match</code> и <em>раннего выхода</em>.</p>
<p>Таким образом мы просто можем остановить работу функции и 
вернуть ошибку, если она произошла. Для некоторых, такой код 
будет легче в чтении и написании. Посмотрите код из предыдущего 
примера, переписанный с использованием раннего выхода:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; first_number,
        Err(e) =&gt; return Err(e),
    };

    let second_number = match second_number_str.parse::&lt;i32&gt;() {
        Ok(second_number)  =&gt; second_number,
        Err(e) =&gt; return Err(e),
    };

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n равно {}&quot;, n),
        Err(e) =&gt; println!(&quot;Ошибка: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<p>На данный момент, мы изучили обработку ошибок при помощи 
комбинаторов и раннего выхода. Мы хотим избежать паники, но 
явная обработка всех ошибок достаточно громоздка.</p>
<p>В следующем разделе, мы познакомимся с <code>?</code> для 
случаев, где нам просто хотим сделать <code>unwrap</code> без 
возможности вызова <code>panic</code>.</p>
<h1><a class="header" href="#Представляем-" id="Представляем-">Представляем: <code>?</code></a></h1>
<p>Иногда мы хотим получить простоту <code>unwrap</code>, но без 
<code>panic</code>. До текущего момента <code>unwrap</code> 
заставлял нас делать всё больше и больше, в то время как мы 
хотели только <em>извлечь</em> переменную. Для этих целей был 
введён <code>?</code>.</p>
<p>При обнаружении <code>Err</code>, можно выполнить два действия:</p>
<ol>
<li><code>panic!</code>, который мы решили по возможности избегать </li>
<li><code>return</code> так как возврат <code>Err</code> говорит о том, что мы её не обрабатывали</li>
</ol>
<p><code>?</code> <em>почти</em><sup class="footnote-reference"><a href="#†">1</a></sup> эквивалентен
<code>unwrap</code>, который при <code>Err</code> делает 
<code>return</code> вместо <code>panic</code>. Давайте 
посмотрим как мы можем упростить наш пример, использующий 
комбинаторы:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = first_number_str.parse::&lt;i32&gt;()?;
    let second_number = second_number_str.parse::&lt;i32&gt;()?;

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n равно {}&quot;, n),
        Err(e) =&gt; println!(&quot;Ошибка: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h2><a class="header" href="#Макрос-try" id="Макрос-try">Макрос <code>try!</code></a></h2>
<p>До появления <code>?</code>, аналогичная функциональность 
была доступна через макрос <code>try!</code>.
Сейчас рекомендуется использовать оператор <code>?</code>, но 
вы до сих пор можете найти <code>try!</code>, когда 
просматриваете старый код. Функция <code>multiply</code> из 
предыдущего примера с использованием <code>try!</code> будет 
выглядеть следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Для компиляции и запуска с помощью Cargo этого примера без ошибок
// поменяйте в `Cargo.toml` значение поля `edition` секции 
// `[package]` на &quot;2015&quot;.

use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = try!(first_number_str.parse::&lt;i32&gt;());
    let second_number = try!(second_number_str.parse::&lt;i32&gt;());

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n равно {}&quot;, n),
        Err(e) =&gt; println!(&quot;Ошибка: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<div class="footnote-definition" id="†"><sup class="footnote-definition-label">1</sup>
<p>Посмотрите главу <a href="error/result/../multiple_error_types/reenter_question_mark.html">&quot;Другие способы использования <code>?</code>&quot;</a> для большей информации.</p>
</div>
<h1><a class="header" href="#Несколько-типов-ошибок" id="Несколько-типов-ошибок">Несколько типов ошибок</a></h1>
<p>Предыдущие примеры всегда были очень удобны:  <code>Result</code> взаимодействовали с другими <code>Result</code>, а <code>Option</code> - с другими <code>Option</code>.</p>
<p>Иногда <code>Option</code> необходимо взаимодействовать с 
<code>Result</code>, или <code>Result&lt;T, Error1&gt;</code> с 
<code>Result&lt;T, Error2&gt;</code>. В этих случаях, нам нужно 
управлять этими разными типами ошибок таким образом, чтобы 
можно было их компоновать и легко взаимодействовать с ними.</p>
<p>В следующем коде, два варианта <code>unwrap</code> 
генерируют разные типы ошибок. <code>Vec::first</code> 
возвращает <code>Option</code>, в то время как 
<code>parse::&lt;i32&gt;</code> возвращает 
<code>Result&lt;i32, ParseIntError&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // Генерирует ошибку 1
    2 * first.parse::&lt;i32&gt;().unwrap() // Генерирует ошибку 2
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;Первое удвоенное {}&quot;, double_first(numbers));

    println!(&quot;Первое удвоенное {}&quot;, double_first(empty));
    // Ошибка 1: входной вектор пустой

    println!(&quot;Первое удвоенное {}&quot;, double_first(strings));
    // Ошибка 2: элемент не может быть преобразован в число
}
</code></pre></pre>
<p>В следующих главах мы рассмотрим различные стратегии обработки этих типов проблем.</p>
<h1><a class="header" href="#Извлечение-result-из-option" id="Извлечение-result-из-option">Извлечение <code>Result</code> из <code>Option</code></a></h1>
<p>Наиболее простой способ обработки ошибок разных типов - это встраивание их друг в друга.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Option&lt;Result&lt;i32, ParseIntError&gt;&gt; {
    vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    })
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;Первое удвоенное: {:?}&quot;, double_first(numbers));

    println!(&quot;Первое удвоенное: {:?}&quot;, double_first(empty));
    // Ошибка первая: исходный вектор пустой

    println!(&quot;Первое удвоенное {:?}&quot;, double_first(strings));
    // Ошибка вторая: элемент не переводится в число
}
</code></pre></pre>
<p>Бывает, мы хотим приостановить работу при ошибке (как при 
помощи оператора <a href="error/multiple_error_types/../result/enter_question_mark.html"><code>?</code></a>), но продолжать 
работать, если <code>Option</code> <code>None</code>. Есть 
пара комбинаторов, которые поменяют местами 
<code>Result</code> и <code>Option</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;Option&lt;i32&gt;, ParseIntError&gt; {
    let opt = vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    });

    let opt = opt.map_or(Ok(None), |r| r.map(Some))?;

    Ok(opt)
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;Первое удвоенное: {:?}&quot;, double_first(numbers));
    println!(&quot;Первое удвоенное: {:?}&quot;, double_first(empty));
    println!(&quot;Первое удвоенное: {:?}&quot;, double_first(strings));
}
</code></pre></pre>
<h1><a class="header" href="#Объявление-типа-ошибки" id="Объявление-типа-ошибки">Объявление типа ошибки</a></h1>
<p>Иногда для упрощения кода необходимо скрыть все типы ошибок за какой-то одной ошибкой. Мы скроем их за пользовательской ошибкой.</p>
<p>Rust позволяет нам определить наш собственный тип ошибок. 
В общем случае &quot;хороший&quot; тип ошибки должен:</p>
<ul>
<li>Представлять разные ошибки с таким же типом</li>
<li>Предоставлять хорошее сообщение об ошибке пользователю</li>
<li>Легко сравниваться с другими типами
<ul>
<li>Хорошо: <code>Err(EmptyVec)</code></li>
<li>Плохо: <code>Err(&quot;Пожалуйста, используйте вектор хотя бы с одним элементом&quot;.to_owned())</code></li>
</ul>
</li>
<li>Содержать информацию об ошибке
<ul>
<li>Хорошо: <code>Err(BadChar(c, position))</code></li>
<li>Плохо: <code>Err(&quot;+ не может быть использован в данном месте&quot;.to_owned())</code></li>
</ul>
</li>
<li>Хорошо сочетаться с другими ошибками</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

// Определите типы ошибок. Они могут быть настроены для наших случаев обработки ошибок.
// Теперь мы сможем написать наши собственные ошибки, реализовать приведение до основной ошибки
// или сделать что-то ещё между приведениями.
#[derive(Debug, Clone)]
struct DoubleError;

// Генерация ошибки полностью отделена от того, как она отображается.
// Нет необходимости в загромождении сложной логикой построения отображения ошибки.
//
// Мы не храним дополнительной информации об ошибках. Это означает, что мы не можем вывести строку, которую не удалось обработать, без изменения наших типов.
impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;неверный первый элемент&quot;)
    }
}

// Все ошибки сворачиваются в одну.
impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        // Общая ошибка не обрабатывается.
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        // Изменим ошибку на наш новый тип.
        .ok_or(DoubleError)
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                // Обновим тип ошибки также здесь.
                .map_err(|_| DoubleError)
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!(&quot;Первое удвоение {}&quot;, n),
        Err(e) =&gt; println!(&quot;Ошибка: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<h1><a class="header" href="#Упаковка-ошибок-box" id="Упаковка-ошибок-box">Упаковка ошибок (<code>Box</code>)</a></h1>
<p>Чтобы написать простой код и при этом использовать 
оригинальные ошибки, необходимо упаковать 
(<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>) их.
Минусом данного способа является то, что тип ошибок известен 
только во время выполнения программы, а не <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">определён 
статически</a>.</p>
<p>Стандартная библиотека помогает упаковывать наши ошибки.
Это достигается за счёт того, что для <code>Box</code> 
реализована конвертация из любого типа, реализующего типаж 
<code>Error</code>, в типаж-объект <code>Box&lt;Error&gt;</code> 
через <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::fmt;

// Создадим псевдоним с типом ошибки `Box&lt;error::Error&gt;`.
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;error::Error&gt;&gt;;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;неверный первый элемент&quot;)
    }
}

impl error::Error for EmptyVec {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;неверный первый элемент&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        // Общая ошибка, основная причина не отслеживается.
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        .ok_or_else(|| EmptyVec.into()) // Упаковка (преобразование в Box)
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                .map_err(|e| e.into()) // Упаковка (преобразование в Box)
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!(&quot;Удвоенный первый элемент: {}&quot;, n),
        Err(e) =&gt; println!(&quot;Ошибка: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-59" id="Смотрите-также-59">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">Динамическая диспетчеризация</a> и <a href="https://doc.rust-lang.org/std/error/trait.Error.html">типаж <code>Error</code></a></p>
<h1><a class="header" href="#Другие-способы-использования-" id="Другие-способы-использования-">Другие способы использования <code>?</code></a></h1>
<p>Вы обратили внимание, что сразу же после вызова 
<code>parse</code>, мы в <code>map_err</code> упаковали ошибку 
из библиотеки?</p>
<pre><code class="language-rust ignore">.and_then(|s| s.parse::&lt;i32&gt;()
    .map_err(|e| e.into())
</code></pre>
<p>Это простая и распространённая операция и было бы не плохо, 
если бы мы могли её опустить. Но из-за того, что 
<code>and_then</code> недостаточно гибок, мы не можем этого 
сделать. Однако, тут нам может помочь <code>?</code>.</p>
<p>Ранее <code>?</code> был рассмотрен как <code>unwrap</code> 
или <code>return Err(err)</code>. По большей части это правда: на 
самом деле <code>?</code> означает <code>unwrap</code> или 
<code>return Err(From::from(err))</code>. Поскольку 
<code>From::from</code> используется для преобразования между 
разными типами, применение <code>?</code> к ошибке 
автоматически преобразует её в возвращаемый тип (при условии, 
что исходная ошибка может быть в него преобразована).</p>
<p>Теперь мы перепишем наш предыдущий пример с использованием 
<code>?</code>. В результате у нас пропал <code>map_err</code>, 
так как для нашего типа реализован <code>From::from</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::fmt;

// Создадим псевдоним с типом ошибки `Box&lt;error::Error&gt;`.
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;error::Error&gt;&gt;;

#[derive(Debug)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;неверный первый элемент&quot;)
    }
}

impl error::Error for EmptyVec {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;неверный первый элемент&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        // Общая ошибка, основная причина не отслеживается.
        None
    }
}

// Такая же последовательность, как и раньше, но вместо объединения 
// всех `Result` и `Option`, мы используем `?` чтобы незамедлительно 
// получить внутреннее значение.
fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;
    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;Удвоенный первый элемент: {}&quot;, n),
        Err(e) =&gt; println!(&quot;Ошибка: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>Сейчас код выглядит довольно чисто. По сравнению с 
<code>panic</code>, это похоже на замену вызова 
<code>unwrap</code> на <code>?</code> за исключением того, что 
возвращаемый тип будет <code>Result</code>. В результате, он 
может быть обработан уровнем выше.</p>
<h3><a class="header" href="#Смотрите-также-60" id="Смотрите-также-60">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a> и <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator"><code>?</code></a></p>
<h1><a class="header" href="#Оборачивание-ошибок" id="Оборачивание-ошибок">Оборачивание ошибок</a></h1>
<p>Альтернативой упаковке ошибок является оборачивание их в ваш собственный тип.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // Мы не будем обрабатывать ошибку разбора сами, а передадим её в программу.
    // Предоставление дополнительной информации требует добавления дополнительных данных к типу
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;пожалуйста используйте вектор хотя бы с одним элементом&quot;),
            // Это адаптер, так что обратимся к нижележащей реализации `fmt`.
            DoubleError::Parse(ref e) =&gt; e.fmt(f),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // Причиной ошибки является адаптированный тип. Здесь происходит
            // неявное преобразование к типажу `&amp;error::Error`. Это работает
            // так как основной тип реализует типаж `Error`.
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// Реализуем преобразование из `ParseIntError` в `DoubleError`.
// Это преобразование будет автоматически вызвано оператором `?`, 
// если будет необходимо преобразовать `ParseIntError` в `DoubleError`.
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;Первое удвоение {}&quot;, n),
        Err(e) =&gt; println!(&quot;Ошибка: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>Это добавляет чуть больше шаблонного кода для обработки ошибок 
и может быть не нужно всем приложениям. Есть библиотеки, 
которые могут избавить вас от написания этого шаблонного кода.</p>
<h3><a class="header" href="#Смотрите-также-61" id="Смотрите-также-61">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a> и <a href="error/multiple_error_types/../../custom_types/enum.html"><code>Enums</code></a></p>
<h1><a class="header" href="#Итерирование-по-result" id="Итерирование-по-result">Итерирование по <code>Result</code></a></h1>
<p>При работе метода <code>Iter::map</code> может случиться ошибка, например:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Результаты: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>Давайте рассмотрим стратегии обработки этого.</p>
<h2><a class="header" href="#Игнорирование-неудачных-элементов-с-filter_map" id="Игнорирование-неудачных-элементов-с-filter_map">Игнорирование неудачных элементов с <code>filter_map()</code></a></h2>
<p><code>filter_map</code> вызывает функцию и отфильтровывает результаты, вернувшие <code>None</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .filter_map(Result::ok)
        .collect();
    println!(&quot;Результаты: {:?}&quot;, numbers);
}
</code></pre></pre>
<h2><a class="header" href="#Сбой-всей-операции-с-collect" id="Сбой-всей-операции-с-collect">Сбой всей операции с <code>collect()</code></a></h2>
<p><code>Result</code> реализует <code>FromIter</code> так что вектор из результатов (<code>Vec&lt;Result&lt;T, E&gt;&gt;</code>)
может быть преобразован в результат с вектором (<code>Result&lt;Vec&lt;T&gt;, E&gt;</code>). Если будет найдена хотя бы одна <code>Result::Err</code>, итерирование завершится.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Результаты: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>Та же самая техника может использоваться с <code>Option</code>.</p>
<h2><a class="header" href="#Сбор-всех-корректных-значений-и-ошибок-с-помощью-partition" id="Сбор-всех-корректных-значений-и-ошибок-с-помощью-partition">Сбор всех корректных значений и ошибок с помощью <code>partition()</code></a></h2>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    println!(&quot;Числа: {:?}&quot;, numbers);
    println!(&quot;Ошибки: {:?}&quot;, errors);
}
</code></pre></pre>
<p>Если вы посмотрите на результаты работы, вы заметите, что они всё ещё обёрнуты в <code>Result</code>. Потребуется немного больше шаблонного кода, чтобы получить нужный результат.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!(&quot;Числа: {:?}&quot;, numbers);
    println!(&quot;Ошибки: {:?}&quot;, errors);
}
</code></pre></pre>
<h1><a class="header" href="#Типы-стандартной-библиотеки" id="Типы-стандартной-библиотеки">Типы стандартной библиотеки</a></h1>
<p>Стандартная библиотека (<code>std</code>) предоставляет множество пользовательских типов, которые значительно
расширяют <code>примитивы</code>. Некоторые из них:</p>
<ul>
<li>расширяемую строку <code>String</code>s: <code>&quot;hello world&quot;</code></li>
<li>динамический массив: <code>[1, 2, 3]</code></li>
<li>опциональные типы: <code>Option&lt;i32&gt;</code></li>
<li>типы для обработки ошибок: <code>Result&lt;i32, i32&gt;</code></li>
<li>указатели на объекты в куче: <code>Box&lt;i32&gt;</code></li>
</ul>
<h3><a class="header" href="#Смотрите-также-62" id="Смотрите-также-62">Смотрите также:</a></h3>
<p><a href="primitives.html">Примитивы</a> и <a href="https://doc.rust-lang.org/std/"><code>std</code></a></p>
<h1><a class="header" href="#box-стек-и-куча" id="box-стек-и-куча"><code>Box</code>, стек и куча</a></h1>
<p>Все значения в Rust по умолчанию аллоцируются на стеке. Значения могут быть <em>упакованы</em>
(аллоцированы в куче) при помощи создания <code>Box&lt;T&gt;</code>. <code>Box</code> - это умный указатель на аллоцированное в куче значение типа <code>T</code>. Когда <code>Box</code> покидает область видимости, вызывается его деструктор, который уничтожает внутренний объект, и занятая им память в куче освобождается.</p>
<p>Упакованные значения могут быть разыменованы с помощью операции <code>*</code>.
Эта операция убирает один уровень косвенности.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::mem;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

#[allow(dead_code)]
struct Rectangle {
    p1: Point,
    p2: Point,
}

fn origin() -&gt; Point {
    Point { x: 0.0, y: 0.0 }
}

fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // Аллоцировать эту точку в куче и вернуть указатель на неё
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() {
    // (все аннотации типов избыточны)
    // Переменные, аллоцированные на стеке
    let point: Point = origin();
    let rectangle: Rectangle = Rectangle {
        p1: origin(),
        p2: Point { x: 3.0, y: 4.0 }
    };

    // Прямоугольник, аллоцированный в куче
    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
        p1: origin(),
        p2: origin()
    });

    // Результат функции может быть упакован
    let boxed_point: Box&lt;Point&gt; = Box::new(origin());

    // Двойная косвенность
    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

    println!(&quot;Точка занимает {} байт на стеке&quot;,
             mem::size_of_val(&amp;point));
    println!(&quot;Прямоугольник занимает {} байт на стеке&quot;,
             mem::size_of_val(&amp;rectangle));

    // box size == pointer size
    println!(&quot;Упакованная точка занимает {} байт на стеке&quot;,
             mem::size_of_val(&amp;boxed_point));
    println!(&quot;Упакованный прямоугольник занимает {} байт на стеке&quot;,
             mem::size_of_val(&amp;boxed_rectangle));
    println!(&quot;Упакованная 'упаковка' занимает {} байт на стеке&quot;,
             mem::size_of_val(&amp;box_in_a_box));

    // Копируем данные из `boxed_point` в `unboxed_point`
    let unboxed_point: Point = *boxed_point;
    println!(&quot;Распакованная точка занимает {} байт на стеке&quot;,
             mem::size_of_val(&amp;unboxed_point));
}
</code></pre></pre>
<h1><a class="header" href="#Вектора" id="Вектора">Вектора</a></h1>
<p>Вектора - это массивы изменяемого размера. Их размер, как и у 
срезов, не известен во время компиляции, но он может в любое 
время расширяться. Вектора представляются при помощи 3 
параметров:</p>
<ul>
<li>указатель на данные</li>
<li>длина</li>
<li>вместимость</li>
</ul>
<p>Вместимость показывает сколько памяти зарезервировано для 
вектора. Вектор может расти до тех пор, пока его длина меньше 
вместимости. Если при следующей вставке порог может быть 
превышен, под вектор выделяется больше памяти и данные переносятся в новый вектор.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Итераторы могут быть собраны в вектора
    let collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!(&quot;(0..10) собраны в: {:?}&quot;, collected_iterator);

    // Макрос `vec!` может быть использован для инициализации вектора
    let mut xs = vec![1i32, 2, 3];
    println!(&quot;Исходный вектор: {:?}&quot;, xs);

    // Вставка нового элемента в конец вектора
    println!(&quot;Добавим 4 в конец вектора&quot;);
    xs.push(4);
    println!(&quot;Вектор: {:?}&quot;, xs);

    // Ошибка! Неизменяемые вектора не могут увеличиваться
    collected_iterator.push(0);
    // ИСПРАВЬТЕ ^ Закомментируйте эту строку

    // Метод `len` отдаёт количество элементом, сохранённых в векторе
    println!(&quot;Длина вектора: {}&quot;, xs.len());

    // Индексация выполняется при помощи квадратных скобок (индексация начинается с 0)
    println!(&quot;Второй элемент: {}&quot;, xs[1]);

    // `pop` удаляет последний элемент из вектора и возвращает его
    println!(&quot;Последний элемент: {:?}&quot;, xs.pop());

    // Выход за пределы индексации вызывает панику
    println!(&quot;Четвёртый элемент: {}&quot;, xs[3]);
    // ИСПРАВЬТЕ ^ Закомментируйте эту строку

    // По векторами легко итерироваться
    println!(&quot;Содержимое `xs`:&quot;);
    for x in xs.iter() {
        println!(&quot;&gt; {}&quot;, x);
    }

    // Также можно итерироваться по вектору с получением индекса элемента
    // (который будет содержаться в отдельной переменной `i`)
    for (i, x) in xs.iter().enumerate() {
        println!(&quot;{}-ый элемент имеет значение {}&quot;, i, x);
    }

    // Благодаря `iter_mut`, у изменяемых векторов можно менять значения
    // во время итерирования
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!(&quot;Обновлённый вектор: {:?}&quot;, xs);
}
</code></pre></pre>
<p>Подробную информацию о методах объекта Vec
можно почитать в разделе модуля std::vec</p>
<h1><a class="header" href="#Строки" id="Строки">Строки</a></h1>
<p>В Rust есть два типа строк: <code>String</code> и <code>&amp;str</code>.</p>
<p><code>String</code> сохраняется как вектор байт 
(<code>Vec&lt;u8&gt;</code>), но с гарантией, что это всегда будет 
действительная UTF-8 последовательность. <code>String</code> 
выделяется в куче, расширяемая и не заканчивается нулевым байтом 
(не null-terminated).</p>
<p><code>&amp;str</code> - это срез (<code>&amp;[u8]</code>), 
который всегда указывает на действительную UTF-8 
последовательность, и является отображением 
<code>String</code>, так же как и <code>&amp;[T]</code> - 
отображение <code>Vec&lt;T&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // (все аннотации типов избыточны)
    // Ссылка на строку, размещённую в read-only памяти
    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
    println!(&quot;Pangram: {}&quot;, pangram);

    // Итерируемся по словам в обратном прядке, новая строка не аллоцируется
    println!(&quot;Words in reverse&quot;);
    for word in pangram.split_whitespace().rev() {
        println!(&quot;&gt; {}&quot;, word);
    }

    // Копируем символы в вектор, сортируем и удаляем дубликаты
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // Создаём пустую расширяемую `String`
    let mut string = String::new();
    for c in chars {
        // Добавляем символ в конец строки
        string.push(c);
        // Добавляем в конец строки другую строку
        string.push_str(&quot;, &quot;);
    }

    // Усечённая строка - это срез оригинальной строки, а значит новых 
    // аллокаций не производится
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!(&quot;Used characters: {}&quot;, trimmed_str);

    // Строка, аллоцированная в куче
    let alice = String::from(&quot;I like dogs&quot;);
    // Выделяется новая память, в которую сохраняется модифицированная строка
    let bob: String = alice.replace(&quot;dog&quot;, &quot;cat&quot;);

    println!(&quot;Alice says: {}&quot;, alice);
    println!(&quot;Bob says: {}&quot;, bob);
}
</code></pre></pre>
<p>Больше методов <code>str</code> и <code>String</code> вы 
можете найти в описании модулей <a href="https://doc.rust-lang.org/std/str/">std::str</a> и 
<a href="https://doc.rust-lang.org/std/string/">std::string</a>.</p>
<h2><a class="header" href="#Литералы-и-экранирование" id="Литералы-и-экранирование">Литералы и экранирование</a></h2>
<p>Есть несколько способов написать строковый литерал со 
специальными символами в нём. Все способы приведут к одной и 
той же строке, так что лучше использовать тот способ, который 
легче всего написать. Аналогично все способы записать строковый 
литера из байтов в итоге дадут <code>&amp;[u8; N]</code>.</p>
<p>Обычно специальные символы экранируются с помощью обратной косой черты: <code>Обычно специальные символы экранируются с помощью обратной косой черты: . В этом случае вы можете добавить в вашу  строку любые символы, даже непечатаемые и те, которые вы не  знаете как набрать. Если вы хотите добавить обратную косую черту,  экранируйте его с помощью ещё одной: </code>`.</p>
<p>Строковые или символьные разделители литералов (кавычки, встречающиеся внутри другого литерала, должны быть экранированы: <code>&quot;\&quot;&quot;</code>, <code>'.'</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // You can use escapes to write bytes by their hexadecimal values...
    let byte_escape = &quot;I'm writing \x52\x75\x73\x74!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // ...or Unicode code points.
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );


    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<p>Иногда приходится экранировать слишком много символов или 
легче записать строку как она есть. В этот момент в игру вступают 
сырые строковые литералы.</p>
<pre><pre class="playpen"><code class="language-rust ">fn main() {
    let raw_str = r&quot;Экранирование здесь не работает: \x3F \u{211D}&quot;;
    println!(&quot;{}&quot;, raw_str);

    // Если вам необходимы кавычки с сырой строке, добавьте пару `#`
    let quotes = r#&quot;И затем я сказал: &quot;Здесь нет экранирования!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // Если вам необходимо добавить в вашу строку `&quot;#`, то просто добавьте больше `#` в разделитель.
    // Здесь нет ограничений на количество `#` которое вы можете использовать.
    let longer_delimiter = r###&quot;Строка с &quot;# внутри неё. И даже с &quot;##!&quot;###;
    println!(&quot;{}&quot;, longer_delimiter);
}
</code></pre></pre>
<p>Хотите строку, которая не UTF-8? (Помните, <code>str</code> и 
<code>String</code> должны содержать действительные UTF-8 
последовательности). Или возможно вы хотите массив байтов, 
которые в основном текст? Байтовые строки вас спасут!</p>
<pre><pre class="playpen"><code class="language-rust ">use std::str;

fn main() {
    // Note that this is not actually a `&amp;str`
    let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;;

    // Byte arrays don't have the `Display` trait, so printing them is a bit limited
    println!(&quot;A byte string: {:?}&quot;, bytestring);

    // Byte strings can have byte escapes...
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...but no unicode escapes
    // let escaped = b&quot;\u{211D} is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // Raw byte strings work just like raw strings
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // Converting a byte array to `str` can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // Byte strings don't have to be UTF-8
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82&quot;; // &quot;ようこそ&quot; in SHIFT-JIS

    // But then they can't always be converted to `str`
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}
</code></pre></pre>
<p>Для преобразования между кодировками символов, посмотрите крейт <a href="https://crates.io/crates/encoding">encoding</a>.</p>
<p>Более детальный список способов записи строковых литералов и 
экранирования символов можно найти в <a href="https://doc.rust-lang.org/reference/tokens.html">главе 'Tokens'</a> Rust Reference.</p>
<h1><a class="header" href="#option" id="option"><code>Option</code></a></h1>
<p>Иногда желательно перехватить ошибку в какой-либо части программы
вместо вызова паники с помощью макроса <code>panic!</code>. Это можно сделать
с помощью перечисления <code>Option</code>.</p>
<p>Перечисление <code>Option&lt;T&gt;</code> имеет два варианта:</p>
<ul>
<li><code>None</code>, указывающий о наличии ошибки или отсутствия значений</li>
<li><code>Some(value)</code>, кортежная структура, обёртка для <code>значения</code> типа <code>T</code>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Целочисленное деление, которое не вызывает `panic!`
fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor == 0 {
        // В случае ошибки возвращаем `None`
        None
    } else {
        // Результат деления возвращаем в варианте `Some`
        Some(dividend / divisor)
    }
}

// Эта функция обрабатывает деление, которое может выполнится с ошибкой
fn try_division(dividend: i32, divisor: i32) {
    // Значение типа `Option` могут быть сопоставлены по шаблону
    match checked_division(dividend, divisor) {
        None =&gt; println!(&quot;{} / {} вызвало ошибку!&quot;, dividend, divisor),
        Some(quotient) =&gt; {
            println!(&quot;{} / {} = {}&quot;, dividend, divisor, quotient)
        },
    }
}

fn main() {
    try_division(4, 2);
    try_division(1, 0);

    // Привязка `None` к переменной должна быть аннотированной по типу
    let none: Option&lt;i32&gt; = None;
    let _equivalent_none = None::&lt;i32&gt;;

    let optional_float = Some(0f32);

    // Распаковка варианта `Some` будет извлекать данные, которые в нем находятся.
    println!(&quot;{:?} распаковывается в {:?}&quot;, optional_float, optional_float.unwrap());

    // Распаковка варианта `None` вызовет `panic!`
    println!(&quot;{:?} распаковывается в {:?}&quot;, none, none.unwrap());
}
</code></pre></pre>
<h1><a class="header" href="#result-1" id="result-1"><code>Result</code></a></h1>
<p>Раньше мы видели, что в качестве возвращаемого значения из 
функции, которая может завершиться с ошибкой, можно использовать 
перечисление <code>Option</code>, в котором <code>None</code> 
будет обозначать неудачу. Однако иногда важно понять 
<em>почему</em> операция потерпела неудачу. Для этого у нас есть 
перечисление <code>Result</code>.</p>
<p>Перечисление <code>Result&lt;T, E&gt;</code> имеет два варианта:</p>
<ul>
<li><code>Ok(value)</code>, который обозначает, что операция успешно завершилась, и оборачивает значение (<code>value</code>), возвращаемое операцией (<code>value</code> имеет тип <code>T</code>).</li>
<li><code>Err(why)</code>, который показывает, что операция потерпела неудачу, оборачивает значение ошибки (причину, <code>why</code>), которое (надеемся) описывает причину неудачи. <code>why</code> имеет тип <code>E</code>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    // Математические &quot;ошибки&quot;, которые мы хотим отлавливать
    #[derive(Debug)]
    pub enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    pub type MathResult = Result&lt;f64, MathError&gt;;

    pub fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            // При таком значение операция потерпит неудачу.
            // Вместо этого давайте вернём ошибку, обёрнутую в `Err`
            Err(MathError::DivisionByZero)
        } else {
            // Эта операция возможна, так что вернём результат, обёрнутый в `Ok`
            Ok(x / y)
        }
    }

    pub fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    pub fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }
}

// `op(x, y)` === `sqrt(ln(x / y))`
fn op(x: f64, y: f64) -&gt; f64 {
    // Это трёхуровневая пирамида из `match`!
    match checked::div(x, y) {
        Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
        Ok(ratio) =&gt; match checked::ln(ratio) {
            Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
            Ok(ln) =&gt; match checked::sqrt(ln) {
                Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
                Ok(sqrt) =&gt; sqrt,
            },
        },
    }
}

fn main() {
    // Потерпит ли это неудачу?
    println!(&quot;{}&quot;, op(1.0, 10.0));
}
</code></pre></pre>
<h1><a class="header" href="#" id=""><code>?</code></a></h1>
<p>Разбор цепочки результатов с использованием <code>match</code> может стать 
довольно неопрятной, к счастью, с помощью оператора 
<code>?</code> можно сделать разбор снова красивым. 
<code>?</code> используется в конце выражения, возвращающего 
<code>Result</code> и эквивалентен выражению <code>match</code>, в котором 
ветка <code>Err(err)</code> разворачивается в 
<code>Err(From::from(err))</code>, а ветка <code>Ok(ok)</code> во 
внутреннее значение (<code>ok</code>).</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    type MathResult = Result&lt;f64, MathError&gt;;

    fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(x / y)
        }
    }

    fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }

    // Промежуточная функция
    fn op_(x: f64, y: f64) -&gt; MathResult {
        // Если `div` &quot;упадёт&quot;, тогда будет &quot;возвращено&quot; `DivisionByZero`
        let ratio = div(x, y)?;

        // если `ln` &quot;упадёт&quot;, тогда будет &quot;возвращено&quot; `NonPositiveLogarithm`
        let ln = ln(ratio)?;

        sqrt(ln)
    }

    pub fn op(x: f64, y: f64) {
        match op_(x, y) {
            Err(why) =&gt; panic!(match why {
                MathError::NonPositiveLogarithm
                    =&gt; &quot;логарифм не положительного числа&quot;,
                MathError::DivisionByZero
                    =&gt; &quot;деление на ноль&quot;,
                MathError::NegativeSquareRoot
                    =&gt; &quot;квадратный корень от отрицательного числа&quot;,
            }),
            Ok(value) =&gt; println!(&quot;{}&quot;, value),
        }
    }
}

fn main() {
    checked::op(1.0, 10.0);
}
</code></pre></pre>
<p>Обязательно посмотрите <a href="https://doc.rust-lang.org/std/result/index.html">документацию</a>, так как есть много 
методов для работы с <code>Result</code>.</p>
<h1><a class="header" href="#panic-1" id="panic-1"><code>panic!</code></a></h1>
<p>Макрос <code>panic!</code> используется для генерации паники и раскрутки стека.
Во время раскрутки стека, среда выполнения возьмёт на себя всю ответственность по
освобождению ресурсов, которыми <em>владеет</em> текущий поток, вызывая деструкторы
всех объектов.</p>
<p>Так как в данном случае мы имеем дело с однопоточной программой, <code>panic!</code> заставит
программу вывести сообщение с ошибкой и завершится.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Реализуем свою версию целочисленного деления (/)
fn division(dividend: i32, divisor: i32) -&gt; i32 {
    if divisor == 0 {
       // Деление на ноль вызывает панику
        panic!(&quot;Деление на ноль!&quot;);
    } else {
        dividend / divisor
    }
}

// Основной поток `main`
fn main() {
    // Целочисленное значение, выделенное в куче
    let _x = Box::new(0i32);

    // Это операция вызовет панику в основном потоке
    division(3, 0);

    println!(&quot;Эта часть кода не будет достигнута&quot;);

    // `_x` должен быть уничтожен в этой точке
}
</code></pre></pre>
<p>Давайте убедимся, что <code>panic!</code> не приводит к утечки памяти.</p>
<pre><code class="language-bash">$ rustc panic.rs &amp;&amp; valgrind ./panic
==4401== Memcheck, a memory error detector
==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==4401== Command: ./panic
==4401== 
thread '&lt;main&gt;' panicked at 'division by zero', panic.rs:5
==4401== 
==4401== HEAP SUMMARY:
==4401==     in use at exit: 0 bytes in 0 blocks
==4401==   total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated
==4401== 
==4401== All heap blocks were freed -- no leaks are possible
==4401== 
==4401== For counts of detected and suppressed errors, rerun with: -v
==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<h1><a class="header" href="#hashmap" id="hashmap">HashMap</a></h1>
<p>В то время как вектора сохраняют значения с числовыми индексами, 
<code>HashMap</code> сохраняют значения по ключу. Ключи 
<code>HashMap</code> могут иметь логический, числовой, строковый 
или любой другой тип данных, который реализует типажи 
<code>Eq</code> и <code>Hash</code>. Подробнее об этом в 
следующей главе.</p>
<p>Как и вектора, <code>HashMap</code> расширяемые, но они также 
могут и сжать себя, когда у них появляется избыточное пространство. 
Вы можете создать хэш-карту с определённой размерностью при 
помощи <code>HashMap::with_capacity(uint)</code> или использовать 
<code>HashMap::new()</code> для получения хэш-карты с 
размерностью по умолчанию (рекомендуется).</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;

fn call(number: &amp;str) -&gt; &amp;str {
    match number {
        &quot;798-1364&quot; =&gt; &quot;Абонент выключен или находится вне зоны действия сети. 
            Пожалуйста, позвоните позднее.&quot;,
        &quot;645-7689&quot; =&gt; &quot;Здравствуйте, это Mr. Awesome's Pizza. Меня зовут Фред.
            Что я могу сделать для вас?&quot;,
        _ =&gt; &quot;Привет! Кто это опять?&quot;
    }
}

fn main() { 
    let mut contacts = HashMap::new();

    contacts.insert(&quot;Даниель&quot;, &quot;798-1364&quot;);
    contacts.insert(&quot;Эшли&quot;, &quot;645-7689&quot;);
    contacts.insert(&quot;Кейти&quot;, &quot;435-8291&quot;);
    contacts.insert(&quot;Роберт&quot;, &quot;956-1745&quot;);

    // Возьмём ссылку и вернём `Option&lt;&amp;V&gt;`
    match contacts.get(&amp;&quot;Даниель&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Звоним Даниелю: {}&quot;, call(number)),
        _ =&gt; println!(&quot;У нас нет номера Даниеля.&quot;),
    }

    // `HashMap::insert()` вернёт `None`, если мы добавляем 
    // новое значение, иначе - `Some(value)`
    contacts.insert(&quot;Даниель&quot;, &quot;164-6743&quot;);

    match contacts.get(&amp;&quot;Эшли&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Звоним Эшли: {}&quot;, call(number)),
        _ =&gt; println!(&quot;У нас нет номера Эшли.&quot;),
    }

    contacts.remove(&amp;&quot;Эшли&quot;); 

    // `HashMap::iter()` возвращает итератор, который в произвольном
    // порядке отдаёт пары `(&amp;'a key, &amp;'a value)`.
    for (contact, &amp;number) in contacts.iter() {
        println!(&quot;Звоним {}: {}&quot;, contact, call(number)); 
    }
}
</code></pre></pre>
<p>Для большей информации о том, как работает хеширование и хэш-карты (который иногда называются хэш-таблицами), вы можете обратиться к <a href="https://en.wikipedia.org/wiki/Hash_table">Wikipedia</a>.</p>
<h1><a class="header" href="#Альтернативные-пользовательские-типы-ключей" id="Альтернативные-пользовательские-типы-ключей">Альтернативные (пользовательские) типы ключей</a></h1>
<p>Любой тип, реализующий типажи <code>Eq</code> и 
<code>Hash</code> могут являться ключами в 
<code>HashMap</code>. Туда входят:</p>
<ul>
<li><code>bool</code> (хотя он будет не очень полезен, так как будет всего лишь два возможных ключа)</li>
<li><code>int</code>, <code>uint</code> и все их варианты</li>
<li><code>String</code> и <code>&amp;str</code> (подсказка: вы можете сделать <code>HashMap</code> с ключами типа <code>String</code>, а вызывать <code>.get()</code> - с <code>&amp;str</code>)</li>
</ul>
<p>Заметьте, что <code>f32</code> и <code>f64</code> <em>не</em> 
реализуют <code>Hash</code>, из-за того, что <a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">ошибки 
точности при работе с плавающей запятой</a> могут привести к 
ужасным ошибкам при использовании их в качестве ключей для 
хэш-карт.</p>
<p>Все классы коллекций реализуют <code>Eq</code> и 
<code>Hash</code> если содержащийся в них тип также реализует 
<code>Eq</code> и <code>Hash</code>. Например, 
<code>Vec&lt;T&gt;</code> реализует <code>Hash</code>, если 
<code>T</code> реализует <code>Hash</code>.</p>
<p>Вы можете легко реализовать <code>Eq</code> и 
<code>Hash</code> для пользовательских типов добавив всего 
лишь одну строчку: <code>#[derive(PartialEq, Eq, Hash)]</code></p>
<p>Компилятор сделает всё остальное. Если вы хотите больше 
контроля над деталями, вы можете сами реализовать 
<code>Eq</code> и/или <code>Hash</code>. Данное руководство 
не охватывает специфику реализации <code>Hash</code>.</p>
<p>Чтобы поиграть с использованием <code>struct</code> в 
<code>HashMap</code>, давайте попробуем реализовать очень 
простую систему авторизации пользователей:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;

// `Eq` требует, чтобы для типа был также выведен `PartialEq`.
#[derive(PartialEq, Eq, Hash)]
struct Account&lt;'a&gt;{
    username: &amp;'a str,
    password: &amp;'a str,
}

struct AccountInfo&lt;'a&gt;{
    name: &amp;'a str,
    email: &amp;'a str,
}

type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;

fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
        username: &amp;'a str, password: &amp;'a str){
    println!(&quot;Имя пользователя: {}&quot;, username);
    println!(&quot;Пароль: {}&quot;, password);
    println!(&quot;Попытка входа...&quot;);

    let logon = Account {
        username,
        password,
    };

    match accounts.get(&amp;logon) {
        Some(account_info) =&gt; {
            println!(&quot;Успешный вход!&quot;);
            println!(&quot;Имя: {}&quot;, account_info.name);
            println!(&quot;Email: {}&quot;, account_info.email);
        },
        _ =&gt; println!(&quot;Ошибка входа!&quot;),
    }
}

fn main(){
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: &quot;j.everyman&quot;,
        password: &quot;password123&quot;,
    };

    let account_info = AccountInfo {
        name: &quot;John Everyman&quot;,
        email: &quot;j.everyman@email.com&quot;,
    };

    accounts.insert(account, account_info);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;psasword123&quot;);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;password123&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#hashset" id="hashset">HashSet</a></h1>
<p>Рассмотрим <code>HashSet</code> как <code>HashMap</code> в 
котором мы заботимся только о ключах (в действительности,
<code>HashSet&lt;T&gt;</code> - это просто адаптер к 
<code>HashMap&lt;T, ()&gt;</code>).</p>
<p>&quot;Какой в этом смысл?&quot;, - спросите вы. - &quot;Я бы мог просто хранить 
ключи в <code>Vec</code>.&quot;</p>
<p>Уникальная особенность <code>HashSet</code> в том, что он 
гарантирует, что в нём не содержится повторяющихся элементом. 
Это условие выполняет любой набор (set). <code>HashSet</code> - 
всего лишь одна реализация (смотрите также: 
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a>).</p>
<p>Если вы вставите значение, которое уже содержится в 
<code>HashSet</code>, (например, новое значение равно 
существующему значению и они оба имеют одинаковый хэш), то 
новое значение заменит старое.</p>
<p>Это хорошо подходит для случаев, когда вы не хотите иметь в 
коллекции больше одного &quot;чего-либо&quot; или когда вам необходимо 
знать имеете ли вы что-либо.</p>
<p>Но наборы могут делать гораздо более.</p>
<p>Наборы имеют 4 основные операции (все вызовы вернут итератор):</p>
<ul>
<li>
<p><code>union</code>: получить все уникальные элементы из обоих наборов.</p>
</li>
<li>
<p><code>difference</code>: получить все элементы, представленные в первом наборе, но отсутствующие во втором.</p>
</li>
<li>
<p><code>intersection</code>: получить только те элементы, которые <em>присутствуют в обоих</em> наборах.</p>
</li>
<li>
<p><code>symmetric_difference</code>: получить элементы 
содержащиеся либо только в первом наборе, либо только во 
втором, но <em>не в обоих</em> (xor).</p>
</li>
</ul>
<p>Попробуем эти методы в следующем примере:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">use std::collections::HashSet;

fn main() {
    let mut a: HashSet&lt;i32&gt; = vec![1i32, 2, 3].into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec![2i32, 3, 4].into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&amp;4));

    // `HashSet::insert()` вернёт `false`
    // если элемент уже содержится в наборе.
    assert!(b.insert(4), &quot;Значение 4 уже есть в наборе B!&quot;);
    // ИСПРАВЬТЕ ^ Закомментируйте эту строку

    b.insert(5);

    // Если элементы коллекции реализуют `Debug`,
    // то и сама коллекция реализует `Debug`.
    // Обычно, элементы выводятся в формате `[elem1, elem2, ...]`
    println!(&quot;A: {:?}&quot;, a);
    println!(&quot;B: {:?}&quot;, b);

    // Выведет [1, 2, 3, 4, 5] в произвольном порядке
    println!(&quot;Union: {:?}&quot;, a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Выведет только [1]
    println!(&quot;Difference: {:?}&quot;, a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Выведет [2, 3, 4] в произвольном порядке.
    println!(&quot;Intersection: {:?}&quot;, a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Выведет [1, 5]
    println!(&quot;Symmetric Difference: {:?}&quot;,
             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());
}
</code></pre></pre>
<p>(Пример адаптирован из <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.difference">документации</a>)</p>
<h1><a class="header" href="#rc" id="rc"><code>Rc</code></a></h1>
<p>Когда необходимо множественное владение, может использоваться 
<code>Rc</code> (счётчик ссылок). <code>Rc</code> отслеживает 
количество ссылок, означающих количество владельцев значения, 
сохранённого в <code>Rc</code>.</p>
<p>Количество ссылок на <code>Rc</code> увеличивается на 1 каждый 
раз, когда <code>Rc</code> клонируется, и уменьшается на 1, когда 
один из клонов выходит из области видимости и удаляется. Когда 
количество ссылок на <code>Rc</code> становится равным нулю, 
т.е. владельцев больше нет, и <code>Rc</code>, и значение 
удаляются.</p>
<p>При клонировании <code>Rc</code> никогда не делается глубокая 
копия. Клонирование лишь создаёт другой указатель на обёрнутое 
значение и увеличивает счётчик.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::rc::Rc;

fn main() {
    let rc_examples = &quot;Пример с Rc&quot;.to_string();
    {
        println!(&quot;--- Создана rc_a ---&quot;);
        
        let rc_a: Rc&lt;String&gt; = Rc::new(rc_examples);
        println!(&quot;Количество ссылок на rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        {
            println!(&quot;--- rc_a клонировано в rc_b ---&quot;);
            
            let rc_b: Rc&lt;String&gt; = Rc::clone(&amp;rc_a);
            println!(&quot;Количество ссылок на rc_b: {}&quot;, Rc::strong_count(&amp;rc_b));
            println!(&quot;Количество ссылок на rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
            
            // Два `Rc` равны, если равны их внутренние значения
            println!(&quot;rc_a и rc_b равны: {}&quot;, rc_a.eq(&amp;rc_b));
            
            // Мы можем напрямую использовать методы внутреннего значения
            println!(&quot;Размер значения внутри rc_a: {}&quot;, rc_a.len());
            println!(&quot;Значение rc_b: {}&quot;, rc_b);
            
            println!(&quot;--- rc_b удаляется ---&quot;);
        }
        
        println!(&quot;Количество ссылок на rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        println!(&quot;--- rc_a удаляется ---&quot;);
    }
    
    // Ошибка! `rc_examples` уже перемещена в `rc_a`
    // И когда `rc_a` удалилась, `rc_examples` удалилась вместе с ней
    // println!(&quot;rc_examples: {}&quot;, rc_examples);
    // TODO ^ Попробуйте удалить комментарий эту строку
}
</code></pre></pre>
<h3><a class="header" href="#Смотрите-также-63" id="Смотрите-также-63">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/rc/index.html">std::rc</a> и <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a>.</p>
<h1><a class="header" href="#Разное-в-стандартной-библиотеке" id="Разное-в-стандартной-библиотеке">Разное в стандартной библиотеке</a></h1>
<p>Многие другие типы предоставляются стандартной библиотекой
для вспомогательных целей, например:</p>
<ul>
<li>Потоки</li>
<li>Каналы</li>
<li>Операции файлового ввода/вывода</li>
</ul>
<p>Они расширяют возможности, которые предоставляют <a href="primitives.html">примитивы</a>.</p>
<h3><a class="header" href="#Смотрите-также-64" id="Смотрите-также-64">Смотрите также:</a></h3>
<p><a href="primitives.html">примитивы</a> и <a href="https://doc.rust-lang.org/std/">стандартная библиотека</a></p>
<h1><a class="header" href="#Потоки" id="Потоки">Потоки</a></h1>
<p>Rust предоставляет механизм для создания собственных потоков операционной системы через функцию <code>spawn</code>. Аргументом этой функции является замыкание, которое принимает владение захваченным ею окружением.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::thread;

static NTHREADS: i32 = 10;

// Это главный поток `main`
fn main() {
    // Создаём вектор дочерних потоков.
    let mut children = vec![];

    for i in 0..NTHREADS {
        // Создаём очередной поток
        children.push(thread::spawn(move || {
            println!(&quot;этот поток номер {}&quot;, i);
        }));
    }

    for child in children {
        // Ждём пока поток завершится и вернёт результат.
        let _ = child.join();
    }
}
</code></pre></pre>
<p>Эти потоки будут запланированы ОС.</p>
<h1><a class="header" href="#Пример-map-reduce" id="Пример-map-reduce">Пример: map-reduce</a></h1>
<p>Rust позволяет очень легко распределить обработку данных между потоками, без 
головной боли, традиционно связанной с попыткой сделать это.</p>
<p>Стандартная библиотека предоставляет отличные примитивы для работы потоками из коробки. Они в сочетании с концепцией владения и правилами алиасинга в Rust, автоматически предотвращают гонки данных.</p>
<p>Правила алиасинга (одна уникальная ссылка на запись или много ссылок на чтение) автоматически не позволяет вам манипулировать 
состоянием, которое видно другим потокам. (Где синхронизация необходима,
есть примитивы синхронизации, такие как <code>mutex</code> (мьютексы) или <code>channel</code> (каналы).)</p>
<p>В этом примере мы вычислим сумму всех цифр в блоке чисел. Мы сделаем это, разбив куски блока на разные потоки. Каждый поток будет суммировать свой крошечный блок цифр, и впоследствии мы будем суммировать промежуточные суммы, полученные каждым потоком.</p>
<p>Обратите внимание на то, что хоть мы и передаём ссылки через 
границы потоков, Rust понимает, что мы только передаём 
неизменяемые ссылки, которые можно только читать, и что из-за 
этого не может быть никакой небезопасности и гонок данных. Так 
как мы перемещаем (<code>move</code>) сегменты данных в 
поток, Rust также уверен, что данные будут жить до тех пор, пока 
поток не завершится, и висящих указателей не появится.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::thread;

// This is the `main` thread
fn main() {

    // This is our data to process.
    // We will calculate the sum of all digits via a threaded  map-reduce algorithm.
    // Each whitespace separated chunk will be handled in a different thread.
    //
    // TODO: see what happens to the output if you insert spaces!
    let data = &quot;86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668&quot;;

    // Make a vector to hold the child-threads which we will spawn.
    let mut children = vec![];

    /*************************************************************************
     * &quot;Map&quot; phase
     *
     * Divide our data into segments, and apply initial processing
     ************************************************************************/

    // split our data into segments for individual calculation
    // each chunk will be a reference (&amp;str) into the actual data
    let chunked_data = data.split_whitespace();

    // Iterate over the data segments.
    // .enumerate() adds the current loop index to whatever is iterated
    // the resulting tuple &quot;(index, element)&quot; is then immediately
    // &quot;destructured&quot; into two variables, &quot;i&quot; and &quot;data_segment&quot; with a
    // &quot;destructuring assignment&quot;
    for (i, data_segment) in chunked_data.enumerate() {
        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);

        // Process each data segment in a separate thread
        //
        // spawn() returns a handle to the new thread,
        // which we MUST keep to access the returned value
        //
        // 'move || -&gt; u32' is syntax for a closure that:
        // * takes no arguments ('||')
        // * takes ownership of its captured variables ('move') and
        // * returns an unsigned 32-bit integer ('-&gt; u32')
        //
        // Rust is smart enough to infer the '-&gt; u32' from
        // the closure itself so we could have left that out.
        //
        // TODO: try removing the 'move' and see what happens
        children.push(thread::spawn(move || -&gt; u32 {
            // Calculate the intermediate sum of this segment:
            let result = data_segment
                        // iterate over the characters of our segment..
                        .chars()
                        // .. convert text-characters to their number value..
                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))
                        // .. and sum the resulting iterator of numbers
                        .sum();

            // println! locks stdout, so no text-interleaving occurs
            println!(&quot;processed segment {}, result={}&quot;, i, result);

            // &quot;return&quot; not needed, because Rust is an &quot;expression language&quot;, the
            // last evaluated expression in each block is automatically its value.
            result

        }));
    }


    /*************************************************************************
     * &quot;Reduce&quot; phase
     *
     * Collect our intermediate results, and combine them into a final result
     ************************************************************************/

    // collect each thread's intermediate results into a new Vec
    let mut intermediate_sums = vec![];
    for child in children {
        // collect each child thread's return-value
        let intermediate_sum = child.join().unwrap();
        intermediate_sums.push(intermediate_sum);
    }

    // combine all intermediate sums into a single final sum.
    //
    // we use the &quot;turbofish&quot; ::&lt;&gt; to provide sum() with a type hint.
    //
    // TODO: try without the turbofish, by instead explicitly
    // specifying the type of final_result
    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();

    println!(&quot;Final sum result: {}&quot;, final_result);
}


</code></pre></pre>
<h3><a class="header" href="#Назначения" id="Назначения">Назначения</a></h3>
<p>Не стоит позволять числу наших потоков быть зависимом от 
введённых пользователем данных. Что если пользователь решит 
вставить много пробелов? Мы <em>действительно</em> хотим 
создать 2000 потоков? Измените программу так, чтобы данные 
разбивались на ограниченное число блоков, объявленных 
статической константой в начале программы.</p>
<h3><a class="header" href="#Смотрите-также-65" id="Смотрите-также-65">Смотрите также:</a></h3>
<ul>
<li><a href="std_misc/threads/../threads.html">Потоки</a></li>
<li><a href="std_misc/threads/../../std/vec.html">вектора</a> и <a href="std_misc/threads/../../trait/iter.html">итераторы</a></li>
<li><a href="std_misc/threads/../../fn/closures.html">замыкания</a>, <a href="std_misc/threads/../../scope/move.html">семантика передачи владения</a> и <a href="https://doc.rust-lang.org/book/ch13-01-closures.html#closures-can-capture-their-environment">перемещения (<code>move</code>) в замыканиях</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values">деструктуризация</a> при присвоениях</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">нотация turbofish</a> в помощь механизму вывода типов</li>
<li><a href="std_misc/threads/../../error/option_unwrap.html"><code>unwrap</code> или <code>expect</code></a></li>
<li><a href="https://doc.rust-lang.org/book/loops.html#enumerate">enumerate</a></li>
</ul>
<h1><a class="header" href="#Каналы" id="Каналы">Каналы</a></h1>
<p>Rust предоставляет асинхронные каналы (<code>channel</code>) для 
взаимодействия между потоками. Каналы обеспечивают 
однонаправленную передачу информации между двумя конечными 
точками: отправителем (<code>Sender</code>) и получателем 
(<code>Receiver</code>).</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // Каналы имеют две конечные точки: Sender&lt;T&gt;` и `Receiver&lt;T&gt;`,
    // где `T` - тип передаваемового сообщения.
    // (аннотации типов избыточны)
    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();
    let mut children = Vec::new();

    for id in 0..NTHREADS {
        // Отправитель может быть скопирован
        let thread_tx = tx.clone();

        // Каждый поток отправит через канал его id
        let child = thread::spawn(move || {
            // Поток забирает владение `thread_tx`
            // Каждый поток добавляет своё сообщение в очередь канала
            thread_tx.send(id).unwrap();

            // Отправка - не блокирующая операция, поток незамедлительно
            // продолжит работу после отправки сообщения
            println!(&quot;поток {} завершён&quot;, id);
        });

        children.push(child);
    }

    // Здесь все сообщения собираются
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // Метод `recv` &quot;достаёт&quot; сообщения из канала
        // `recv` блокирует текущий поток, если доступных сообщений нет
        ids.push(rx.recv());
    }
    
    // Ожидаем, когда потоки завершат всю оставшуюся работу
    for child in children {
        child.join().expect(&quot;Упс! Дочерний поток паникует&quot;);
    }

    // Посмотрите порядок, с которым сообщения были отправлeны
    println!(&quot;{:?}&quot;, ids);
}
</code></pre></pre>
<h1><a class="header" href="#path" id="path">Path</a></h1>
<p>Структура <code>Path</code> представляет пути к файлу в файловой 
системе. Есть два вида <code>Path</code>: <code>posix::Path</code>, 
для UNIX - подобных систем, и <code>windows::Path</code>, для 
Windows. В прелюдии экспортируется соответствующий 
платформозависимый вариант <code>Path</code>.</p>
<p><code>Path</code> может быть создан из <code>OsStr</code>, и 
предоставляет некоторые методы для получения информации о 
файле или директории, на которые он указывает.</p>
<p>Обратите внимание, что внутренне представление 
<code>Path</code> <em>не является</em> UTF-8 строкой, но вместо 
этого хранит вектор байт (<code>Vec&lt;u8&gt;</code>). 
Следовательно, преобразование <code>Path</code> в 
<code>&amp;str</code> <em>не</em> бесплатно и может закончиться 
неудачей (возвращается <code>Option</code>).</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::path::Path;

fn main() {
    // Создаём `Path` из `&amp;'static str`
    let path = Path::new(&quot;.&quot;);

    // Метод `display` возвращает показываемую структуру
    let _display = path.display();

    // `join` соединяет `path` с байтовым контейнером, используя ОС-специфичный
    // разделитель, и возвращает новый путь
    let new_path = path.join(&quot;a&quot;).join(&quot;b&quot;);

    // Конвертируем путь в строковый срез
    match new_path.to_str() {
        None =&gt; panic!(&quot;новый путь не является действительной UTF-8 последовательностью&quot;),
        Some(s) =&gt; println!(&quot;новый путь {}&quot;, s),
    }
}

</code></pre></pre>
<p>Не забудьте проверить остальные методы <code>Path</code>
(<code>posix::Path</code> или <code>windows::Path</code>) и
структуры <code>Metadata</code>.</p>
<h3><a class="header" href="#Смотрите-также-66" id="Смотрите-также-66">Смотрите также:</a></h3>
<p><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">OsStr</a> и <a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html">Metadata</a>.</p>
<h1><a class="header" href="#Файловый-ввод-вывод" id="Файловый-ввод-вывод">Файловый ввод-вывод</a></h1>
<p>Структура <code>File</code> представляет открытый файл (она является обёрткой над файловым дескриптором) и даёт возможность чтения/записи этого файла.</p>
<p>Из-за того, что многие вещи могут пойти не так в процессе файлового 
ввода-вывода, все методы <code>File</code> возвращают тип 
<code>io::Result&lt;T&gt;</code>, который является псевдонимом для 
<code>Result&lt;T, io::Error&gt;</code>.</p>
<p>Это делает <em>явными</em> ошибки всех операций ввода-вывода. 
Благодаря этому, программист может увидеть все пути отказов и 
обрабатывать их упреждающей форме.</p>
<h1><a class="header" href="#open" id="open"><code>open</code></a></h1>
<p>Статический метод <code>open</code> может использоваться для открытия файла в режиме только для чтения.</p>
<p>Структура <code>File</code> владеет ресурсом, файловым 
дескриптором, и заботится о том, чтобы он был закрыт, когда 
структура удаляется из памяти.</p>
<pre><code class="language-rust editable ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // Создадим &quot;путь&quot; к нужному файлу
    let path = Path::new(&quot;hello.txt&quot;);
    let display = path.display();

    // Откроем &quot;путь&quot; в режиме &quot;только чтение&quot;. Возвращается `io::Result&lt;File&gt;`
    let mut file = match File::open(&amp;path) {
        // Метод `description` у `io::Error` возвращает строку,
        // которая описывает ошибку
        Err(why) =&gt; panic!(&quot;невозможно открыть {}: {}&quot;, display,
                                                   why.description()),
        Ok(file) =&gt; file,
    };

    // Читаем содержимое файла в строку. Метод возвращает `io::Result&lt;usize&gt;`
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;невозможно прочесть {}: {}&quot;, display,
                                                   why.description()),
        Ok(_) =&gt; print!(&quot;{} содержит:\n{}&quot;, display, s),
    }

    // `file` выходит из области видимости и файл &quot;hello.txt&quot; закрывается
}

</code></pre>
<p>Вот ожидаемый результат:</p>
<pre><code class="language-shell">$ echo &quot;Hello World!&quot; &gt; hello.txt
$ rustc open.rs &amp;&amp; ./open
hello.txt содержит:
Hello World!
</code></pre>
<p>(Рекомендуем протестировать предыдущий пример при различных 
условиях сбоев: файл <code>hello.txt</code> не существует или 
<code>hello.txt</code> не читаемый и другое)</p>
<h1><a class="header" href="#create" id="create"><code>create</code></a></h1>
<p>Статический метод <code>create</code> открывает файл в режиме 
только для записи. Если файл уже существует, то его содержимое 
уничтожится, в противном же случае, создастся новый файл.</p>
<pre><code class="language-rust ignore">static LOREM_IPSUM: &amp;str =
    &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
&quot;;

use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    let path = Path::new(&quot;out/lorem_ipsum.txt&quot;);
    let display = path.display();

    // Откроем файл в режиме для записи. Возвращается `io::Result&lt;File&gt;`
    let mut file = match File::create(&amp;path) {
        Err(why) =&gt; panic!(&quot;невозможно создать {}: {}&quot;, display, why.description()),
        Ok(file) =&gt; file,
    };

    // Запишем строку `LOREM_IPSUM` в `file`. Возвращается `io::Result&lt;()&gt;`
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;невозможно записать в {}: {}&quot;, display, why.description()),
        Ok(_) =&gt; println!(&quot;успешно записано в {}&quot;, display),
    }
}
</code></pre>
<p>Вот расширенный ожидаемый результат:</p>
<pre><code class="language-shell">$ mkdir out
$ rustc create.rs &amp;&amp; ./create
успешно записано в out/lorem_ipsum.txt
$ cat out/lorem_ipsum.txt
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
</code></pre>
<p>(Как и в предыдущем примере, предлагаем вам протестировать этот 
код с различными вариантами отказа.)</p>
<p>Существует структура <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html"><code>OpenOptions</code></a>, которая 
может использоваться для настройки того, как файл будет открыт.</p>
<h1><a class="header" href="#read_lines" id="read_lines"><code>read_lines</code></a></h1>
<p>Метод <code>lines()</code> возвращает итератор, проходящий через
все строки файла.</p>
<p><code>File::open</code> работает с чем-то, что реализует типаж <code>AsRef&lt;Path&gt;</code>. Поэтому <code>read_lines()</code> будет ожидать это же.</p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    // Файл `hosts` должен существовать в текущей директории
    if let Ok(lines) = read_lines(&quot;./hosts&quot;) {
        // Получает итератор, который возвращает Option
        for line in lines {
            if let Ok(ip) = line {
                println!(&quot;{}&quot;, ip);
            }      
        }   
    }
}

// Для обработки ошибок, возвращаемое значение оборачивается в Result
// Возвращаем `Iterator` для построчного чтения файла.
fn read_lines&lt;P&gt;(filename: P) -&gt; io::Result&lt;io::Lines&lt;io::BufReader&lt;File&gt;&gt;&gt;
where P: AsRef&lt;Path&gt;, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
</code></pre></pre>
<p>Запуск этой программы просто выводит эти строки на экран по
отдельности.</p>
<pre><code class="language-shell">$ echo -e &quot;127.0.0.1\n192.168.0.1\n&quot; &gt; hosts
$ rustc read_lines.rs &amp;&amp; ./read_lines
127.0.0.1
192.168.0.1
</code></pre>
<p>Такой подход более эффективен, чем создание <code>String</code> в памяти, особенно при работе с большими файлами.</p>
<h1><a class="header" href="#Дочерние-процессы" id="Дочерние-процессы">Дочерние процессы</a></h1>
<p>Структура <code>process::Output</code> представляет результат завершённого дочернего процесса,
и структура <code>process::Command</code> - это строитель процесса.</p>
<pre><code class="language-rust editable ignore">use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;--version&quot;)
        .output().unwrap_or_else(|e| {
            panic!(&quot;Ошибка выполнения процесса {}&quot;, e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&amp;output.stdout);

        print!(&quot;rustc завершился успешно и вывел в stdout:\n{}&quot;, s);
    } else {
        let s = String::from_utf8_lossy(&amp;output.stderr);

        print!(&quot;rustc завершился с ошибкой и вывел в stderr:\n{}&quot;, s);
    }
}
</code></pre>
<p>(Рекомендуется попробовать предыдущий пример с неправильным флагом обращения к <code>rustc</code>)</p>
<h1><a class="header" href="#pipes" id="pipes">Pipes</a></h1>
<p>Структура <code>std::Child</code> представляет собой запущенный 
дочерний процесс и предоставляет дескрипторы <code>stdin</code>, 
<code>stdout</code> и <code>stderr</code> для взаимодействия с 
этим процессом через каналы (pipes).</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &amp;'static str =
&quot;the quick brown fox jumped over the lazy dog\n&quot;;

fn main() {
    // Создадим команду `wc`
    let process = match Command::new(&quot;wc&quot;)
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) =&gt; panic!(&quot;не удалось создать wc: {}&quot;, why.description()),
        Ok(process) =&gt; process,
    };

    // Запишем строку в `stdin` созданной команды.
    //
    // `stdin` имеет тип `Option&lt;ChildStdin&gt;`, но так как мы знаем, что экземпляр должен быть только один,
    // мы можем напрямую вызвать `unwrap`.
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;не удалось записать в stdin команды wc: {}&quot;,
                           why.description()),
        Ok(_) =&gt; println!(&quot;пангамма отправлена&quot;),
    }

    // Так как `stdin` не существует после вышележащих вызовов, он разрушается
    // и канал закрывается.
    //
    // Это очень важно, иначе `wc` не начал бы обработку только что
    // отправленных данных.

    // Поле `stdout` имеет тип `Option&lt;ChildStdout&gt;` и может быть извлечено.
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;невозможно прочесть stdout команды wc: {}&quot;,
                           why.description()),
        Ok(_) =&gt; print!(&quot;wc ответил:\n{}&quot;, s),
    }
}
</code></pre>
<h1><a class="header" href="#Ожидание" id="Ожидание">Ожидание</a></h1>
<p>Если вы хотите дождаться завершения <code>process::Child</code>, вы должны вызвать <code>Child::wait</code>, который вернёт <code>process::ExitStatus</code>.</p>
<pre><code class="language-rust ignore">use std::process::Command;

fn main() {
    let mut child = Command::new(&quot;sleep&quot;).arg(&quot;5&quot;).spawn().unwrap();
    let _result = child.wait().unwrap();

    println!(&quot;достигнут конец функции main&quot;);
}
</code></pre>
<pre><code class="language-bash">$ rustc wait.rs &amp;&amp; ./wait
# `wait` продолжает работать в течение 5 секунд, пока команда `sleep 5` не завершится
достигнут конец функции main
</code></pre>
<h1><a class="header" href="#Работа-с-файловой-системой" id="Работа-с-файловой-системой">Работа с файловой системой</a></h1>
<p>Модуль <code>std::fs</code> содержит различные функции для 
работы с файловой системой.</p>
<pre><code class="language-rust ignore">use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
use std::os::unix;
use std::path::Path;

// Упрощённая реализация `% cat path`
fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// Упрощённая реализация `% echo s &gt; path`
fn echo(s: &amp;str, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// Упрощённая реализация `% touch path` (игнорирует существующие файлы)
fn touch(path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) =&gt; Ok(()),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    println!(&quot;`mkdir a`&quot;);
    // Создаём директорию, получаем `io::Result&lt;()&gt;`
    match fs::create_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(_) =&gt; {},
    }

    println!(&quot;`echo hello &gt; a/b.txt`&quot;);
    // Предыдущий `match` может быть написан проще, с помощью метода`unwrap_or_else`
    echo(&quot;hello&quot;, &amp;Path::new(&quot;a/b.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`mkdir -p a/c/d`&quot;);
    // Рекурсивно создаём директории, получаем `io::Result&lt;()&gt;`
    fs::create_dir_all(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`touch a/c/e.txt`&quot;);
    touch(&amp;Path::new(&quot;a/c/e.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`ln -s ../b.txt a/c/b.txt`&quot;);
    // Создаём символическую ссылку, получаем `io::Result&lt;()&gt;`
    if cfg!(target_family = &quot;unix&quot;) {
        unix::fs::symlink(&quot;../b.txt&quot;, &quot;a/c/b.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
        });
    }

    println!(&quot;`cat a/c/b.txt`&quot;);
    match cat(&amp;Path::new(&quot;a/c/b.txt&quot;)) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(s) =&gt; println!(&quot;&gt; {}&quot;, s),
    }

    println!(&quot;`ls a`&quot;);
    // Читаем содержимое директории, получаем `io::Result&lt;Vec&lt;Path&gt;&gt;`
    match fs::read_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(paths) =&gt; for path in paths {
            println!(&quot;&gt; {:?}&quot;, path.unwrap().path());
        },
    }

    println!(&quot;`rm a/c/e.txt`&quot;);
    // Удаляем файл, получаем `io::Result&lt;()&gt;`
    fs::remove_file(&quot;a/c/e.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`rmdir a/c/d`&quot;);
    // Удаляем пустую директорию, получаем `io::Result&lt;()&gt;`
    fs::remove_dir(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });
}

</code></pre>
<p>Вот ожидаемый результат:</p>
<pre><code class="language-shell">$ rustc fs.rs &amp;&amp; ./fs
`mkdir a`
`echo hello &gt; a/b.txt`
`mkdir -p a/c/d`
`touch a/c/e.txt`
`ln -s ../b.txt a/c/b.txt`
`cat a/c/b.txt`
&gt; hello
`ls a`
&gt; &quot;a/b.txt&quot;
&gt; &quot;a/c&quot;
`rm a/c/e.txt`
`rmdir a/c/d`
</code></pre>
<p>И конечное состояние директории <code>a</code>:</p>
<pre><code class="language-shell">$ tree a
a
|-- b.txt
`-- c
    `-- b.txt -&gt; ../b.txt

1 directory, 2 files
</code></pre>
<p>Альтернативный путь определения функции <code>cat</code> - с 
нотацией <code>?</code>:</p>
<pre><code class="language-rust ignore">fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre>
<h3><a class="header" href="#Смотрите-также-67" id="Смотрите-также-67">Смотрите также:</a></h3>
<p><a href="std_misc/../attribute/cfg.html"><code>cfg!</code></a></p>
<h1><a class="header" href="#Аргументы-программы" id="Аргументы-программы">Аргументы программы</a></h1>
<h2><a class="header" href="#Стандартная-библиотека" id="Стандартная-библиотека">Стандартная библиотека</a></h2>
<p>Аргументы командной строки могут быть доступны при помощи 
<code>std::env::args</code>, который возвращает итератор, который 
выдаёт <code>String</code> для каждого аргумента:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    // Первый аргумент - путь, используемый для вызова программы.
    println!(&quot;Мой путь {}.&quot;, args[0]);

    // Оставшиеся аргументы - переданные в командной строке параметры.
    // Вызов программы выглядит так:
    //   $ ./args arg1 arg2
    println!(&quot;У меня {:?} аргумента: {:?}.&quot;, args.len() - 1, &amp;args[1..]);
}
</code></pre></pre>
<pre><code class="language-shell">$ ./args 1 2 3
Мой путь ./args.
У меня 3 аргумента: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].
</code></pre>
<h2><a class="header" href="#Крейты" id="Крейты">Крейты</a></h2>
<p>В качестве альтернативы, существует несколько крейтов, которые 
предоставляют дополнительную функциональность при создании 
приложений командной сроки. <a href="https://rust-lang-nursery.github.io/rust-cookbook/cli/arguments.html">Rust Cookbook</a> показывает 
лучшие практики, как использовать один из самых популярных 
крейтов для аргументов командной строки, <code>clap</code>.</p>
<h1><a class="header" href="#Парсинг-аргументов" id="Парсинг-аргументов">Парсинг аргументов</a></h1>
<p>Сопоставление может быть использовано для разбора простых аргументов:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::env;

fn increase(number: i32) {
    println!(&quot;{}&quot;, number + 1);
}

fn decrease(number: i32) {
    println!(&quot;{}&quot;, number - 1);
}

fn help() {
    println!(&quot;usage:
match_args &lt;string&gt;
    Проверяет является ли данная строка ответом.
match_args {{increase|decrease}} &lt;integer&gt;
    Увеличивает или уменьшает число на 1.&quot;);
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    match args.len() {
        // аргументы не переданы
        1 =&gt; {
            println!(&quot;Я - 'match_args'. Попробуйте передать аргументы!&quot;);
        },
        // передан один аргумент
        2 =&gt; {
            match args[1].parse() {
                Ok(42) =&gt; println!(&quot;Это ответ!&quot;),
                _ =&gt; println!(&quot;Это не ответ.&quot;),
            }
        },
        // переданы одна команда и один аргумент
        3 =&gt; {
            let cmd = &amp;args[1];
            let num = &amp;args[2];
            // parse the number
            let number: i32 = match num.parse() {
                Ok(n) =&gt; {
                    n
                },
                Err(_) =&gt; {
                    eprintln!(&quot;ошибка: второй аргумент не является числом&quot;);
                    help();
                    return;
                },
            };
            // парсим команду
            match &amp;cmd[..] {
                &quot;increase&quot; =&gt; increase(number),
                &quot;decrease&quot; =&gt; decrease(number),
                _ =&gt; {
                    eprintln!(&quot;ошибка: неизвестная команда&quot;);
                    help();
                },
            }
        },
        // все остальные случаи
        _ =&gt; {
            // показываем сообщение с помощью
            help();
        }
    }
}
</code></pre></pre>
<pre><code class="language-shell">$ ./match_args Rust
Это не ответ.
$ ./match_args 42
Это ответ!
$ ./match_args do something
ошибка: второй аргумент не является числом
usage:
match_args &lt;string&gt;
    Проверяет является ли данная строка ответом.
match_args {increase|decrease} &lt;integer&gt;
    Увеличивает или уменьшает число на 1.
$ ./match_args do 42
ошибка: неизвестная команда
usage:
match_args &lt;string&gt;
    Проверяет является ли данная строка ответом.
match_args {increase|decrease} &lt;integer&gt;
    Увеличивает или уменьшает число на 1.
$ ./match_args increase 42
43
</code></pre>
<h1><a class="header" href="#foreign-function-interface" id="foreign-function-interface">Foreign Function Interface</a></h1>
<p>Rust предоставляет интерфейс внешних функций (Foreign Function 
Interface, FFI) к библиотекам, написанным на языке С. Внешние 
функции должны быть объявлены внутри блока <code>extern</code> 
и аннотированы при помощи атрибута <code>#[link]</code>, который 
содержит имя внешней библиотеки.</p>
<pre><code class="language-rust ignore">use std::fmt;

// Этот extern-блок подключает библиотеку libm
#[link(name = &quot;m&quot;)]
extern {
    // Это внешняя функция, которая считает квадратный корень
    // комплексного числа одинарной точности
    fn csqrtf(z: Complex) -&gt; Complex;

    fn ccosf(z: Complex) -&gt; Complex;
}

// Так как вызовы внешних функций считаются unsafe,
// принято писать над ними обёртки.
fn cos(z: Complex) -&gt; Complex {
    unsafe { ccosf(z) }
}

fn main() {
    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };

    // вызов внешней функции - unsafe операция
    let z_sqrt = unsafe { csqrtf(z) };

    println!(&quot;квадратный корень от {:?} равен {:?}&quot;, z, z_sqrt);

    // вызов безопасного API в котором находится unsafe операция
    println!(&quot;cos({:?}) = {:?}&quot;, z, cos(z));
}

// Минимальная реализация комплексного числа одинарной точности
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.im &lt; 0. {
            write!(f, &quot;{}-{}i&quot;, self.re, -self.im)
        } else {
            write!(f, &quot;{}+{}i&quot;, self.re, self.im)
        }
    }
}
</code></pre>
<h1><a class="header" href="#Тестирование-1" id="Тестирование-1">Тестирование</a></h1>
<p>Rust - это язык программирования, который очень заботится о корректности и
включает в себя поддержку написания тестов программного обеспечения в самом языке.</p>
<p>Тестирование поставляется в трёх стилях:</p>
<ul>
<li><a href="testing/unit_testing.html">Модульное</a> тестирование.</li>
<li><a href="testing/doc_testing.html">Тестирование кода из примеров документации</a>.</li>
<li><a href="testing/integration_testing.html">Интеграционное тестирование</a>.</li>
</ul>
<p>Также Rust поддерживает указание дополнительных зависимостей для тестов:</p>
<ul>
<li><a href="testing/dev_dependencies.html">Dev-dependencies</a></li>
</ul>
<h2><a class="header" href="#Смотрите-также-68" id="Смотрите-также-68">Смотрите также:</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-00-testing.html">Глава о тестировании</a> в &quot;The Rust Programming Language&quot;</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">Описание API</a> для тестирования примеров из документации.</li>
</ul>
<h1><a class="header" href="#unit-тестирование" id="unit-тестирование">Unit-тестирование</a></h1>
<p>Тесты - это функции на Rust, которые проверяют, что тестируемый 
код работает ожидаемым образом. Тело тестовых функций обычно 
выполняет некоторую настройку, запускает код, который мы 
тестируем, и затем сравнивает полученный результат с тем, что мы 
ожидаем.</p>
<p>Большинство модульных тестов располагается в <a href="testing/../mod.html">модуле</a> 
<code>tests</code>, помеченном <a href="testing/../attribute.html">атрибутом</a> 
<code>#[cfg(test)]</code>. Тестовые функции помечаются 
атрибутом <code>#[test]</code>.</p>
<p>Тесты заканчиваются неудачей, когда что-либо в тестовой функции 
вызывает <a href="testing/../std/panic.html">панику</a>. Есть несколько вспомогательных 
<a href="testing/../macros.html">макросов</a>:</p>
<ul>
<li><code>assert!(expression)</code> - паникует, если результат выражения равен <code>false</code>.</li>
<li><code>assert_eq!(left, right)</code> и <code>assert_ne!(left, right)</code> - сравнивает левое и правое выражения на равенство и неравенство соответственно.</li>
</ul>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// Это действительно плохая функция сложения, её назначение в данном // примере - потерпеть неудачу.
#[allow(dead_code)]
fn bad_add(a: i32, b: i32) -&gt; i32 {
    a - b
}

#[cfg(test)]
mod tests {
    // Обратите внимание на эту полезную идиому: импортирование имён из внешней (для mod - тестов) области видимости.
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }

    #[test]
    fn test_bad_add() {
        // Это утверждение запустится и проверка не сработает.
        // Заметьте, что приватные функции также могут быть протестированы!
        assert_eq!(bad_add(1, 2), 3);
    }
}
</code></pre>
<p>Тесты могут быть запущены при помощи команды <code>cargo test</code>.</p>
<pre><code class="language-shell">$ cargo test

running 2 tests
test tests::test_bad_add ... FAILED
test tests::test_add ... ok

failures:

---- tests::test_bad_add stdout ----
        thread 'tests::test_bad_add' panicked at 'assertion failed: `(left == right)`
  left: `-1`,
 right: `3`', src/lib.rs:21:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::test_bad_add

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#Тестирование-паники" id="Тестирование-паники">Тестирование паники</a></h2>
<p>Для тестирования функций, которые должны паниковать при 
определённых обстоятельствах, используется атрибут 
<code>#[should_panic]</code>. Этот атрибут принимает 
необязательный параметр <code>expected =</code> с текстом 
сообщения о панике. Если ваша функция может паниковать в 
разных случаях, то этот параметр поможет вам быть уверенным, 
что вы тестируете именно ту панику, которую собирались.</p>
<pre><code class="language-rust ignore">pub fn divide_non_zero_result(a: u32, b: u32) -&gt; u32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    } else if a &lt; b {
        panic!(&quot;Divide result is zero&quot;);
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = &quot;Divide result is zero&quot;)]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
}
</code></pre>
<p>Запуск этих тестов даст следующее:</p>
<pre><code class="language-shell">$ cargo test

running 3 tests
test tests::test_any_panic ... ok
test tests::test_divide ... ok
test tests::test_specific_panic ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#Запуск-конкретных-тестов" id="Запуск-конкретных-тестов">Запуск конкретных тестов</a></h2>
<p>Для запуска конкретного теста надо добавить имя теста в команду 
<code>cargo test</code>.</p>
<pre><code class="language-shell">$ cargo test test_any_panic
running 1 test
test tests::test_any_panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Для запуска нескольких тестов, можно указать часть имени, 
которая есть во всех необходимых тестах.</p>
<pre><code class="language-shell">$ cargo test panic
running 2 tests
test tests::test_any_panic ... ok
test tests::test_specific_panic ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#Игнорирование-тестов" id="Игнорирование-тестов">Игнорирование тестов</a></h2>
<p>Тесты могут быть помечены атрибутом <code>#[ignore]</code>, чтобы они были исключены из списка запускаемых командой <code>cargo test</code>. Такие тесты можно запустить с помощью команды <code>cargo test -- --ignored</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(100, 2), 102);
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(0, 0), 0);
    }
}
#}</code></pre></pre>
<pre><code class="language-shell">$ cargo test
running 3 tests
test tests::ignored_test ... ignored
test tests::test_add ... ok
test tests::test_add_hundred ... ok

test result: ok. 2 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

$ cargo test -- --ignored
running 1 test
test tests::ignored_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h1><a class="header" href="#Тестирование-документации" id="Тестирование-документации">Тестирование документации</a></h1>
<p>Основной способ документирования проекта на Rust - это 
аннотирование исходного кода. Документационные комментарии 
пишутся с использованием <a href="https://daringfireball.net/projects/markdown/">markdown</a> и позволяют 
использовать внутри блоки кода. Rust заботится о корректности, так 
что эти блоки кода могут компилироваться и использоваться в 
качестве тестов.</p>
<pre><code class="language-rust ignore">/// Первая строка - это краткое описание функции.
///
/// Следующие строки представляют детальную документацию. Блоки кода /// начинаются трёх обратных кавычек и внутри содержат неявные
/// `fn main()` и `extern crate &lt;cratename&gt;`. Предположим, мы
/// тестируем крейт `doccomments`:
///
/// ```
/// let result = doccomments::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

/// Ообычно документационные комментарии могут содержат секции &quot;Examples&quot;, &quot;Panics&quot; and &quot;Failures&quot;.
///
/// Следующая функция делит два числа.
///
/// # Examples
///
/// ```
/// let result = doccomments::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// Функция паникует, если второй аргумент равен нулю.
///
/// ```rust,should_panic
/// // паникует при делении на 0
/// doccomments::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!(&quot;Ошибка деления на 0&quot;);
    }

    a / b
}
</code></pre>
<p>Тесты могут быть запущены при помощи <code>cargo test</code>:</p>
<pre><code class="language-shell">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests doccomments

running 3 tests
test src/lib.rs - add (line 7) ... ok
test src/lib.rs - div (line 21) ... ok
test src/lib.rs - div (line 31) ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#Мотивация-для-документационных-тестов" id="Мотивация-для-документационных-тестов">Мотивация для документационных тестов</a></h2>
<p>Главная цель документационных тестов - служить примерами 
предоставляемой функциональности, что является одной из самых 
важных <a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html#examples-use--not-try-not-unwrap-c-question-mark">рекомендаций</a>. Это позволяет использовать 
примеры из документации в качестве полных фрагментов кода. Но 
использование <code>?</code> приведёт к ошибке компиляции, так 
как функция <code>main</code> возвращает <code>()</code> 
(<code>unit</code>). На помощь приходит возможность скрыть из документации 
некоторые строки исходного кода: можно написать 
<code>fn try_main() -&gt; Result&lt;(), ErrorType&gt;</code>, скрыть 
её и вызвать её в скрытом <code>main</code> с 
<code>unwrap</code>. Звучит сложно? Вот пример:</p>
<pre><code class="language-rust ignore">/// Использование скрытой `try_main` в документационных тестах.
///
/// ```
/// # // скрытые строки начинаются с символа `#`, но они всё ещё компилируемы!
/// # fn try_main() -&gt; Result&lt;(), String&gt; { // эта линия оборачивает тело функции, которое отображается в документации
/// let res = try::try_div(10, 2)?;
/// # Ok(()) // возвращается из try_main
/// # }
/// # fn main() { // начало `main` которая выполняет `unwrap()`
/// #    try_main().unwrap(); // вызов `try_main` и извлечение результата
/// #                         // так что в случае ошибки этот тест запаникует
/// # }
pub fn try_div(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from(&quot;Деление на 0&quot;))
    } else {
        Ok(a / b)
    }
}
</code></pre>
<h2><a class="header" href="#Смотрите-также-69" id="Смотрите-также-69">Смотрите также:</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC505</a> по стилю документации</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">Рекомендации для API</a> по документационному тестированию</li>
</ul>
<h1><a class="header" href="#Интеграционное-тестирование" id="Интеграционное-тестирование">Интеграционное тестирование</a></h1>
<p><a href="testing/unit_testing.html">Модульные тесты</a> тестируют по одному модулю изолированно: они малы
и могут проверить не публичный код. Интеграционные тесты являются внешними для вашего пакета и используют
только его открытый интерфейс, таким же образом, как и любой другой код. Их цель в том, чтобы проверить, что многие части вашей библиотеки работают корректно вместе.</p>
<p>Cargo ищет интеграционные тесты в каталоге <code>tests</code> после каталога <code>src</code>.</p>
<p>Файл <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">// Предположим, что наш пакет называется `adder`, для теста он будет внешним кодом.
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
<p>Файл с тестом: <code>tests/integration_test.rs</code>:</p>
<pre><code class="language-rust ignore">// мы тестируем extern crate, как и любой другой код.
extern crate adder;

#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>Запустить тесты можно командой <code>cargo test</code>:</p>
<pre><code class="language-shell">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-bcd60824f5fbfe19

running 1 test
test test_add ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Каждый файл с исходным кодом в директории <code>tests</code> компилируется в отдельный пакет. 
Один из путей использовать некоторый общий код между интеграционными тестами - создать модуль с публичными функциями и импортировать их в тестах.</p>
<p>Файл <code>tests/common.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn setup() {
    // некоторый код для настройки, создание необходимых файлов/каталогов, запуск серверов.
}
</code></pre>
<p>Файл с тестом: <code>tests/integration_test.rs</code></p>
<pre><code class="language-rust ignore">// мы тестируем extern crate, как и любой другой код.
extern crate adder;

// импорт общего модуля.
mod common;

#[test]
fn test_add() {
    // использование общего кода.
    common::setup();
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>Модули с общим кодом следуют обычным правилам  <a href="testing/../mod.html">модулей</a>. Общий модуль можно создать как <code>tests/common/mod.rs</code>.</p>
<h1><a class="header" href="#dev-dependencies" id="dev-dependencies"><code>dev-dependencies</code></a></h1>
<p>Иногда возникает необходимость иметь зависимости только для тестов (примеры, бенчмарки). Такие зависимости добавляются в <code>Cargo.toml</code> в секцию
<code>[dev-dependencies]</code>. Эти зависимости не распространяются как зависимости на другие пакеты, которые зависят от этого пакета.</p>
<p>Одним из таких примеров является пакет расширяющий стандартный макрос <code>assert!</code>. Файл <code>Cargo.toml</code>:</p>
<pre><code class="language-ignore"># при стандартной сборке проекта данная зависимость не будет использоваться.
[dev-dependencies]
pretty_assertions = &quot;0.4.0&quot;
</code></pre>
<p>Файл <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">// внешний пакет используется только для тестирования
#[cfg(test)]
#[macro_use]
extern crate pretty_assertions;

pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
</code></pre>
<h2><a class="header" href="#Смотрите-также-70" id="Смотрите-также-70">Смотрите также:</a></h2>
<p>Документация <a href="http://doc.crates.io/specifying-dependencies.html">Cargo</a> по указанию зависимостей.</p>
<h1><a class="header" href="#Небезопасные-операции" id="Небезопасные-операции">Небезопасные операции</a></h1>
<p>В качестве введения в этот раздел процитируем официальную документацию,
&quot;нужно стараться минимизировать количество небезопасного кода в кодовой базе.&quot; Имея это в виду, давайте начнём! Небезопасные аннотации в Rust используются для обхода блокировок
защиты, устанавливаемых компилятором; в частности, существует четыре основных варианта использования небезопасного кода:</p>
<ul>
<li>разыменование сырых указателей</li>
<li>вызов функций или методов, которые являются <code>unsafe</code> (включая вызов функции через FFI см. <a href="std_misc/ffi.html">предыдущую главу</a> книги)</li>
<li>доступ или изменение статических изменяемых переменных</li>
<li>реализация небезопасных типажей</li>
</ul>
<h3><a class="header" href="#Сырые-указатели" id="Сырые-указатели">Сырые указатели</a></h3>
<p>Сырые указатели <code>*</code> и ссылки <code>&amp;T</code> имеют схожую функциональность, но ссылки
всегда безопасны, потому что они гарантированно указывают на достоверные данные за счёт механизма проверки заимствований. Разыменование же сырого указателя можно выполнить только через небезопасный блок.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let raw_p: *const u32 = &amp;10;

    unsafe {
        assert!(*raw_p == 10);
    }
}
</code></pre></pre>
<h3><a class="header" href="#Вызов-небезопасных-функций" id="Вызов-небезопасных-функций">Вызов небезопасных функций</a></h3>
<p>Некоторые функции могут быть объявлены как <code>unsafe</code>, то есть за корректность этого кода несёт ответственность программист, написавший его, вместо компилятора. Пример -
это метод <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html"><code>std::slice::from_raw_parts</code></a>, который создаст срез из указателя на первый элемент и длины.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::slice;

fn main() {
    let some_vector = vec![1, 2, 3, 4];

    let pointer = some_vector.as_ptr();
    let length = some_vector.len();

    unsafe {
        let my_slice: &amp;[u32] = slice::from_raw_parts(pointer, length);

        assert_eq!(some_vector.as_slice(), my_slice);
    }
}
</code></pre></pre>
<p>Для <code>slice::from_raw_parts</code> одно из предположений, которое <em>должно</em> быть поддержано,
что переданный указатель указывает на допустимую память и что в памяти лежит значение правильного типа. Если эти инварианты не поддерживаются, то поведение программы не определено, и неизвестно, что произойдёт.</p>
<h1><a class="header" href="#Совместимость" id="Совместимость">Совместимость</a></h1>
<p>Rust быстро развивается и из-за этого могут возникнуть определённые проблемы совместимости, не смотря на усилия по обеспечению обратной совместимости везде, где это возможно.</p>
<ul>
<li><a href="compatibility/raw_identifiers.html">Сырые идентификаторы</a></li>
</ul>
<h1><a class="header" href="#Сырые-идентификаторы" id="Сырые-идентификаторы">Сырые идентификаторы</a></h1>
<p>В Rust, как и во многих других языках программирования, существует концепция &quot;ключевых слов&quot;.
Эти идентификаторы что-то значат для языка и из-за этого вы не можете использовать их в качестве названия переменных, именах функций и других местах.
Сырые идентификаторы позволяют использовать ключевые слова там, где они обычно не разрешены.
Это особенно полезно, когда Rust вводит новые ключевые слова и библиотеки, использующие старую редакцию Rust, имеют переменные или функции с таким же именем, как и ключевое слово, введённое в новой редакции.</p>
<p>Например, рассмотрим крейт <code>foo</code>, скомпилированный с 2015 редакцией Rust, и который экспортирует функцию с именем <code>try</code>. Это ключевое слово зарезервировано для новой функциональности в 2018 редакции, из-за чего без сырых идентификаторов мы не можем назвать так функцию.</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::try();
}
</code></pre>
<p>Вы получите ошибку:</p>
<pre><code class="language-text">error: expected identifier, found keyword `try`
 --&gt; src/main.rs:4:4
  |
4 | foo::try();
  |      ^^^ expected identifier, found keyword
</code></pre>
<p>Вы можете записать это при помощи сырого идентификатора:</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::r#try();
}
</code></pre>
<h1><a class="header" href="#meta" id="meta">Meta</a></h1>
<p>Некоторые темы не совсем соответствуют тому, как вы программируете, но предоставляют вам инструменты или инфраструктуру, которые делают лучше для всех. Эти темы включают:</p>
<ul>
<li>Документацию: генерирование пользовательской документации с использованием <code>rustdoc</code>.</li>
<li>Тестирование: создание набора тестов для библиотек, чтобы быть уверенным, что ваша библиотека делает то, что должна.</li>
<li>Бенчмаркинг: создание бенчмарков функциональности для уверенности, что она работает быстро.</li>
</ul>
<h1><a class="header" href="#Документация" id="Документация">Документация</a></h1>
<p>Используйте <code>cargo doc</code> для сборки документации в 
<code>target/doc</code>.</p>
<p>Используйте <code>cargo test</code> для запуска всех тестов 
(включая документационные тесты) и <code>cargo test --doc</code> 
для запуска только документационных тестов.</p>
<p>Эти команды, по мере необходимости, будут соответствующим 
образом вызывать <code>rustdoc</code> (и <code>rustc</code>).</p>
<h3><a class="header" href="#Документационные-комментарии" id="Документационные-комментарии">Документационные комментарии</a></h3>
<p>Документационные комментарии очень полезны для больших 
проектов, требующих документирования. Эти комментарии 
компилируются в документацию при запуске <code>rustdoc</code>. Они 
обозначаются как <code>///</code> и поддерживают 
<a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>.</p>
<pre><code class="language-rust editable ignore">#![crate_name = &quot;doc&quot;]

/// Эта структура представляет человека
pub struct Person {
    /// Человек должен иметь имя вне зависимости от того, на сколько Джульетта его ненавидит
    name: String,
}

impl Person {
    /// Возвращает человека с данным ему именем
    ///
    /// # Аргументы
    ///
    /// * `name` - Срез строки, содержащий имя человека
    ///
    /// # Прмер
    ///
    /// ```
    /// // Мы можете писать код на Rust внутри комментариев.
    /// // Если вы передадите `--test` в `rustdoc`, то он проверит его!
    /// use doc::Person;
    /// let person = Person::new(&quot;name&quot;);
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// Дружественное приветствие!
    ///
    /// Говорит &quot;Привет, [name]&quot; для `Person` у которого он вызывается.
    pub fn hello(&amp; self) {
        println!(&quot;Привет, {}!&quot;, self.name);
    }
}

fn main() {
    let john = Person::new(&quot;John&quot;);

    john.hello();
}
</code></pre>
<p>Для запуска тестов сначала соберите код как библиотеку, а затем 
скажите <code>rustdoc</code> где найти эту библиотеку, чтобы он мог 
подключить её к каждому документационному тесту:</p>
<pre><code class="language-shell">$ rustc doc.rs --crate-type lib
$ rustdoc --test --extern doc=&quot;libdoc.rlib&quot; doc.rs
</code></pre>
<h3><a class="header" href="#Смотрите-также-71" id="Смотрите-также-71">Смотрите также:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">The Rust Book: Making Useful Documentation Comments</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/index.html">The Rustdoc Book</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/comments.html#doc-comments">The Reference: Doc comments</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1574-more-api-documentation-conventions.html#appendix-a-full-conventions-text">RFC 1574: API Documentation Conventions</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1946-intra-rustdoc-links.html">RFC 1946: Relative links to other items from doc comments (intra-rustdoc links)</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/ahb50s/is_there_any_documentation_style_guide_for/">Is there any documentation style guide for comments? (reddit)</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-142155799-3', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
